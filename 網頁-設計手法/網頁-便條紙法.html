<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>便條紙法 (Affinity Diagram) 工具</title>
    <!-- 載入 Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 載入 html2canvas (用於截圖) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <!-- Firebase SDKs (Compat version for v8 style usage) -->
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
    <!-- 載入 Inter 字體 -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Noto+Sans+TC:wght@400;500;700&display=swap" rel="stylesheet">
    
    <style>
        /* 自訂樣式 */
        body {
            font-family: 'Inter', 'Noto Sans TC', sans-serif;
        }
        kbd {
            font-family: 'Inter', 'Noto Sans TC', sans-serif;
        }
        /* 畫布背景 */
        #board {
            background-color: #f1f5f9;
            transition: transform 0.1s linear;
            position: relative;
            /* [FIX] 修正縮放原點為左上角，解決縮放後定位跑掉的問題 */
            transform-origin: 0 0;
        }

        #board-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }

        .connection-line {
            stroke: #4b5563; /* gray-600 */
            stroke-width: 2px;
            fill: none;
            marker-end: url(#arrowhead);
            pointer-events: stroke; /* [FIX] 讓線條可以被點擊 (Req 2) */
            cursor: pointer; /* [FIX] 顯示手型游標 (Req 2) */
            transition: stroke-width 0.2s, stroke 0.2s;
        }
        .connection-line:hover {
            stroke-width: 4px; /* [FIX] hover 時加粗方便點擊 */
            stroke: #3b82f6; /* blue-500 */
        }
        .connection-line.selected {
            stroke: #ef4444; /* red-500 選取狀態為紅色 */
            stroke-width: 3px;
        }
        
        /* 線條控制點 */
        .connection-control-point {
            position: absolute;
            width: 12px;
            height: 12px;
            background-color: #ffffff;
            border: 2px solid #ef4444;
            border-radius: 50%;
            cursor: move;
            z-index: 100;
            transform: translate(-50%, -50%);
            pointer-events: auto;
        }
        
        .connection-control-point:hover {
            background-color: #ef4444;
            transform: translate(-50%, -50%) scale(1.3);
        }
        
        .connection-control-line {
            position: absolute;
            border-top: 1px dashed #ef4444;
            pointer-events: none;
            z-index: 99;
        }

        #temp-line {
            stroke: #3b82f6; /* blue-500 */
            stroke-width: 2px;
            stroke-dasharray: 5, 5;
            fill: none;
            marker-end: url(#arrowhead);
        }

        /* 便利貼 */
        .sticky-note {
            width: 220px;
            /* [MODIFIED] 讀取 CSS 變數 */
            min-height: var(--note-min-height, 100px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            transition: box-shadow 0.2s, transform 0.2s, opacity 0.2s;
            cursor: grab;
            display: flex;
            flex-direction: column;
            position: absolute;
            z-index: 10; 
        }

        .sticky-note:active {
            cursor: grabbing;
            transform: scale(1.03);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
            z-index: 50 !important;
        }
        
        .sticky-note.note-title {
            min-height: 0;
        }
        .sticky-note.note-title .editable {
            font-size: 1.25rem; /* text-xl */
            font-weight: 700; /* bold */
            background-color: transparent !important;
            padding: 0.5rem 1rem;
        }
        .sticky-note.note-title .editable:focus {
             background-color: #ffffff !important;
        }
        
        /* 群組區塊 */
        .group-container {
            min-width: 400px;
            min-height: 300px;
            background-color: rgba(229, 231, 235, 0.7); /* bg-gray-200/70 */
            border: 1px solid #d1d5db; /* border-gray-300 */
            z-index: 1 !important; 
            backdrop-filter: blur(2px);
            /* [NEW] 讓 resize handle 可以定位 (Req 1) */
            position: absolute; 
        }
        .group-container .editable {
            background-color: transparent !important;
            font-size: 1.125rem; /* text-lg */
            font-weight: 600; /* semibold */
            color: #1f2937; /* text-gray-800 */
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #d1d5db;
            flex-grow: 0; 
            min-height: 0;
            border-radius: 0;
        }
        .group-container .editable:focus {
            background-color: #fff !important;
        }
        .group-container.selected {
            border-color: #3b82f6;
        }


        .sticky-note.selected {
            box-shadow: 0 0 0 2px #3b82f6, 0 10px 20px rgba(0, 0, 0, 0.2);
            z-index: 40 !important;
        }
        
        .note-header {
            display: flex;
            align-items: center;
            padding: 0.5rem 0.75rem;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            cursor: pointer;
            user-select: none;
        }
        
        .note-title-text {
            flex-grow: 1;
            font-weight: 600;
            font-size: 0.95rem;
            outline: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        
        .note-title-text[contenteditable="true"] {
            user-select: text;
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
        }
        
        .collapse-icon {
            width: 16px;
            height: 16px;
            margin-right: 0.5rem;
            transition: transform 0.2s;
            flex-shrink: 0;
        }
        
        .sticky-note.collapsed .collapse-icon {
            transform: rotate(-90deg);
        }
        
        .note-content {
            padding: 0.75rem;
            font-size: var(--note-font-size, 0.875rem);
            line-height: 1.4;
            outline: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            overflow: hidden;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        .note-content[contenteditable="true"] {
            user-select: text;
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
        }
        
        .sticky-note.collapsed {
            min-height: auto;
            height: auto;
        }
        
        .sticky-note.collapsed .note-content {
            display: none;
        }
        
        .editable {
            flex-grow: 1;
            padding: 0.75rem;
            /* [MODIFIED] 讀取 CSS 變數 */
            font-size: var(--note-font-size, 0.875rem);
            line-height: 1.4;
            outline: none;
            border-radius: 0 0 0.5rem 0.5rem;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            cursor: inherit;
            /* [FIX] 文字水平垂直置中 (Req 1) */
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            word-break: break-word; /* 避免長單字撐開 */
        }
        
        .editable:focus {
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            user-select: text;
            cursor: text;
            background-color: #fff;
        }
        
        /* 浮動工具列 */
        .toolbar {
            opacity: 0;
            visibility: hidden;
            transform: translateY(10px);
            transition: opacity 0.2s, transform 0.2s, visibility 0.2s;
            z-index: 1000;
            position: fixed;
            background-color: white;
            border-radius: 0.5rem; /* rounded-lg */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* shadow-xl */
            padding: 0.5rem; /* p-2 */
            display: flex;
            align-items: center;
        }
        
        .toolbar.visible {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }
        
        .align-button {
            width: 2rem; /* w-8 */
            height: 2rem; /* h-8 */
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 0.25rem; /* rounded */
            color: #4b5563; /* text-gray-600 */
        }
        .align-button:hover:not(:disabled) {
            background-color: #f3f4f6; /* hover:bg-gray-100 */
        }
        .align-button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        .align-button svg {
            width: 1.25rem; /* w-5 */
            height: 1.25rem; /* h-5 */
        }
        .toolbar-divider {
            width: 1px;
            height: 1.5rem; /* h-6 */
            background-color: #d1d5db; /* bg-gray-300 */
            margin-left: 0.25rem; /* mx-1 */
            margin-right: 0.25rem;
        }

        .connector-node {
            position: absolute;
            width: 12px;
            height: 12px;
            background-color: #fff;
            border: 2px solid #3b82f6; /* blue-500 */
            border-radius: 50%;
            z-index: 11;
            cursor: crosshair;
            opacity: 0;
            transition: opacity 0.2s, background-color 0.2s;
            pointer-events: none;
        }
        
        /* [MODIFIED] 群組被選取時不顯示節點 (Req 1) */
        .sticky-note.selected.single-select:not(.group-container) .connector-node {
            opacity: 1;
            pointer-events: auto;
        }
        
        /* [MODIFIED] 群組作為目標時不顯示節點 (Req 1) */
        .sticky-note.connection-target:not(.group-container) .connector-node {
            opacity: 1;
        }
        
        .connector-node:hover {
            background-color: #3b82f6;
        }

        .node-top { top: -6px; left: 50%; transform: translateX(-50%); }
        .node-right { right: -6px; top: 50%; transform: translateY(-50%); }
        .node-bottom { bottom: -6px; left: 50%; transform: translateX(-50%); }
        .node-left { left: -6px; top: 50%; transform: translateY(-50%); }

        #selection-box {
            position: absolute;
            border: 1px dashed #3b82f6; /* blue-500 */
            background-color: rgba(59, 130, 246, 0.1);
            z-index: 999;
            pointer-events: none;
            display: none;
        }
        
        .action-button {
            display: inline-flex;
            align-items: center;
            vertical-align: middle;
            background-color: #ffffff;
            color: #374151; /* text-gray-700 */
            font-size: 0.875rem; /* 14px */
            font-weight: 500; /* medium */
            padding: 0.5rem 1rem; /* 8px 16px */
            border-radius: 0.5rem; /* 8px */
            border: 1px solid #d1d5db; /* border-gray-300 */
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            transition: all 0.2s ease-in-out;
            cursor: pointer;
        }
        .action-button:hover {
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            border-color: #9ca3af; /* border-gray-400 */
        }
        .action-button svg {
            width: 1.25rem; /* 20px */
            height: 1.25rem; /* 20px */
            margin-right: 0.5rem; /* 8px */
            color: #6b7280; /* text-gray-500 */
        }
        
        .warning-button {
            background-color: #ef4444; /* bg-red-500 */
            color: #ffffff; /* text-white */
            border-color: #ef4444;
        }
        .warning-button:hover {
            background-color: #dc2626; /* hover:bg-red-600 */
            border-color: #dc2626;
        }
        .warning-button svg {
            color: #fef2f2; /* text-red-50 */
        }

        .top-right-buttons {
            position: fixed;
            top: 1.5rem;
            right: 5.75rem;
            z-index: 60;
            display: flex;
            gap: 0.75rem;
        }

        .icon-button {
            padding: 0.75rem;
            border-radius: 9999px;
            background-color: #ffffff;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            color: #2563eb;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.2s ease;
        }

        .icon-button:hover {
            background-color: #eff6ff;
            transform: translateY(-1px);
        }

        .icon-button svg {
            width: 1.5rem;
            height: 1.5rem;
            display: block;
        }

        .floating-action-button {
            position: fixed;
            padding: 0.75rem;
            border-radius: 9999px;
            background-color: #ffffff;
            color: #2563eb;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            border: none;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.2s ease;
            z-index: 60;
        }

        .floating-action-button:hover {
            background-color: #eff6ff;
            transform: translateY(-1px);
        }

        .floating-action-button svg {
            width: 1.5rem;
            height: 1.5rem;
            display: block;
        }

        #help-button {
            top: 1.5rem;
            right: 1.5rem;
        }


        .modal-overlay {
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 4000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal {
            position: fixed;
            inset: 0;
            z-index: 4005;
            overflow-y: auto;
        }

        .modal.hidden {
            display: none;
        }

        .modal-container {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 1rem;
            position: relative;
            z-index: 4010;
            pointer-events: none;
        }

        #help-modal-overlay {
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(2px);
            z-index: 4008;
        }

        .modal-content {
            position: relative;
            width: 100%;
            background-color: #ffffff;
            border-radius: 0.5rem;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            z-index: 4015;
            pointer-events: auto;
        }

        .close-modal-button {
            position: absolute;
            top: 1rem;
            right: 1rem;
            color: #9ca3af;
            background: none;
            border: none;
            cursor: pointer;
            padding: 0.25rem;
            transition: color 0.15s ease-in-out;
        }

        .close-modal-button:hover {
            color: #4b5563;
        }

        .close-modal-button svg {
            width: 1.5rem;
            height: 1.5rem;
        }

        @media (max-width: 768px) {
            .top-right-buttons {
                top: 1rem;
                right: 1rem;
            }

            #help-button {
                top: 1rem;
                right: 1rem;
            }

        }
        
        /* [NEW] 群組的 resize handle (Req 1) */
        /* [MODIFIED] 替換舊的 .resize-handle (Req 1) */
        .resize-handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background-color: #fff;
            border: 2px solid #3b82f6; /* blue-500 */
            border-radius: 2px;
            z-index: 6;
            display: none; /* 預設隱藏 */
            opacity: 0.8;
        }
        .resize-handle:hover {
            opacity: 1;
            background-color: #3b82f6;
        }
        .group-container.selected .resize-handle {
            display: block; /* 選取群組時顯示 */
        }
        .resize-handle-tl { top: -6px; left: -6px; cursor: nwse-resize; }
        .resize-handle-t  { top: -6px; left: 50%; transform: translateX(-50%); cursor: ns-resize; }
        .resize-handle-tr { top: -6px; right: -6px; cursor: nesw-resize; }
        .resize-handle-l  { top: 50%; left: -6px; transform: translateY(-50%); cursor: ew-resize; }
        .resize-handle-r  { top: 50%; right: -6px; transform: translateY(-50%); cursor: ew-resize; }
        .resize-handle-bl { bottom: -6px; left: -6px; cursor: nesw-resize; }
        .resize-handle-b  { bottom: -6px; left: 50%; transform: translateX(-50%); cursor: ns-resize; }
        .resize-handle-br { bottom: -6px; right: -6px; cursor: nwse-resize; }

        /* [NEW] 智慧對齊線 (Req 2) */
        .snap-line {
            position: absolute;
            background-color: #ef4444; /* red-500 */
            z-index: 1000;
            display: none;
            opacity: 0.7;
        }
        #snap-line-v { width: 1px; height: 100%; top: 0; }
        #snap-line-h { height: 1px; width: 100%; left: 0; }

        /* Status Indicator */
        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
            margin-left: 8px;
        }
        .status-connecting { background-color: #f59e0b; } /* Orange */
        .status-connected { background-color: #22c55e; } /* Green */
        .status-disconnected { background-color: #9ca3af; } /* Gray */

        /* [NEW] 純文字節點 (Req 1) */
        .sticky-note.text-node {
            /* [MODIFIED] 移除強制透明，改為 20% 不透明度 (Req) */
            --tw-bg-opacity: 0.2;
            box-shadow: none !important;
            border: 1px dashed transparent; /* 預設透明邊框，方便選取時顯示 */
            min-height: auto !important; /* [FIX] 自動高度 (Req 1) */
            height: auto !important; /* [FIX] 自動高度 (Req 1) */
            width: auto !important; /* [FIX] 自動寬度 (Req 1) */
            min-width: 50px; /* 最小寬度 */
        }
        .sticky-note.text-node:hover {
            border-color: #cbd5e1; /* hover 時顯示淡邊框 */
        }
        .sticky-note.text-node.selected {
            border: 2px solid #3b82f6; /* 選取時顯示藍框 */
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }
        .sticky-note.text-node .editable {
            padding: 1px 4px; /* [FIX] 緊湊 padding (Req 1) */
            min-height: auto;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* [NEW] 關聯線文字標籤 (Req 2) */
        .connection-label {
            position: absolute;
            background-color: #000000;
            color: #ffffff;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 20; /* 高於關聯線 (z-index 5) 和便利貼 (z-index 10) */
            cursor: pointer;
            transform: translate(-50%, -50%); /* 置中 */
            white-space: nowrap;
            max-width: 150px;
            overflow: hidden;
            text-overflow: ellipsis;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: transform 0.1s;
        }
        .connection-label:hover {
            transform: translate(-50%, -50%) scale(1.1);
            z-index: 25;
        }
        .connection-label.selected {
            box-shadow: 0 0 0 2px #3b82f6, 0 4px 8px rgba(0,0,0,0.3);
            z-index: 30;
        }
        .connection-label:focus {
            outline: none;
            background-color: #000000; /* 編輯時保持黑色背景 */
            color: #ffffff;
            min-width: 50px;
            z-index: 30;
            overflow: visible;
        }

        /* [NEW] 圖片節點 (Req) */
        .sticky-note.image-node {
            background-color: transparent !important;
            box-shadow: none !important;
            border: none;
            padding: 0;
        }
        .sticky-note.image-node img {
            width: 100%;
            height: 100%;
            object-fit: fill;
            pointer-events: none;
            display: block;
            user-select: none;
            -webkit-user-drag: none;
        }
        .sticky-note.image-node.selected {
            outline: 2px solid #3b82f6;
        }

        /* [NEW] 旋轉控制點 */
        .rotate-handle {
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            width: 12px;
            height: 12px;
            background-color: #fff;
            border: 2px solid #3b82f6;
            border-radius: 50%;
            cursor: grab;
            z-index: 20;
            display: none;
        }
        .rotate-line {
            position: absolute;
            top: -30px;
            left: 50%;
            width: 1px;
            height: 30px;
            background-color: #3b82f6;
            transform: translateX(-50%);
            pointer-events: none;
            display: none;
        }
        .sticky-note.selected .rotate-handle,
        .sticky-note.selected .rotate-line {
            display: block;
        }

    </style>
</head>
<body class="bg-gray-100 overflow-hidden"> 

    <!-- 頂部工具列 -->
    <header class="fixed top-4 left-4 z-50 flex space-x-2">
        <button id="add-group-btn" class="action-button">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" d="M3.75 9.75h16.5m-16.5 4.5h16.5m-16.5 4.5h16.5m-16.5-13.5h16.5a1.5 1.5 0 0 1 1.5 1.5v10.5a1.5 1.5 0 0 1-1.5 1.5h-16.5a1.5 1.5 0 0 1-1.5-1.5v-10.5a1.5 1.5 0 0 1 1.5-1.5z" />
            </svg>
            新增群組
        </button>
        <!-- [NEW] 插入文字按鈕 (Req 1) -->
        <button id="add-text-btn" class="action-button">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" d="M16.862 4.487l1.687-1.688a1.875 1.875 0 112.652 2.652L10.582 16.07a4.5 4.5 0 01-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 011.13-1.897l8.932-8.931zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0115.75 21H5.25A2.25 2.25 0 013 18.75V8.25A2.25 2.25 0 015.25 6H10" />
            </svg>
            插入文字
        </button>
        <div class="w-px h-10 bg-gray-300 mx-1"></div>
        <input type="file" id="import-input" accept="application/json" class="hidden">
        <button id="import-btn" class="action-button">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5m-13.5-9L12 3m0 0 4.5 4.5M12 3v13.5" />
            </svg>
            匯入
        </button>
        <button id="export-btn" class="action-button">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5M16.5 12L12 16.5m0 0L7.5 12m4.5 4.5V3" />
            </svg>
            匯出
        </button>
        <button id="collab-btn" class="action-button">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" d="M18 18.72a9.094 9.094 0 0 0 3.741-.479 3 3 0 0 0-4.682-2.72m.94 3.198.001.031c0 .225-.012.447-.037.666A11.944 11.944 0 0 1 12 21c-2.17 0-4.207-.576-5.963-1.584A6.062 6.062 0 0 1 6 18.719m12 0a5.971 5.971 0 0 0-.941-3.197m0 0A5.995 5.995 0 0 0 12 12.75a5.995 5.995 0 0 0-5.058 2.772m0 0a3 3 0 0 0-4.681 2.72 8.986 8.986 0 0 0 3.74.477m.94-3.197a5.971 5.971 0 0 0-.94 3.197M15 6.75a3 3 0 1 1-6 0 3 3 0 0 1 6 0Zm6 3a2.25 2.25 0 1 1-4.5 0 2.25 2.25 0 0 1 4.5 0Zm-13.5 0a2.25 2.25 0 1 1-4.5 0 2.25 2.25 0 0 1 4.5 0Z" />
            </svg>
            多人協作
            <span class="status-indicator status-disconnected"></span>
        </button>
        <button id="screenshot-btn" class="action-button">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M6.827 6.175A2.31 2.31 0 0 1 5.186 7.23c-.38.054-.757.112-1.134.174a2.31 2.31 0 0 0-1.64 2.288v7.517A2.31 2.31 0 0 0 4.615 21h14.77a2.31 2.31 0 0 0 2.31-2.31v-7.517a2.31 2.31 0 0 0-1.64-2.288c-.377-.062-.754-.12-1.134-.174a2.31 2.31 0 0 1-1.64-1.055l-.822-1.316a2.192 2.192 0 0 0-1.736-1.039 48.776 48.776 0 0 0-5.232 0 2.192 2.192 0 0 0-1.736 1.04l-.821 1.316Z" /><path stroke-linecap="round" stroke-linejoin="round" d="M16.5 12.75a4.5 4.5 0 1 1-9 0 4.5 4.5 0 0 1 9 0ZM18.75 10.5h.008v.008h-.008V10.5Z" /></svg>
            截圖
        </button>
        <button id="clear-btn" class="action-button warning-button">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" d="M14.74 9l-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 0 1-2.244 2.077H8.084a2.25 2.25 0 0 1-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 0 0-3.478-.397m-12.503 0l-.165.51a2.25 2.25 0 0 1-2.244 2.077H8.084a2.25 2.25 0 0 1-2.244-2.077L4.772 5.79m14.456 0l-3.477-.397m-12.503 0l3.477.397m6.51 0l-3.477-.397M4.772 5.79L4.5 5.25m0 0l-.346-1.023a1.125 1.125 0 0 1 1.123-1.404h10.004a1.125 1.125 0 0 1 1.123 1.404l-.346 1.023m-1.715 0a48.108 48.108 0 0 0-3.478-.397m-4.788 0a48.108 48.108 0 0 1-3.478-.397" />
            </svg>
            清空
        </button>
    </header>

    <!-- 主畫布 -->
    <div id="board-container" class="w-screen h-screen relative overflow-hidden cursor-grab">
        <div id="board" class="absolute inset-0 w-full h-full">
            <svg id="board-svg">
                <defs>
                    <marker id="arrowhead" markerWidth="10" markerHeight="7" 
                          refX="8" refY="3.5" orient="auto" markerUnits="strokeWidth">
                        <polygon points="0 0, 10 3.5, 0 7" fill="#4b5563" />
                    </marker>
                </defs>
            </svg>
            
            <div id="selection-box"></div>

            <!-- [NEW] 智慧對齊線 (Req 2) -->
            <div id="snap-line-v" class="snap-line"></div>
            <div id="snap-line-h" class="snap-line"></div>
        </div>
    </div>

    <!-- 浮動工具列 (單一物件) -->
    <div id="context-menu" class="toolbar space-x-1">
        <button data-color="bg-yellow-200" class="w-6 h-6 rounded-full bg-yellow-200 border-2 border-white hover:ring-2 hover:ring-blue-500"></button>
        <button data-color="bg-green-200" class="w-6 h-6 rounded-full bg-green-200 border-2 border-white hover:ring-2 hover:ring-blue-500"></button>
        <button data-color="bg-blue-200" class="w-6 h-6 rounded-full bg-blue-200 border-2 border-white hover:ring-2 hover:ring-blue-500"></button>
        <button data-color="bg-pink-200" class="w-6 h-6 rounded-full bg-pink-200 border-2 border-white hover:ring-2 hover:ring-blue-500"></button>
        <button data-color="bg-purple-200" class="w-6 h-6 rounded-full bg-purple-200 border-2 border-white hover:ring-2 hover:ring-blue-500"></button>
        <button data-color="bg-gray-200" class="w-6 h-6 rounded-full bg-gray-200 border-2 border-white hover:ring-2 hover:ring-blue-500"></button>
        <div class="toolbar-divider"></div>
        <button data-action="title" title="切換為標題" class="w-7 h-7 flex items-center justify-center rounded hover:bg-gray-100 text-gray-700">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 4H4a2 2 0 00-2 2v10m9-12v12m-5-7h10"></path></svg>
        </button>
        <!-- [NEW] 新增 "移除關聯線" 按鈕 -->
        <button data-action="delete-lines" title="移除關聯線" class="w-7 h-7 flex items-center justify-center rounded hover:bg-gray-100 text-gray-700">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899l4-4a4 4 0 00-5.656-5.656l-1.1 1.1"></path></svg>
        </button>
        <button data-action="delete" title="刪除" class="w-7 h-7 flex items-center justify-center rounded hover:bg-gray-100 text-red-500" id="note-delete-btn">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
        </button>
    </div>

    <!-- 對齊工具列 (多物件) -->
    <div id="align-toolbar" class="toolbar space-x-0">
        <button id="align-left" class="align-button" title="靠左對齊">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M3 3a1 1 0 011-1h2a1 1 0 011 1v14a1 1 0 01-1 1H4a1 1 0 01-1-1V3zm8 4a1 1 0 011-1h2a1 1 0 011 1v6a1 1 0 01-1 1h-2a1 1 0 01-1-1V7z" clip-rule="evenodd"></path></svg>
        </button>
        <button id="align-center-h" class="align-button" title="水平置中">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path d="M10 3a1 1 0 00-1 1v12a1 1 0 002 0V4a1 1 0 00-1-1zM4 3a1 1 0 00-1 1v12a1 1 0 002 0V4a1 1 0 00-1-1zM16 3a1 1 0 00-1 1v12a1 1 0 002 0V4a1 1 0 00-1-1z"></path></svg>
        </button>
        <button id="align-right" class="align-button" title="靠右對齊">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M13 3a1 1 0 011-1h2a1 1 0 011 1v14a1 1 0 01-1 1h-2a1 1 0 01-1-1V3zm-8 4a1 1 0 011-1h2a1 1 0 011 1v6a1 1 0 01-1 1H6a1 1 0 01-1-1V7z" clip-rule="evenodd"></path></svg>
        </button>
        <div class="toolbar-divider"></div>
        <button id="align-top" class="align-button" title="靠上對齊">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="rotate-90"><path fill-rule="evenodd" d="M3 3a1 1 0 011-1h2a1 1 0 011 1v14a1 1 0 01-1 1H4a1 1 0 01-1-1V3zm8 4a1 1 0 011-1h2a1 1 0 011 1v6a1 1 0 01-1 1h-2a1 1 0 01-1-1V7z" clip-rule="evenodd"></path></svg>
        </button>
        <button id="align-middle-v" class="align-button" title="垂直置中">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="rotate-90"><path d="M10 3a1 1 0 00-1 1v12a1 1 0 002 0V4a1 1 0 00-1-1zM4 3a1 1 0 00-1 1v12a1 1 0 002 0V4a1 1 0 00-1-1zM16 3a1 1 0 00-1 1v12a1 1 0 002 0V4a1 1 0 00-1-1z"></path></svg>
        </button>
        <button id="align-bottom" class="align-button" title="靠下對齊">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="rotate-90"><path fill-rule="evenodd" d="M13 3a1 1 0 011-1h2a1 1 0 011 1v14a1 1 0 01-1 1h-2a1 1 0 01-1-1V3zm-8 4a1 1 0 011-1h2a1 1 0 011 1v6a1 1 0 01-1 1H6a1 1 0 01-1-1V7z" clip-rule="evenodd"></path></svg>
        </button>
        <div class="toolbar-divider"></div>
        <button id="dist-h" class="align-button" title="水平均分">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M4 3a1 1 0 00-1 1v12a1 1 0 001 1h2a1 1 0 001-1V4a1 1 0 00-1-1H4zm-2 7a1 1 0 011-1h14a1 1 0 110 2H3a1 1 0 01-1-1zm12-7a1 1 0 00-1 1v12a1 1 0 001 1h2a1 1 0 001-1V4a1 1 0 00-1-1h-2z" clip-rule="evenodd"></path></svg>
        </button>
        <button id="dist-v" class="align-button" title="垂直均分">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="rotate-90"><path fill-rule="evenodd" d="M4 3a1 1 0 00-1 1v12a1 1 0 001 1h2a1 1 0 001-1V4a1 1 0 00-1-1H4zm-2 7a1 1 0 011-1h14a1 1 0 110 2H3a1 1 0 01-1-1zm12-7a1 1 0 00-1 1v12a1 1 0 001 1h2a1 1 0 001-1V4a1 1 0 00-1-1h-2z" clip-rule="evenodd"></path></svg>
        </button>
        <!-- [NEW] 多選刪除按鈕 -->
        <div class="toolbar-divider"></div>
        <button id="delete-selected-btn" class="align-button" title="刪除選取項目">
            <svg class="w-5 h-5 text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
        </button>
    </div>

    <!-- 設定按鈕 (右上角群組) -->
    <div class="top-right-buttons">
        <button id="settings-button" class="icon-button" title="設定">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" d="M10.343 3.94c.09-.542.56-.94 1.11-.94h1.093c.55 0 1.02.398 1.11.94l.149.894c.07.424.384.764.78.93.398.164.855.142 1.205-.108l.737-.527a1.125 1.125 0 0 1 1.45.12l.773.774c.39.389.44 1.002.12 1.45l-.527.737c-.25.35-.272.806-.108 1.204.165.397.505.71.93.78l.893.15c.543.09.94.56.94 1.11v1.093c0 .55-.397 1.02-.94 1.11l-.893.149c-.425.07-.765.383-.93.78-.165.398-.142.854.108 1.204l-.527.738c.32.447.27.96-.12 1.45l-.774.773a1.125 1.125 0 0 1-1.449.12l-.738-.527c-.35-.25-.806-.272-1.203-.108-.398.165-.71.505-.78.93l-.15.893c-.09.543-.56.94-1.11.94h-1.094c-.55 0-1.019-.397-1.11-.94l-.149-.893c-.07-.425-.383-.765-.78-.93-.398-.164-.854-.142-1.204.108l-.738.527c-.447.32-.96.27-1.45-.12l-.773-.774a1.125 1.125 0 0 1-.12-1.45l.527-.737c.25-.35.272-.806.108-1.204-.165-.397-.505-.71-.93-.78l-.894-.15c-.542-.09-.94-.56-.94-1.11v-1.094c0-.55.398-1.02.94-1.11l.894-.149c.424-.07.764-.383.93-.78.165-.398.142-.854-.108-1.204l-.527-.738a1.125 1.125 0 0 1 .12-1.45l.773-.773a1.125 1.125 0 0 1 1.45-.12l.737.527c.35.25.807.272 1.204.108.397-.165.71-.505.78-.93l.15-.893zM12 15.75a3.75 3.75 0 1 0 0-7.5 3.75 3.75 0 0 0 0 7.5z" />
            </svg>
        </button>
    </div>

    <!-- [MODIFIED] 提示訊息 (Req 3) -->
    <button id="help-button" class="floating-action-button" title="查看使用說明" aria-label="查看使用說明">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-6 h-6">
           <path stroke-linecap="round" stroke-linejoin="round" d="M9.879 7.519c1.171-1.025 3.071-1.025 4.242 0 1.172 1.025 1.172 2.687 0 3.712-.203.179-.43.326-.67.442-.745.361-1.45.999-1.45 1.827v.75M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Zm-9 5.25h.008v.008H12v-.008Z" />
       </svg>
    </button>
    
    <div id="help-modal" class="modal hidden" aria-hidden="true">
        <div id="help-modal-overlay"></div>
        <div class="modal-container">
            <div id="help-modal-content" class="modal-content w-full max-w-3xl p-6 md:p-8 overflow-y-auto" style="max-height: 85vh;">
                <button id="help-modal-close-btn" class="close-modal-button" aria-label="關閉說明視窗">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M6 18 18 6M6 6l12 12" />
                    </svg>
                </button>

                <div class="space-y-4">
                    <h2 class="text-2xl font-bold text-slate-800">方法介紹：便條紙法 (Affinity Diagram / KJ 法)</h2>
                    <div class="prose max-w-none text-slate-700">
                        <table class="w-full border-collapse border border-slate-200">
                            <tbody class="align-baseline">
                                <tr class="border-b border-slate-200">
                                    <td class="p-3 bg-slate-50 font-semibold w-1/4">一句話總結</td>
                                    <td class="p-3">讓大量的零散資訊「自動歸位」，從混亂中浮現出洞見與結構。</td>
                                </tr>
                                <tr class="border-b border-slate-200">
                                    <td class="p-3 bg-slate-50 font-semibold">核心概念</td>
                                    <td class="p-3">這是一種「由下而上 (Bottom-up)」的資料分類法。它不預先設定任何分類框架，而是讓團隊成員透過直覺與合作，將大量的質化資料（如：用戶訪談筆記、點子、觀察）進行分組，最終讓資料本身的關聯性「自然地長出」有意義的主題與架構。</td>
                                </tr>
                                <tr class="border-b border-slate-200">
                                    <td class="p-3 bg-slate-50 font-semibold">解決的核心問題</td>
                                    <td class="p-3">當你面對一大堆看似混亂、零散的質化數據（例如：上百張的便利貼、訪談逐字稿、腦力激盪的點子），感到不知所措時。便條紙法能幫助團隊綜觀與收斂、發掘模式，並建立共識。</td>
                                </tr>
                                <tr class="border-b border-slate-200">
                                    <td class="p-3 bg-slate-50 font-semibold">最佳使用時機</td>
                                    <td class="p-3">主要用於「探索期」與「發想期」。<br>• 用戶研究後： 用來統整和分析所有質化發現。<br>• 腦力激盪後： 用來分類和組織大量的創意點子。</td>
                                </tr>
                                <tr>
                                    <td class="p-3 bg-slate-50 font-semibold">使用流程說明</td>
                                    <td class="p-3">
                                        <ol class="list-decimal list-inside space-y-1">
                                            <li><strong>準備資料：</strong> 將所有的資料點（如：一句用戶原話）分別寫在「一張」便利貼上。</li>
                                            <li><strong>隨機貼上：</strong> 將所有便利貼隨機貼在白板上。</li>
                                            <li><strong>靜默分組：</strong> 團隊成員「安靜地」開始移動便利貼，將相似的聚集在一起。</li>
                                            <li><strong>命名與討論：</strong> 為每一個群組下一個精準的「標題卡」。</li>
                                            <li><strong>建立架構：</strong> 檢查群組之間是否還有更高層次的關聯。</li>
                                            <li><strong>總結洞見：</strong> 討論浮現的關鍵主題、痛點與機會點。</li>
                                        </ol>
                                    </td>
                                </tr>
                            </tbody>
                        </table>

                        <div class="mt-8 space-y-4">
                            <h3 class="text-xl font-semibold text-slate-800">功能操作指南（操作流程）</h3>
                            <table class="w-full border-collapse border border-slate-200 text-slate-800">
                                <tbody class="align-baseline">
                                    <tr class="border-b border-slate-200">
                                        <td class="p-3 bg-slate-50 font-semibold w-1/3">操作</td>
                                        <td class="p-3">操作說明</td>
                                    </tr>
                                    <tr class="border-b border-slate-200">
                                        <td class="p-3 bg-slate-50 font-semibold">新增群組 / 便利貼</td>
                                        <td class="p-3">使用左上角 <code>#add-group-btn</code> 新增群組，或使用新增貼文按鈕在畫布加入便利貼。</td>
                                    </tr>
                                    <tr class="border-b border-slate-200">
                                        <td class="p-3 bg-slate-50 font-semibold">編輯貼文</td>
                                        <td class="p-3">點擊貼文內的可編輯區 (editable) 直接輸入；離開後自動儲存。</td>
                                    </tr>
                                    <tr class="border-b border-slate-200">
                                        <td class="p-3 bg-slate-50 font-semibold">拖曳與排列</td>
                                        <td class="p-3">拖曳便利貼重新排列位置；使用對齊工具列執行靠左/置中/靠右等動作。</td>
                                    </tr>
                                    <tr class="border-b border-slate-200">
                                        <td class="p-3 bg-slate-50 font-semibold">建立/移除關聯線</td>
                                        <td class="p-3">使用貼文上的連接節點 (connector-node) 拖曳建立連線；工具列可移除關聯線。</td>
                                    </tr>
                                    <tr class="border-b border-slate-200">
                                        <td class="p-3 bg-slate-50 font-semibold">群組大小調整</td>
                                        <td class="p-3">選取群組後使用 <code>resize-handle</code> 調整群組大小。</td>
                                    </tr>
                                    <tr class="border-b border-slate-200">
                                        <td class="p-3 bg-slate-50 font-semibold">匯入 / 匯出 / 截圖</td>
                                        <td class="p-3">使用 <code>#import-btn</code> / <code>#export-btn</code> 管理資料，<code>#screenshot-btn</code> 可下載畫布圖片，<code>#clear-btn</code> 可清空（請先備份）。</td>
                                    </tr>
                                    <tr>
                                        <td class="p-3 bg-slate-50 font-semibold">浮動工具列</td>
                                        <td class="p-3">選取便利貼後會出現 <code>#context-menu</code>，可更換顏色、切換標題、刪除或移除關聯線等。</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 清空確認 Modal -->
    <div id="clear-modal" class="modal-overlay hidden">
        <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-sm">
            <h2 class="text-xl font-bold text-gray-800 mb-4">確認清空畫布？</h2>
            <p class="text-gray-700 mb-6">此動作將移除所有便利貼、群組和關聯線，且無法復原。您確定要繼續嗎？</p>
            <div class="flex justify-end space-x-2">
                <button id="cancel-clear-btn" class="action-button">取消</button>
                <button id="confirm-clear-btn" class="action-button warning-button">確認清空</button>
            </div>
        </div>
    </div>

    <!-- [NEW] 設定 Modal -->
    <div id="settings-modal" class="hidden fixed inset-0 z-[1001] overflow-y-auto">
        <div id="settings-modal-overlay" class="modal-overlay fixed inset-0 w-full h-full" style="background-color: rgba(0, 0, 0, 0.5);"></div>
        
        <div class="modal-container">
            <div class="modal-content relative w-full max-w-md bg-white p-6 md:p-8 rounded-lg shadow-xl">
                <!-- 關閉按鈕 -->
                <button id="close-settings-button" class="absolute top-4 right-4 text-gray-400 hover:text-gray-600">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-6 h-6">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M6 18 18 6M6 6l12 12" />
                    </svg>
                </button>
                
                <!-- 彈窗內容 -->
                <div class="space-y-6">
                    <h2 class="text-2xl font-bold text-gray-800">顯示設定</h2>
                    
                    <!-- 字體大小 -->
                    <div class="space-y-2">
                        <label for="font-size-slider" class="flex justify-between items-center text-sm font-medium text-gray-700">
                            <span>字體大小</span>
                            <span id="font-size-value" class="text-gray-900 font-semibold">14 px</span>
                        </label>
                        <input type="range" id="font-size-slider" min="12" max="24" value="14" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                    </div>

                    <!-- 卡片高度 -->
                    <div class="space-y-2">
                        <label for="card-height-slider" class="flex justify-between items-center text-sm font-medium text-gray-700">
                            <span>卡片最小高度</span>
                            <span id="card-height-value" class="text-gray-900 font-semibold">100 px</span>
                        </label>
                        <input type="range" id="card-height-slider" min="80" max="200" value="100" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                    </div>
                    
                    <!-- 關聯線樣式 -->
                    <div class="space-y-2">
                        <label for="connection-style-select" class="block text-sm font-medium text-gray-700">
                            關聯線樣式
                        </label>
                        <select id="connection-style-select" class="w-full p-2 border border-gray-300 rounded-lg bg-white text-gray-900 focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                            <option value="round">折線（圓角）</option>
                            <option value="cubic">三次貝茲曲線（預設）</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>
    </div>


    <!-- 協作設定視窗 -->
    <div id="collab-modal" class="hidden fixed inset-0 z-[2000] overflow-y-auto">
        <div class="fixed inset-0 w-full h-full bg-black/50 backdrop-blur-sm" id="collab-modal-overlay"></div>
        <div class="flex items-center justify-center min-h-screen p-4 relative pointer-events-none">
            <div class="relative w-full max-w-md bg-white p-6 rounded-lg shadow-xl pointer-events-auto">
                <button id="collab-modal-close-btn" class="absolute top-4 right-4 text-gray-400 hover:text-gray-600">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" /></svg>
                </button>
                
                <h2 class="text-2xl font-bold text-slate-800 mb-4">即時協作</h2>
                
                <!-- 尚未加入 Session -->
                <div id="collab-start-view">
                    <p class="text-slate-600 mb-4">建立一個新的協作空間，邀請他人一起編輯。</p>
                    <div class="mb-4">
                        <label class="block text-sm font-medium text-slate-700 mb-1">設定編輯密碼 (選填)</label>
                        <input type="password" id="collab-password-input" class="w-full p-2 border border-slate-300 rounded focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500" placeholder="若留空則任何人皆可編輯">
                    </div>
                    <button id="create-session-btn" class="w-full bg-indigo-600 text-white py-2 px-4 rounded hover:bg-indigo-700 transition-colors">
                        建立新協作
                    </button>
                </div>

                <!-- 已經在 Session 中 -->
                <div id="collab-active-view" class="hidden">
                    <div class="bg-green-50 text-green-800 p-3 rounded mb-4 flex items-center">
                        <span class="w-2 h-2 bg-green-500 rounded-full mr-2 animate-pulse"></span>
                        正在協作中
                    </div>
                    <p class="text-sm text-slate-600 mb-2">將此連結分享給協作者：</p>
                    <div class="flex space-x-2 mb-4">
                        <input type="text" id="share-link-input" class="flex-1 p-2 border border-slate-300 rounded bg-slate-50 text-slate-500 text-sm" readonly>
                        <button id="copy-link-btn" class="bg-white border border-slate-300 text-slate-700 px-3 py-2 rounded hover:bg-slate-50">
                            複製
                        </button>
                    </div>
                    <p class="text-xs text-slate-400 text-center">Session ID: <span id="display-session-id"></span></p>
                </div>
            </div>
        </div>
    </div>

    <!-- 密碼驗證視窗 -->
    <div id="password-modal" class="hidden fixed inset-0 z-[2010] overflow-y-auto">
        <div class="fixed inset-0 w-full h-full bg-black/80 backdrop-blur-sm"></div>
        <div class="flex items-center justify-center min-h-screen p-4 relative pointer-events-none">
            <div class="relative w-full max-w-sm bg-white p-6 rounded-lg shadow-xl text-center pointer-events-auto">
                <h3 class="text-xl font-bold text-slate-800 mb-2">需要密碼</h3>
                <p class="text-slate-600 mb-4">此協作空間受密碼保護，請輸入密碼以進行編輯。</p>
                <input type="password" id="auth-password-input" class="w-full p-2 border border-slate-300 rounded mb-4 focus:ring-2 focus:ring-indigo-500" placeholder="輸入密碼">
                <button id="auth-password-btn" class="w-full bg-indigo-600 text-white py-2 px-4 rounded hover:bg-indigo-700">
                    確認
                </button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Firebase Configuration & Global Variables ---
            const firebaseConfig = {
                apiKey: "AIzaSyDyB_rJ37rHW1uwpQNASlWc53AjsPwh2EE",
                authDomain: "business-model-canvas-3da74.firebaseapp.com",
                projectId: "business-model-canvas-3da74",
                storageBucket: "business-model-canvas-3da74.firebasestorage.app",
                messagingSenderId: "922978479250",
                appId: "1:922978479250:web:22a62879f85a552da68a4b",
                measurementId: "G-GTVB77BGRM"
            };

            const APP_ID = 'stk-tool-v1';
            let db;
            let auth;
            let currentSessionId = null;
            let unsubscribe = null;
            let isReadOnly = false;
            let localEditPassword = null;
            let isFirebaseReady = false;
            let updateTimeout = null; // For debouncing

            // --- Firebase Initialization ---
            try {
                if (firebase.apps.length === 0) {
                    firebase.initializeApp(firebaseConfig);
                }
                db = firebase.firestore();
                auth = firebase.auth();

                auth.onAuthStateChanged(async (user) => {
                    if (user) {
                        isFirebaseReady = true;
                        console.log("Firebase Auth Ready:", user.uid);
                        
                        // 更新狀態燈號為未連線
                        updateCollabStatus('disconnected');
                        
                        // Check URL for session
                        const urlParams = new URLSearchParams(window.location.search);
                        const session = urlParams.get('session');
                        if (session && !currentSessionId) {
                            await joinSession(session);
                        }
                    } else {
                        await auth.signInAnonymously().catch(console.error);
                    }
                });
            } catch (e) {
                console.warn("Firebase init failed:", e);
            }

            // --- Collaboration UI Elements ---
            const collabButton = document.getElementById('collab-btn');
            // [NEW] 取得狀態燈號
            const collabStatusIndicator = collabButton ? collabButton.querySelector('.status-indicator') : null;
            
            // 初始化狀態燈號
            if (collabStatusIndicator) {
                collabStatusIndicator.classList.add('status-disconnected');
            }
            
            const collabModal = document.getElementById('collab-modal');
            const collabModalOverlay = document.getElementById('collab-modal-overlay');
            const collabModalCloseBtn = document.getElementById('collab-modal-close-btn');
            const createSessionBtn = document.getElementById('create-session-btn');
            const collabStartView = document.getElementById('collab-start-view');
            const collabActiveView = document.getElementById('collab-active-view');
            const shareLinkInput = document.getElementById('share-link-input');
            const copyLinkBtn = document.getElementById('copy-link-btn');
            const displaySessionId = document.getElementById('display-session-id');
            
            const passwordModal = document.getElementById('password-modal');
            const authPasswordInput = document.getElementById('auth-password-input');
            const authPasswordBtn = document.getElementById('auth-password-btn');

            // [NEW] 更新連線狀態燈號
            function updateCollabStatus(status) {
                if (!collabStatusIndicator) return;
                collabStatusIndicator.classList.remove('status-connecting', 'status-connected', 'status-disconnected');
                collabStatusIndicator.classList.add(`status-${status}`);
            }

            // --- Collaboration Functions ---

            // 1. Open Modal
            if (collabButton) {
                collabButton.addEventListener('click', () => {
                    collabModal.classList.remove('hidden');
                    if (currentSessionId) {
                        collabStartView.classList.add('hidden');
                        collabActiveView.classList.remove('hidden');
                        shareLinkInput.value = window.location.href;
                        displaySessionId.textContent = currentSessionId;
                    } else {
                        collabStartView.classList.remove('hidden');
                        collabActiveView.classList.add('hidden');
                    }
                });
            }

            // 2. Close Modal
            const closeCollabModal = () => collabModal.classList.add('hidden');
            if (collabModalOverlay) collabModalOverlay.addEventListener('click', closeCollabModal);
            if (collabModalCloseBtn) collabModalCloseBtn.addEventListener('click', closeCollabModal);

            // 3. Create Session
            if (createSessionBtn) {
                createSessionBtn.addEventListener('click', async () => {
                    if (!isFirebaseReady) {
                        alert("Firebase 尚未連線，請檢查設定。");
                        return;
                    }
                    
                    const password = document.getElementById('collab-password-input').value.trim();
                    createSessionBtn.disabled = true;
                    createSessionBtn.textContent = "建立中...";

                    try {
                        const newSessionId = Math.random().toString(36).substring(2, 10);
                        
                        // Gather current state
                        const currentState = getCurrentState();
                        const initialData = {
                            created: firebase.firestore.FieldValue.serverTimestamp(),
                            editPassword: password || null,
                            boardData: JSON.stringify(currentState)
                        };

                        await db.collection('artifacts').doc(APP_ID)
                            .collection('public').doc('data')
                            .collection('sessions').doc(newSessionId)
                            .set(initialData);

                        localEditPassword = password;
                        await joinSession(newSessionId, true);
                        
                        // Update UI
                        collabStartView.classList.add('hidden');
                        collabActiveView.classList.remove('hidden');
                        shareLinkInput.value = window.location.href;
                        displaySessionId.textContent = newSessionId;
                        createSessionBtn.disabled = false;
                        createSessionBtn.textContent = "建立新協作";

                    } catch (err) {
                        console.error("Error creating session:", err);
                        alert("建立失敗：" + err.message);
                        createSessionBtn.disabled = false;
                        createSessionBtn.textContent = "建立新協作";
                    }
                });
            }

            // 4. Join Session
            async function joinSession(sessionId, justCreated = false) {
                updateCollabStatus('connecting');
                currentSessionId = sessionId;
                
                // Update URL
                const newUrl = `${window.location.pathname}?session=${sessionId}`;
                window.history.pushState({path: newUrl}, '', newUrl);

                // Change button style
                if (collabButton) collabButton.classList.add('bg-indigo-50', 'border-indigo-400');

                if (unsubscribe) unsubscribe();

                unsubscribe = db.collection('artifacts').doc(APP_ID)
                    .collection('public').doc('data')
                    .collection('sessions').doc(sessionId)
                    .onSnapshot((doc) => {
                        if (doc.exists) {
                            updateCollabStatus('connected');
                            const data = doc.data();

                            // Check Password / ReadOnly
                            if (!justCreated && !localEditPassword && data.editPassword && !isReadOnly) {
                                passwordModal.classList.remove('hidden');
                            }

                            // Sync Data
                            if (data.boardData) {
                                // Avoid syncing if user is actively interacting (dragging/resizing)
                                if (isDraggingNote || isDrawingLine || isPanning || isMarqueeing) {
                                    // Skip this update to prevent jumping
                                    return;
                                }
                                
                                // Also check if active element is editable
                                if (document.activeElement && document.activeElement.isContentEditable) {
                                    return;
                                }

                                try {
                                    const remoteState = JSON.parse(data.boardData);
                                    // Compare with current state to avoid unnecessary redraws?
                                    // For now, just restore.
                                    restoreState(remoteState);
                                    // Update history to avoid "undo" reverting to pre-sync state immediately?
                                    // Actually, we should probably clear history or append?
                                    // Let's just set it as the latest state.
                                    history = [remoteState];
                                    historyPointer = 0;
                                } catch (e) {
                                    console.error("Failed to parse remote board data", e);
                                }
                            }
                        } else {
                            alert("此協作 Session 不存在或已被刪除。");
                            currentSessionId = null;
                            updateCollabStatus('disconnected');
                        }
                    }, (error) => {
                        console.error("Sync error:", error);
                        updateCollabStatus('disconnected');
                    });
            }

            // 5. Password Auth
            if (authPasswordBtn) {
                authPasswordBtn.addEventListener('click', () => {
                    const inputPwd = authPasswordInput.value.trim();
                    db.collection('artifacts').doc(APP_ID)
                        .collection('public').doc('data')
                        .collection('sessions').doc(currentSessionId)
                        .get().then(doc => {
                            if (doc.exists && doc.data().editPassword === inputPwd) {
                                localEditPassword = inputPwd;
                                passwordModal.classList.add('hidden');
                                isReadOnly = false;
                                // Trigger a sync to get latest data
                                joinSession(currentSessionId);
                            } else {
                                alert("密碼錯誤");
                            }
                        });
                });
            }

            // 6. Copy Link
            if (copyLinkBtn) {
                copyLinkBtn.addEventListener('click', () => {
                    shareLinkInput.select();
                    document.execCommand('copy');
                    copyLinkBtn.textContent = "已複製";
                    setTimeout(() => copyLinkBtn.textContent = "複製", 2000);
                });
            }

            // 7. Debounced Update Function
            function updateFirestoreDebounced(state) {
                if (!db || !isFirebaseReady || !currentSessionId) return;
                if (isReadOnly) return;

                if (updateTimeout) clearTimeout(updateTimeout);

                updateTimeout = setTimeout(() => {
                    db.collection('artifacts').doc(APP_ID)
                        .collection('public').doc('data')
                        .collection('sessions').doc(currentSessionId)
                        .update({
                            boardData: JSON.stringify(state)
                        }).catch(err => {
                            console.error("Update failed:", err);
                        });
                }, 500);
            }

            // Helper to get current state (extracted from saveState)
            function getCurrentState() {
                const notesState = [];
                board.querySelectorAll('.sticky-note').forEach(note => {
                    const editable = note.querySelector('.editable');
                    notesState.push({
                        id: note.id,
                        x: parseFloat(note.style.left),
                        y: parseFloat(note.style.top),
                        isTitle: note.classList.contains('note-title'),
                        color: note.dataset.color,
                        content: editable ? editable.innerHTML : '',
                        isGroup: note.classList.contains('group-container'),
                        width: note.style.width || null,
                        height: note.style.height || null
                    });
                });
                return {
                    notes: notesState,
                    connections: connections,
                    settings: {
                        fontSize: currentFontSize,
                        minHeight: currentMinHeight
                    }
                };
            }

            const board = document.getElementById('board');
            const boardContainer = document.getElementById('board-container');
            const contextMenu = document.getElementById('context-menu');
            const boardSvg = document.getElementById('board-svg');
            const alignToolbar = document.getElementById('align-toolbar');
            const distHBtn = document.getElementById('dist-h');
            const distVBtn = document.getElementById('dist-v');
            const selectionBox = document.getElementById('selection-box');

            // [NEW] 取得多選刪除按鈕 (Req 4)
            const deleteSelectedBtn = document.getElementById('delete-selected-btn'); // (Req 4)
            
            const addGroupBtn = document.getElementById('add-group-btn');
            const addTextBtn = document.getElementById('add-text-btn'); // [NEW] (Req 1)
            const importBtn = document.getElementById('import-btn');
            const importInput = document.getElementById('import-input');
            const exportBtn = document.getElementById('export-btn');
            const screenshotBtn = document.getElementById('screenshot-btn');
            const clearBtn = document.getElementById('clear-btn');
            
            const clearModal = document.getElementById('clear-modal');
            const cancelClearBtn = document.getElementById('cancel-clear-btn');
            const confirmClearBtn = document.getElementById('confirm-clear-btn');
            
            // [MODIFIED] 取得 headerToolbar (Req 3)
            const headerToolbar = document.querySelector('header');
            // [MODIFIED] 取得 help-button (Req 3)
            const helpButton = document.getElementById('help-button');
            const helpModal = document.getElementById('help-modal');
            const helpModalCloseBtn = document.getElementById('help-modal-close-btn');
            const helpModalOverlay = document.getElementById('help-modal-overlay');

            // [NEW] 取得設定 Modal 的 DOM
            const settingsButton = document.getElementById('settings-button');
            const settingsModal = document.getElementById('settings-modal');
            const closeSettingsButton = document.getElementById('close-settings-button');
            const settingsModalOverlay = document.getElementById('settings-modal-overlay');
            const fontSizeSlider = document.getElementById('font-size-slider');
            const fontSizeValue = document.getElementById('font-size-value');
            const cardHeightSlider = document.getElementById('card-height-slider');
            const cardHeightValue = document.getElementById('card-height-value');
            const connectionStyleSelect = document.getElementById('connection-style-select');

            let selectedNotes = [];
            let isDraggingNote = false;
            let isPanning = false;
            let dragOffsets = new Map();
            let connections = [];
            let isDrawingLine = false;
            let tempLine = null;
            let startNodeInfo = null;
            let zIndexCounter = 100;
            let currentTargetNote = null; 
            let tempSnapTarget = null;
            let history = [];
            let historyPointer = -1;
            let isRestoring = false;
            let scale = 1;
            let panX = 0;
            let panY = 0;
            let isSpacePressed = false;
            let panStartX = 0;
            let panStartY = 0;
            let isMarqueeing = false;
            let marqueeStartX = 0;
            let marqueeStartY = 0;
            
            let childNotesToDrag = new Map();
            
            // [NEW] 複製貼上剪貼簿 (Req 1)
            let clipboard = [];
            
            // [NEW] 選取的關連線
            let selectedConnection = null;
            
            // [NEW] 設定的狀態變數
            let currentFontSize = 14;
            let currentMinHeight = 100;
            let currentConnectionStyle = 'cubic';
            
            // [NEW] 智慧對齊線 (Req 2)
            const snapLineV = document.getElementById('snap-line-v');
            const snapLineH = document.getElementById('snap-line-h');
            const SNAP_THRESHOLD = 5; // 5px (螢幕像素)
            
            // [FIX] 將輔助函數定義移到最前面
            // --- [NEW] 智慧對齊線 邏輯 (Req 2) ---
            function showVLine(x) {
                snapLineV.style.left = `${x}px`;
                snapLineV.style.display = 'block';
            }
            function showHLine(y) {
                snapLineH.style.top = `${y}px`;
                snapLineH.style.display = 'block';
            }
            function hideSnapLines() {
                snapLineV.style.display = 'none';
                snapLineH.style.display = 'none';
            }

            function updateBoardTransform() {
                board.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
            }

            // [NEW] 套用設定到 CSS 變數
            function applySettings() {
                // 將 JS 變數寫入 #board 的 style 中
                board.style.setProperty('--note-font-size', `${currentFontSize}px`);
                board.style.setProperty('--note-min-height', `${currentMinHeight}px`);
                
                // 更新 slider UI (如果 modal 是打開的)
                if (fontSizeSlider) {
                    fontSizeSlider.value = currentFontSize;
                    fontSizeValue.textContent = `${currentFontSize} px`;
                }
                if (cardHeightSlider) {
                    cardHeightSlider.value = currentMinHeight;
                    cardHeightValue.textContent = `${currentMinHeight} px`;
                }
            }

            // --- 事件監聽 (平移/縮放/框選) ---

            boardContainer.addEventListener('wheel', (e) => {
                e.preventDefault();
                const rect = boardContainer.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const mouseXInWorld = (mouseX - panX) / scale;
                const mouseYInWorld = (mouseY - panY) / scale;
                const delta = -e.deltaY * 0.001;
                scale = Math.max(0.1, Math.min(3, scale + delta));
                panX = mouseX - mouseXInWorld * scale;
                panY = mouseY - mouseYInWorld * scale;
                updateBoardTransform();
                updateToolbarPositions();
            }, { passive: false });

            boardContainer.addEventListener('mousedown', (e) => {
                if (e.target === boardContainer || e.target === board) {
                    if (isSpacePressed || e.button === 1) { 
                        isPanning = true;
                        panStartX = e.clientX - panX;
                        panStartY = e.clientY - panY;
                        boardContainer.style.cursor = 'grabbing';
                    } else if (e.button === 0) { 
                        isMarqueeing = true;
                        // [FIX] 使用 getBoardCoordinates 取得正確的世界座標，修正縮放後的框選起始點錯誤
                        const { x: worldX, y: worldY } = getBoardCoordinates(e.clientX, e.clientY);
                        marqueeStartX = e.clientX; // 保留 ClientX 用於計算寬高
                        marqueeStartY = e.clientY;
                        
                        // 使用世界座標設置起始位置
                        selectionBox.style.left = `${worldX}px`;
                        selectionBox.style.top = `${worldY}px`;
                        selectionBox.style.width = '0px';
                        selectionBox.style.height = '0px';
                        selectionBox.style.display = 'block';

                        if (!e.ctrlKey && !e.metaKey) {
                            clearSelection();
                        }
                    }
                }
            });
            
            document.addEventListener('mousemove', (e) => {
                if (isPanning) {
                    panX = e.clientX - panStartX;
                    panY = e.clientY - panStartY;
                    updateBoardTransform();
                    updateToolbarPositions();
                }
                
                if (isMarqueeing) {
                    const currentX = e.clientX;
                    const currentY = e.clientY;
                    const { x: startXWorld, y: startYWorld } = getBoardCoordinates(marqueeStartX, marqueeStartY);
                    const { x: currentXWorld, y: currentYWorld } = getBoardCoordinates(currentX, currentY);
                    const left = Math.min(startXWorld, currentXWorld);
                    const top = Math.min(startYWorld, currentYWorld);
                    const width = Math.abs(currentXWorld - startXWorld);
                    const height = Math.abs(currentYWorld - startYWorld);
                    selectionBox.style.left = `${left}px`;
                    selectionBox.style.top = `${top}px`;
                    selectionBox.style.width = `${width}px`;
                    selectionBox.style.height = `${height}px`;
                }
            });
            
            document.addEventListener('mouseup', (e) => {
                if (isPanning) {
                    isPanning = false;
                    boardContainer.style.cursor = isSpacePressed ? 'grab' : 'grab';
                    if (!isSpacePressed) {
                        boardContainer.style.cursor = 'grab';
                    }
                }
                
                if (isMarqueeing) {
                    isMarqueeing = false;
                    selectionBox.style.display = 'none';
                    
                    // [FIX] 改用世界座標 (World Coordinates) 進行碰撞檢測
                    // 這樣可以完全排除縮放 (scale) 和平移 (pan) 帶來的計算誤差
                    const selLeft = parseFloat(selectionBox.style.left);
                    const selTop = parseFloat(selectionBox.style.top);
                    const selWidth = parseFloat(selectionBox.style.width);
                    const selHeight = parseFloat(selectionBox.style.height);
                    const selRight = selLeft + selWidth;
                    const selBottom = selTop + selHeight;

                    board.querySelectorAll('.sticky-note').forEach(note => {
                        // 取得卡片的世界座標
                        const noteLeft = parseFloat(note.style.left);
                        const noteTop = parseFloat(note.style.top);
                        // 使用 offsetWidth/Height 取得卡片實際大小 (不含 scale)
                        const noteRight = noteLeft + note.offsetWidth;
                        const noteBottom = noteTop + note.offsetHeight;

                        // 判斷是否重疊 (AABB collision detection)
                        const isOverlapping = !(noteRight < selLeft || 
                                              noteLeft > selRight || 
                                              noteBottom < selTop || 
                                              noteTop > selBottom);
                        
                        if (isOverlapping) {
                            addNoteToSelection(note);
                        }
                    });
                    updateToolbarStates();
                }
            });
            
            document.addEventListener('keydown', (e) => {
                const isCtrl = e.ctrlKey || e.metaKey;
                const key = e.key.toLowerCase();
                
                // Ctrl+L 切換摺疊/展開
                if (isCtrl && key === 'l') {
                    e.preventDefault();
                    
                    // 檢查是否有任何便條紙未摺疊
                    const allNotes = Array.from(board.querySelectorAll('.sticky-note')).filter(note => 
                        !note.classList.contains('group-container') && 
                        !note.classList.contains('note-title') && 
                        !note.classList.contains('text-node') &&
                        !note.classList.contains('image-node') &&
                        note.querySelector('.note-content')
                    );
                    
                    const hasUncollapsed = allNotes.some(note => !note.classList.contains('collapsed'));
                    
                    if (hasUncollapsed) {
                        // 如果有未摺疊的，全部摺疊
                        allNotes.forEach(note => {
                            note.classList.add('collapsed');
                            updateConnectionsForNote(note);
                        });
                    } else {
                        // 如果全部都已摺疊，全部展開
                        allNotes.forEach(note => {
                            note.classList.remove('collapsed');
                            updateConnectionsForNote(note);
                        });
                    }
                    
                    saveState();
                    return;
                }
                
                if (document.activeElement.isContentEditable) return;

                // [MODIFIED] 整合 Undo/Redo/Copy/Paste
                if (isCtrl) {
                    switch (key) {
                        case 'z':
                            e.preventDefault();
                            undo();
                            break;
                        case 'y':
                            e.preventDefault();
                            redo();
                            break;
                        // [NEW] 複製功能 (Req 1)
                        case 'c':
                            e.preventDefault();
                            copySelectedNotes();
                            break;
                        // [NEW] 貼上功能 (Req 1) - 移至 paste 事件處理
                        /* case 'v':
                            e.preventDefault();
                            pasteNotes();
                            break; */
                    }
                } else {
                    // [NEW] 刪除功能 (Req 3)
                    if (e.key === 'Delete' || e.key === 'Backspace') {
                        // 避免在編輯文字時刪除
                        if (document.activeElement.isContentEditable || document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') {
                            return;
                        }
                        
                        // 刪除選取的關連線
                        if (selectedConnection) {
                            e.preventDefault();
                            deleteSelectedConnection();
                            return;
                        }
                        
                        // 刪除選取的便利貼
                        if (selectedNotes.length > 0) {
                            e.preventDefault();
                            deleteSelectedNotes();
                        }
                        
                        // 刪除選取的標籤
                        if (window.selectedLabel && window.selectedLabelConnId) {
                            e.preventDefault();
                            const conn = connections.find(c => c.id === window.selectedLabelConnId);
                            if (conn) {
                                conn.label = '';
                                conn.labelColor = null;
                                const labelEl = document.getElementById(`label_${conn.id}`);
                                if (labelEl) labelEl.remove();
                                window.selectedLabel = null;
                                window.selectedLabelConnId = null;
                                contextMenu.classList.remove('visible');
                                saveState();
                            }
                        }
                    }
                }
                
                if (e.code === 'Space' && !isSpacePressed) {
                    e.preventDefault();
                    isSpacePressed = true;
                    if (!isPanning) boardContainer.style.cursor = 'grab';
                }
            });
            
            document.addEventListener('keyup', (e) => {
                if (e.code === 'Space') {
                    isSpacePressed = false;
                    if (!isPanning) boardContainer.style.cursor = 'grab';
                }
            });

            // [NEW] 貼上圖片 (Req)
            document.addEventListener('paste', (e) => {
                if (document.activeElement.isContentEditable || document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') {
                    return;
                }

                const items = e.clipboardData.items;
                let hasImage = false;

                for (let i = 0; i < items.length; i++) {
                    if (items[i].type.indexOf('image') !== -1) {
                        hasImage = true;
                        const blob = items[i].getAsFile();
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            const imgData = event.target.result;
                            const { x, y } = getBoardCoordinates(window.innerWidth / 2, window.innerHeight / 2);
                            
                            const img = new Image();
                            img.onload = () => {
                                let width = img.width;
                                let height = img.height;
                                if (width > 400) {
                                    const ratio = height / width;
                                    width = 400;
                                    height = 400 * ratio;
                                }
                                
                                createNote({
                                    x: x - width / 2,
                                    y: y - height / 2,
                                    width: `${width}px`,
                                    height: `${height}px`,
                                    isImage: true,
                                    imgSrc: imgData
                                });
                            };
                            img.src = imgData;
                        };
                        reader.readAsDataURL(blob);
                        e.preventDefault();
                    }
                }

                // [FIX] 如果剪貼簿沒有圖片，嘗試貼上內部筆記
                if (!hasImage && clipboard.length > 0) {
                    e.preventDefault();
                    pasteNotes();
                }
            });

            boardContainer.addEventListener('dblclick', (e) => {
                if (e.target !== boardContainer && e.target !== board) return;
                if (e.target.closest('header') || e.target.closest('#help-button')) return; 
                
                const { x, y } = getBoardCoordinates(e.clientX, e.clientY);
                createNote({ x, y });
            });

            boardContainer.addEventListener('mousedown', (e) => {
                if (e.target === boardContainer || e.target === board) {
                    if (!isMarqueeing) {
                        clearSelection();
                        clearConnectionSelection(); // [NEW] 清除關連線選取
                    }
                }
            });

            // --- 建立便利貼/群組 ---
            function createNote(options, isRestoring = false) {
                const { 
                    id = `note_${crypto.randomUUID()}`, 
                    x = 100, 
                    y = 100, 
                    isTitle = false, 
                    color = 'bg-yellow-200', 
                    content = '', 
                    isGroup = false, 
                    width, 
                    height, 
                    isTextNode = false,
                    isImage = false, 
                    imgSrc = '',     
                    rotation = 0     
                } = options;

                const note = document.createElement('div');
                note.id = id;
                note.className = 'sticky-note rounded-lg p-0 flex flex-col';
                note.style.left = `${x}px`;
                note.style.top = `${y}px`;
                
                if (width) note.style.width = width;
                if (height) note.style.height = height;
                
                if (rotation) {
                    note.style.transform = `rotate(${rotation}deg)`;
                    note.dataset.rotation = rotation;
                }

                if (isImage) {
                    note.classList.add('image-node');
                    note.dataset.isImage = 'true';
                    note.dataset.imgSrc = imgSrc;
                    
                    const img = document.createElement('img');
                    img.src = imgSrc;
                    img.draggable = false;
                    note.appendChild(img);
                    
                    const rotateLine = document.createElement('div');
                    rotateLine.className = 'rotate-line';
                    note.appendChild(rotateLine);
                    
                    const rotateHandle = document.createElement('div');
                    rotateHandle.className = 'rotate-handle';
                    note.appendChild(rotateHandle);
                    rotateHandle.addEventListener('mousedown', (e) => onRotateMouseDown(e, note));

                } else {
                    note.classList.add(color);
                    note.dataset.color = color;
                    
                    if (isTextNode) {
                        note.classList.add('text-node');
                        note.classList.remove(color);
                        note.dataset.isTextNode = 'true';
                    }

                    // 舊的單一editable模式（用於群組、標題、文字節點）
                    if (isGroup || isTitle || isTextNode) {
                        const editable = document.createElement('div');
                        editable.className = 'editable';
                        editable.contentEditable = false;
                        note.appendChild(editable);
                        
                        if (isTitle) {
                            note.classList.add('note-title');
                        }
                        
                        if (isGroup) {
                            note.classList.add('group-container');
                            editable.innerHTML = content || '群組標題';
                        } else {
                            editable.innerHTML = content || (isTitle ? '標題' : (isTextNode ? '輸入文字' : '輸入文字...'));
                        }

                        note.addEventListener('dblclick', (e) => {
                            if ((e.target === note || e.target === editable || editable.contains(e.target)) && !e.target.closest('.connector-node') && !e.target.closest('.resize-handle')) {
                                editable.contentEditable = true;
                                editable.focus();
                                document.execCommand('selectAll', false, null);
                            }
                        });
                        editable.addEventListener('blur', () => {
                            editable.contentEditable = false;
                            
                            // [NEW] 如果是插入文字節點且內容為空，自動刪除
                            if (note.dataset.isTextNode === 'true') {
                                const text = editable.innerText.trim();
                                if (text === '' || text === '輸入文字') {
                                    removeConnectionsForNote(note);
                                    note.remove();
                                    removeNoteFromSelection(note);
                                    saveState();
                                    return;
                                }
                            }
                            
                            saveState();
                        });
                    } else {
                        // 新的標題+內容模式（用於一般便條紙）
                        const noteHeader = document.createElement('div');
                        noteHeader.className = 'note-header';
                        
                        const collapseIcon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                        collapseIcon.setAttribute('class', 'collapse-icon');
                        collapseIcon.setAttribute('viewBox', '0 0 24 24');
                        collapseIcon.setAttribute('fill', 'currentColor');
                        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        path.setAttribute('d', 'M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z');
                        collapseIcon.appendChild(path);
                        noteHeader.appendChild(collapseIcon);
                        
                        // 解析content來分離標題和內容
                        let titleText = '便條紙標題';
                        let contentText = '內容...';
                        
                        if (content && content.includes('|||')) {
                            const parts = content.split('|||');
                            titleText = parts[0] || '便條紙標題';
                            contentText = parts[1] || '內容...';
                        } else if (content) {
                            contentText = content;
                        }
                        
                        const noteTitleText = document.createElement('div');
                        noteTitleText.className = 'note-title-text';
                        noteTitleText.contentEditable = false;
                        noteTitleText.innerHTML = titleText;
                        noteHeader.appendChild(noteTitleText);
                        
                        note.appendChild(noteHeader);
                        
                        const noteContent = document.createElement('div');
                        noteContent.className = 'note-content';
                        noteContent.contentEditable = false;
                        noteContent.innerHTML = contentText;
                        note.appendChild(noteContent);
                        
                        // 點擊header摺疊/展開
                        noteHeader.addEventListener('mousedown', (e) => {
                            // 如果點擊的是標題文字，不處理摺疊
                            if (e.target === noteTitleText || noteTitleText.contains(e.target)) return;
                            
                            // 記錄點擊位置
                            const startX = e.clientX;
                            const startY = e.clientY;
                            
                            // 監聽 mouseup，如果沒有拖曳則觸發摺疊
                            const handleMouseUp = (upEvent) => {
                                const deltaX = Math.abs(upEvent.clientX - startX);
                                const deltaY = Math.abs(upEvent.clientY - startY);
                                
                                // 如果移動距離小於 5px，視為點擊
                                if (deltaX < 5 && deltaY < 5) {
                                    note.classList.toggle('collapsed');
                                    updateConnectionsForNote(note);
                                    saveState();
                                }
                                
                                document.removeEventListener('mouseup', handleMouseUp);
                            };
                            
                            document.addEventListener('mouseup', handleMouseUp);
                        });
                        
                        // 雙擊標題編輯
                        noteTitleText.addEventListener('dblclick', (e) => {
                            e.stopPropagation();
                            noteTitleText.contentEditable = true;
                            noteTitleText.focus();
                            document.execCommand('selectAll', false, null);
                        });
                        
                        noteTitleText.addEventListener('blur', () => {
                            noteTitleText.contentEditable = false;
                            saveState();
                        });
                        
                        // 雙擊內容編輯
                        noteContent.addEventListener('dblclick', (e) => {
                            e.stopPropagation();
                            noteContent.contentEditable = true;
                            noteContent.focus();
                            document.execCommand('selectAll', false, null);
                        });
                        
                        noteContent.addEventListener('blur', () => {
                            noteContent.contentEditable = false;
                            saveState();
                        });
                    }
                }

                if (isGroup || isImage) {
                    const directions = ['tl', 't', 'tr', 'l', 'r', 'bl', 'b', 'br'];
                    directions.forEach(dir => {
                        const resizeHandle = document.createElement('div');
                        resizeHandle.className = `resize-handle resize-handle-${dir}`;
                        resizeHandle.dataset.direction = dir;
                        note.appendChild(resizeHandle);
                        resizeHandle.addEventListener('mousedown', (e) => onResizeMouseDown(e, note, dir));
                    });
                }

                note.addEventListener('mousedown', (e) => onNoteMouseDown(e, note));
                board.appendChild(note);
                
                if (!isGroup && !isImage) {
                    createConnectorNodes(note);
                }

                if (!isRestoring) {
                    clearSelection();
                    addNoteToSelection(note);
                    saveState();
                }
                return note;
            }
            
            function onResizeMouseDown(e, note, direction) {
                e.stopPropagation();
                
                let isResizing = true;
                const startMouseX = e.clientX;
                const startMouseY = e.clientY;
                
                const rect = note.getBoundingClientRect();
                const { x: centerX, y: centerY } = getBoardCoordinates(rect.left + rect.width/2, rect.top + rect.height/2);
                
                const startWidth = note.offsetWidth;
                const startHeight = note.offsetHeight;
                
                const rotation = parseFloat(note.dataset.rotation || 0);
                const angle = rotation * Math.PI / 180;
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);

                const minWidth = 20;
                const minHeight = 20;

                function onResizeMove(moveEvent) {
                    if (!isResizing) return;
                    
                    const dx = (moveEvent.clientX - startMouseX) / scale;
                    const dy = (moveEvent.clientY - startMouseY) / scale;

                    const localDx = dx * cos + dy * sin;
                    const localDy = -dx * sin + dy * cos;

                    let newW = startWidth;
                    let newH = startHeight;

                    if (direction.includes('r')) newW = startWidth + localDx;
                    if (direction.includes('l')) newW = startWidth - localDx;
                    if (direction.includes('b')) newH = startHeight + localDy;
                    if (direction.includes('t')) newH = startHeight - localDy;

                    if (note.dataset.isImage === 'true' && !moveEvent.shiftKey) {
                         const ratio = startWidth / startHeight;
                         if (direction === 'l' || direction === 'r') {
                             newH = newW / ratio;
                         } else if (direction === 't' || direction === 'b') {
                             newW = newH * ratio;
                         } else {
                             newH = newW / ratio;
                         }
                    }

                    if (newW < minWidth) newW = minWidth;
                    if (newH < minHeight) newH = minHeight;
                    
                    let dW = newW - startWidth;
                    let dH = newH - startHeight;
                    
                    let localCenterShiftX = 0;
                    let localCenterShiftY = 0;
                    
                    if (direction.includes('r')) localCenterShiftX += dW / 2;
                    if (direction.includes('l')) localCenterShiftX -= dW / 2;
                    if (direction.includes('b')) localCenterShiftY += dH / 2;
                    if (direction.includes('t')) localCenterShiftY -= dH / 2;
                    
                    const globalShiftX = localCenterShiftX * cos - localCenterShiftY * sin;
                    const globalShiftY = localCenterShiftX * sin + localCenterShiftY * cos;
                    
                    const newCenterX = centerX + globalShiftX;
                    const newCenterY = centerY + globalShiftY;
                    
                    note.style.width = `${newW}px`;
                    note.style.height = `${newH}px`;
                    note.style.left = `${newCenterX - newW / 2}px`;
                    note.style.top = `${newCenterY - newH / 2}px`;

                    updateConnectionsForNote(note);
                }

                function onResizeEnd(upEvent) {
                    isResizing = false;
                    document.removeEventListener('mousemove', onResizeMove);
                    document.removeEventListener('mouseup', onResizeEnd);
                    saveState();
                }
                
                document.addEventListener('mousemove', onResizeMove);
                document.addEventListener('mouseup', onResizeEnd);
            }

            function onRotateMouseDown(e, note) {
                e.stopPropagation();
                e.preventDefault();
                
                const rect = note.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                let startAngle = parseFloat(note.dataset.rotation || 0);
                const startMouseAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX) * 180 / Math.PI;
                
                function onRotateMove(moveEvent) {
                    const currentMouseAngle = Math.atan2(moveEvent.clientY - centerY, moveEvent.clientX - centerX) * 180 / Math.PI;
                    const deltaAngle = currentMouseAngle - startMouseAngle;
                    const newAngle = startAngle + deltaAngle;
                    
                    note.style.transform = `rotate(${newAngle}deg)`;
                    note.dataset.rotation = newAngle;
                }
                
                function onRotateEnd() {
                    document.removeEventListener('mousemove', onRotateMove);
                    document.removeEventListener('mouseup', onRotateEnd);
                    saveState();
                }
                
                document.addEventListener('mousemove', onRotateMove);
                document.addEventListener('mouseup', onRotateEnd);
            }

            // --- 拖曳邏輯 (含群組拖曳) ---
            function onNoteMouseDown(e, note) {
                const editable = note.querySelector('.editable');
                if (editable && editable.isContentEditable) return;
                if (e.target.closest('button')) return;
                if (e.target.closest('.connector-node')) return;
                if (e.target.closest('.resize-handle')) return; 
                if (e.target.closest('.rotate-handle')) return; // [NEW]
                if (isSpacePressed || e.button === 1) {
                    isPanning = true;
                    panStartX = e.clientX - panX;
                    panStartY = e.clientY - panY;
                    boardContainer.style.cursor = 'grabbing';
                    return;
                }
                
                e.stopPropagation();
                
                let dragStarted = false;
                isDraggingNote = true;
                note.style.zIndex = zIndexCounter++;
                
                const isCtrl = e.ctrlKey || e.metaKey;
                if (isCtrl) {
                    // 點擊時不切換，等到 mouseup 再切換
                } else if (!selectedNotes.includes(note)) {
                    clearSelection();
                    addNoteToSelection(note);
                }
                
                let elementsToDrag = [];
                if (selectedNotes.includes(note)) {
                    elementsToDrag = [...selectedNotes];
                } else {
                    elementsToDrag = [note];
                }

                childNotesToDrag.clear();
                const groups = elementsToDrag.filter(n => n.classList.contains('group-container'));
                
                if (groups.length > 0) {
                    const groupRects = groups.map(g => ({ group: g, rect: g.getBoundingClientRect() }));
                    const allNotes = board.querySelectorAll('.sticky-note:not(.group-container)');
                    
                    allNotes.forEach(child => {
                        if (elementsToDrag.includes(child)) return; 
                        
                        const childRect = child.getBoundingClientRect();
                        for (const { group, rect } of groupRects) {
                            const isOverlapping = !(childRect.right < rect.left || 
                                                  childRect.left > rect.right || 
                                                  childRect.bottom < rect.top || 
                                                  childRect.top > rect.bottom);
                                                  
                            if (isOverlapping) {
                                elementsToDrag.push(child);
                                childNotesToDrag.set(child, group); 
                                break; 
                            }
                        }
                    });
                }
                
                elementsToDrag.forEach(el => {
                    if (el !== note) el.style.zIndex = zIndexCounter - 1;
                });
                
                dragOffsets.clear();
                
                const { x: mouseWorldX, y: mouseWorldY } = getBoardCoordinates(e.clientX, e.clientY);
                
                elementsToDrag.forEach(n => {
                    const noteWorldX = parseFloat(n.style.left);
                    const noteWorldY = parseFloat(n.style.top);
                    
                    dragOffsets.set(n, {
                        offsetX: mouseWorldX - noteWorldX,
                        offsetY: mouseWorldY - noteWorldY
                    });
                });
                
                function onNoteDrag(moveEvent) {
                    if (!isDraggingNote) return;
                    if (!dragStarted) {
                        if (Math.abs(moveEvent.clientX - e.clientX) > 3 || Math.abs(moveEvent.clientY - e.clientY) > 3) {
                            dragStarted = true;
                            if (document.activeElement.isContentEditable) {
                                document.activeElement.blur();
                            }
                        } else {
                            return;
                        }
                    }

                    const { x: boardX, y: boardY } = getBoardCoordinates(moveEvent.clientX, moveEvent.clientY);
                    
                    const primaryOffset = dragOffsets.get(note); 
                    if (!primaryOffset) return; 
                    
                    let newX = boardX - primaryOffset.offsetX;
                    let newY = boardY - primaryOffset.offsetY;

                    hideSnapLines(); 
                    let snappedX = false;
                    let snappedY = false;
                    
                    const primaryRect = {
                        left: newX,
                        top: newY,
                        width: note.offsetWidth,
                        height: note.offsetHeight,
                        right: newX + note.offsetWidth,
                        bottom: newY + note.offsetHeight,
                        hCenter: newX + note.offsetWidth / 2,
                        vCenter: newY + note.offsetHeight / 2
                    };
                    
                    const allNotes = board.querySelectorAll('.sticky-note');
                    const threshold = SNAP_THRESHOLD / scale; 

                    for (const targetNote of allNotes) {
                        if (selectedNotes.includes(targetNote)) continue; 

                        const targetRect = {
                            left: parseFloat(targetNote.style.left),
                            top: parseFloat(targetNote.style.top),
                            width: targetNote.offsetWidth,
                            height: targetNote.offsetHeight,
                        };
                        targetRect.right = targetRect.left + targetRect.width;
                        targetRect.bottom = targetRect.top + targetRect.height;
                        targetRect.hCenter = targetRect.left + targetRect.width / 2;
                        targetRect.vCenter = targetRect.top + targetRect.height / 2;
                        
                        if (!snappedX) {
                            if (Math.abs(primaryRect.left - targetRect.left) < threshold) {
                                newX = targetRect.left;
                                showVLine(targetRect.left);
                                snappedX = true;
                            } else if (Math.abs(primaryRect.hCenter - targetRect.hCenter) < threshold) {
                                newX = targetRect.hCenter - primaryRect.width / 2;
                                showVLine(targetRect.hCenter);
                                snappedX = true;
                            } else if (Math.abs(primaryRect.right - targetRect.right) < threshold) {
                                newX = targetRect.right - primaryRect.width;
                                showVLine(targetRect.right);
                                snappedX = true;
                            } else if (Math.abs(primaryRect.left - targetRect.right) < threshold) { 
                                newX = targetRect.right;
                                showVLine(targetRect.right);
                                snappedX = true;
                            } else if (Math.abs(primaryRect.right - targetRect.left) < threshold) { 
                                newX = targetRect.left - primaryRect.width;
                                showVLine(targetRect.left);
                                snappedX = true;
                            }
                        }

                        if (!snappedY) {
                            if (Math.abs(primaryRect.top - targetRect.top) < threshold) {
                                newY = targetRect.top;
                                showHLine(targetRect.top);
                                snappedY = true;
                            } else if (Math.abs(primaryRect.vCenter - targetRect.vCenter) < threshold) {
                                newY = targetRect.vCenter - primaryRect.height / 2;
                                showHLine(targetRect.vCenter);
                                snappedY = true;
                            } else if (Math.abs(primaryRect.bottom - targetRect.bottom) < threshold) {
                                newY = targetRect.bottom - primaryRect.height;
                                showHLine(targetRect.bottom);
                                snappedY = true;
                            } else if (Math.abs(primaryRect.top - targetRect.bottom) < threshold) { 
                                newY = targetRect.bottom;
                                showHLine(targetRect.bottom);
                                snappedY = true;
                            } else if (Math.abs(primaryRect.bottom - targetRect.top) < threshold) { 
                                newY = targetRect.top - primaryRect.height;
                                showHLine(targetRect.top);
                                snappedY = true;
                            }
                        }
                        
                        if (snappedX && snappedY) break;
                    }
                    
                    const deltaX = newX - parseFloat(note.style.left);
                    const deltaY = newY - parseFloat(note.style.top);

                    dragOffsets.forEach((offset, element) => {
                        element.style.left = `${parseFloat(element.style.left) + deltaX}px`;
                        element.style.top = `${parseFloat(element.style.top) + deltaY}px`;
                        updateConnectionsForNote(element);
                    });
                    
                    updateToolbarPositions();
                }

                function onNoteDragEnd(upEvent) {
                    isDraggingNote = false;
                    document.removeEventListener('mousemove', onNoteDrag);
                    document.removeEventListener('mouseup', onNoteDragEnd);
                    
                    hideSnapLines(); 

                    if (!dragStarted) {
                        const isCtrlEnd = upEvent.ctrlKey || upEvent.metaKey;
                        if (isCtrlEnd) {
                            toggleNoteInSelection(note);
                        } else {
                            clearSelection();
                            addNoteToSelection(note);
                        }
                    } else {
                        saveState(); 
                    }
                    
                    dragOffsets.clear();
                    childNotesToDrag.clear();
                    updateToolbarStates();
                }

                document.addEventListener('mousemove', onNoteDrag);
                document.addEventListener('mouseup', onNoteDragEnd, { once: true });
            }
            
            // --- [NEW] 複製/貼上 邏輯 (Req 1) ---
            function getNoteState(note) {
                const editable = note.querySelector('.editable');
                return {
                    id: note.id, 
                    x: parseFloat(note.style.left),
                    y: parseFloat(note.style.top),
                    isTitle: note.classList.contains('note-title'),
                    color: note.dataset.color,
                    content: editable ? editable.innerHTML : '',
                    isGroup: note.classList.contains('group-container'),
                    width: note.style.width || null,
                    height: note.style.height || null,
                    isTextNode: note.dataset.isTextNode === 'true',
                    isImage: note.dataset.isImage === 'true', // [NEW]
                    imgSrc: note.dataset.imgSrc || '', // [NEW]
                    rotation: parseFloat(note.dataset.rotation || 0) // [NEW]
                };
            }

            function copySelectedNotes() {
                if (selectedNotes.length > 0) {
                    clipboard = selectedNotes.map(getNoteState);
                }
            }
            
            function pasteNotes() {
                if (clipboard.length > 0) {
                    clearSelection();
                    const newNotes = [];
                    const newClipboard = [];
                    
                    clipboard.forEach(noteData => {
                        const newData = { ...noteData }; 
                        newData.id = `note_${crypto.randomUUID()}`; 
                        newData.x += 20 / scale; 
                        newData.y += 20 / scale;
                        
                        const newNote = createNote(newData, true); 
                        addNoteToSelection(newNote);
                        newClipboard.push(getNoteState(newNote)); 
                    });
                    
                    clipboard = newClipboard; 
                    updateToolbarStates();
                    saveState(); 
                }
            }
            
            // --- 多選管理 ---
            function addNoteToSelection(note) {
                if (!selectedNotes.includes(note)) {
                    selectedNotes.push(note);
                    note.classList.add('selected');
                }
            }
            
            function removeNoteFromSelection(note) {
                selectedNotes = selectedNotes.filter(n => n !== note);
                note.classList.remove('selected', 'single-select');
            }
            
            function toggleNoteInSelection(note) {
                if (selectedNotes.includes(note)) {
                    removeNoteFromSelection(note);
                } else {
                    addNoteToSelection(note);
                }
            }

            function clearSelection() {
                selectedNotes.forEach(note => {
                    note.classList.remove('selected', 'single-select');
                });
                selectedNotes = [];
                clearConnectionSelection(); // [FIX] 同時清除關連線選取
                updateToolbarStates();
            }

            // --- 工具列管理 ---
            function updateToolbarStates() {
                // [FIX] 根據選取類型顯示/隱藏工具列按鈕
                const titleBtn = contextMenu.querySelector('[data-action="title"]');
                const deleteLinesBtn = contextMenu.querySelector('[data-action="delete-lines"]');
                const deleteBtn = contextMenu.querySelector('#note-delete-btn');
                
                if (window.selectedLabel) {
                    // 選取標籤時，隱藏「標題」、「移除關連線」和「刪除」按鈕
                    if (titleBtn) titleBtn.style.display = 'none';
                    if (deleteLinesBtn) deleteLinesBtn.style.display = 'none';
                    if (deleteBtn) deleteBtn.style.display = 'none';
                } else {
                    // 選取便利貼時，顯示所有按鈕
                    if (titleBtn) titleBtn.style.display = '';
                    if (deleteLinesBtn) deleteLinesBtn.style.display = '';
                    if (deleteBtn) deleteBtn.style.display = '';
                }
                
                if (selectedNotes.length === 1) {
                    const note = selectedNotes[0];
                    note.classList.add('single-select');
                    showContextMenu(note);
                    contextMenu.classList.add('visible');
                } else {
                    contextMenu.classList.remove('visible');
                    board.querySelectorAll('.single-select').forEach(n => n.classList.remove('single-select'));
                }
                
                if (selectedNotes.length > 1) {
                    showAlignToolbar();
                    alignToolbar.classList.add('visible');
                    distHBtn.disabled = selectedNotes.length < 3;
                    distVBtn.disabled = selectedNotes.length < 3;
                } else {
                    alignToolbar.classList.remove('visible');
                }
            }
            
            function updateToolbarPositions() {
                if (contextMenu.classList.contains('visible') && selectedNotes.length === 1) {
                    showContextMenu(selectedNotes[0]);
                }
                if (alignToolbar.classList.contains('visible') && selectedNotes.length > 1) {
                    showAlignToolbar();
                }
            }

            function showContextMenu(note) {
                if (!note) return;
                const rect = note.getBoundingClientRect();
                const menuRect = contextMenu.getBoundingClientRect();
                let top = rect.top - menuRect.height - 8;
                let left = rect.left + (rect.width / 2) - (menuRect.width / 2);
                if (top < 8) top = rect.bottom + 8;
                if (left < 8) left = 8;
                if (left + menuRect.width > window.innerWidth - 8) {
                    left = window.innerWidth - menuRect.width - 8;
                }
                contextMenu.style.top = `${top}px`;
                contextMenu.style.left = `${left}px`;
            }
            
            function showAlignToolbar() {
                if (selectedNotes.length < 2) return;
                let minTop = Infinity, minLeft = Infinity, maxBottom = -Infinity, maxRight = -Infinity;
                selectedNotes.forEach(note => {
                    const rect = note.getBoundingClientRect();
                    minTop = Math.min(minTop, rect.top);
                    minLeft = Math.min(minLeft, rect.left);
                    maxBottom = Math.max(maxBottom, rect.bottom);
                    maxRight = Math.max(maxRight, rect.right);
                });
                const menuRect = alignToolbar.getBoundingClientRect();
                let top = minTop - menuRect.height - 8;
                let left = minLeft + ((maxRight - minLeft) / 2) - (menuRect.width / 2);
                if (top < 8) top = maxBottom + 8;
                if (left < 8) left = 8;
                if (left + menuRect.width > window.innerWidth - 8) {
                    left = window.innerWidth - menuRect.width - 8;
                }
                alignToolbar.style.top = `${top}px`;
                alignToolbar.style.left = `${left}px`;
            }

            contextMenu.addEventListener('click', (e) => {
                if (selectedNotes.length !== 1 && !window.selectedLabel) return;
                
                const button = e.target.closest('button');
                if (!button) return;
                const colorClass = button.dataset.color; 
                const action = button.dataset.action;
                let stateChanged = false;

                if (window.selectedLabel && window.selectedLabelConnId) {
                    const conn = connections.find(c => c.id === window.selectedLabelConnId);
                    if (conn) {
                        if (colorClass) {
                            const colorMap = {
                                'bg-yellow-200': '#fde047',
                                'bg-green-200': '#86efac',
                                'bg-blue-200': '#93c5fd',
                                'bg-pink-200': '#f9a8d4',
                                'bg-purple-200': '#d8b4fe',
                                'bg-gray-200': '#e5e7eb'
                            };
                            
                            conn.labelColor = colorMap[colorClass] || '#ffffff';
                            drawConnectionLabel(conn); 
                            stateChanged = true;
                        }
                        // [REMOVED] 文字方塊的刪除功能已移除，現在由 blur 事件自動處理
                    }
                } else if (selectedNotes.length === 1) {
                    const note = selectedNotes[0];
                    if (colorClass) {
                        note.classList.remove(note.dataset.color);
                        note.classList.add(colorClass);
                        note.dataset.color = colorClass;
                        stateChanged = true;
                    }
                    if (action === 'title') {
                        note.classList.toggle('note-title');
                        stateChanged = true;
                    }
                    if (action === 'delete-lines') {
                        removeConnectionsForNote(note);
                        stateChanged = true;
                    }
                    if (action === 'delete') {
                        removeConnectionsForNote(note);
                        note.remove();
                        removeNoteFromSelection(note);
                        stateChanged = true;
                    }
                }

                if (stateChanged) {
                    saveState();
                }
                if (action === 'delete') {
                } else {
                    if (window.selectedLabel) {
                    } else {
                        updateToolbarStates();
                        if (action === 'title') {
                             updateToolbarPositions();
                        }
                    }
                }
            });
            
            // --- 對齊功能 ---
            function alignLeft() {
                if (selectedNotes.length < 2) return;
                const minLeft = Math.min(...selectedNotes.map(n => parseFloat(n.style.left)));
                selectedNotes.forEach(n => {
                    n.style.left = `${minLeft}px`;
                    updateConnectionsForNote(n);
                });
                saveState();
                updateToolbarPositions();
            }
            function alignCenterH() {
                if (selectedNotes.length < 2) return;
                const minLeft = Math.min(...selectedNotes.map(n => parseFloat(n.style.left)));
                const maxRight = Math.max(...selectedNotes.map(n => parseFloat(n.style.left) + n.offsetWidth));
                const center = minLeft + (maxRight - minLeft) / 2;
                selectedNotes.forEach(n => {
                    n.style.left = `${center - n.offsetWidth / 2}px`;
                    updateConnectionsForNote(n);
                });
                saveState();
                updateToolbarPositions();
            }
            function alignRight() {
                if (selectedNotes.length < 2) return;
                const maxRight = Math.max(...selectedNotes.map(n => parseFloat(n.style.left) + n.offsetWidth));
                selectedNotes.forEach(n => {
                    n.style.left = `${maxRight - n.offsetWidth}px`;
                    updateConnectionsForNote(n);
                });
                saveState();
                updateToolbarPositions();
            }
            function alignTop() {
                if (selectedNotes.length < 2) return;
                const minTop = Math.min(...selectedNotes.map(n => parseFloat(n.style.top)));
                selectedNotes.forEach(n => {
                    n.style.top = `${minTop}px`;
                    updateConnectionsForNote(n);
                });
                saveState();
                updateToolbarPositions();
            }
            function alignMiddleV() {
                if (selectedNotes.length < 2) return;
                const minTop = Math.min(...selectedNotes.map(n => parseFloat(n.style.top)));
                const maxBottom = Math.max(...selectedNotes.map(n => parseFloat(n.style.top) + n.offsetHeight));
                const middle = minTop + (maxBottom - minTop) / 2;
                selectedNotes.forEach(n => {
                    n.style.top = `${middle - n.offsetHeight / 2}px`;
                    updateConnectionsForNote(n);
                });
                saveState();
                updateToolbarPositions();
            }
            function alignBottom() {
                if (selectedNotes.length < 2) return;
                const maxBottom = Math.max(...selectedNotes.map(n => parseFloat(n.style.top) + n.offsetHeight));
                selectedNotes.forEach(n => {
                    n.style.top = `${maxBottom - n.offsetHeight}px`;
                    updateConnectionsForNote(n);
                });
                saveState();
                updateToolbarPositions();
            }
            function distH() {
                if (selectedNotes.length < 3) return;
                const sorted = [...selectedNotes].sort((a, b) => parseFloat(a.style.left) - parseFloat(b.style.left));
                const minLeft = parseFloat(sorted[0].style.left);
                const maxRight = parseFloat(sorted[sorted.length - 1].style.left) + sorted[sorted.length - 1].offsetWidth;
                const totalWidth = sorted.reduce((sum, n) => sum + n.offsetWidth, 0);
                const totalSpacing = (maxRight - minLeft) - totalWidth;
                const gap = totalSpacing / (sorted.length - 1);
                let currentLeft = minLeft;
                sorted[0].style.left = `${currentLeft}px`; 
                updateConnectionsForNote(sorted[0]);
                for (let i = 1; i < sorted.length - 1; i++) {
                    currentLeft += sorted[i-1].offsetWidth + gap;
                    sorted[i].style.left = `${currentLeft}px`;
                    updateConnectionsForNote(sorted[i]);
                }
                updateConnectionsForNote(sorted[sorted.length - 1]);
                saveState();
                updateToolbarPositions();
            }
            function distV() {
                if (selectedNotes.length < 3) return;
                const sorted = [...selectedNotes].sort((a, b) => parseFloat(a.style.top) - parseFloat(b.style.top));
                const minTop = parseFloat(sorted[0].style.top);
                const maxBottom = parseFloat(sorted[sorted.length - 1].style.top) + sorted[sorted.length - 1].offsetHeight;
                const totalHeight = sorted.reduce((sum, n) => sum + n.offsetHeight, 0);
                const totalSpacing = (maxBottom - minTop) - totalHeight;
                const gap = totalSpacing / (sorted.length - 1);
                let currentTop = minTop;
                sorted[0].style.top = `${currentTop}px`; 
                updateConnectionsForNote(sorted[0]);
                for (let i = 1; i < sorted.length - 1; i++) {
                    currentTop += sorted[i-1].offsetHeight + gap;
                    sorted[i].style.top = `${currentTop}px`;
                    updateConnectionsForNote(sorted[i]);
                }
                updateConnectionsForNote(sorted[sorted.length - 1]);
                saveState();
                updateToolbarPositions();
            }
            
            document.getElementById('align-left').addEventListener('click', alignLeft);
            document.getElementById('align-center-h').addEventListener('click', alignCenterH);
            document.getElementById('align-right').addEventListener('click', alignRight);
            document.getElementById('align-top').addEventListener('click', alignTop);
            document.getElementById('align-middle-v').addEventListener('click', alignMiddleV);
            document.getElementById('align-bottom').addEventListener('click', alignBottom);
            distHBtn.addEventListener('click', distH);
            distVBtn.addEventListener('click', distV);

            // [NEW] 綁定多選刪除功能 (Req 4)
            deleteSelectedBtn.addEventListener('click', deleteSelectedNotes); // (Req 4)

            // [NEW] 多選刪除功能 (Req 4)
            function deleteSelectedNotes() { // (Req 4)
                if (selectedNotes.length === 0) return;

                selectedNotes.forEach(note => {
                    removeConnectionsForNote(note);
                    note.remove();
                });
                
                clearSelection();
                saveState();
            }

            // --- 關聯線功能 ---
            function createConnectorNodes(note) {
                ['top', 'right', 'bottom', 'left'].forEach(side => {
                    const node = document.createElement('div');
                    node.className = `connector-node node-${side}`;
                    node.dataset.side = side;
                    node.addEventListener('mousedown', (e) => {
                        e.stopPropagation();
                        isDrawingLine = true;
                        startNodeInfo = { note, side };
                        tempLine = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        tempLine.setAttribute('id', 'temp-line');
                        const startPos = getNodePosition(note, side);
                        tempLine.setAttribute('d', `M${startPos.x} ${startPos.y} C ${startPos.x} ${startPos.y}, ${startPos.x} ${startPos.y}, ${startPos.x} ${startPos.y}`);
                        boardSvg.appendChild(tempLine);
                        document.addEventListener('mousemove', onDrawingLine);
                        document.addEventListener('mouseup', onEndDrawingLine, { once: true });
                    });
                    note.appendChild(node);
                });
            }
            function getNearestNode(note, point) {
                const noteX = parseFloat(note.style.left);
                const noteY = parseFloat(note.style.top);
                const noteWidth = note.offsetWidth;
                const noteHeight = note.offsetHeight;
                const centerX = noteX + noteWidth / 2;
                const centerY = noteY + noteHeight / 2;
                
                // 計算目標點相對於便條紙中心的方向
                const dx = point.x - centerX;
                const dy = point.y - centerY;
                
                // 根據角度決定最佳連接方向
                const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                let nearestSide;
                
                if (angle >= -45 && angle < 45) {
                    nearestSide = 'right';
                } else if (angle >= 45 && angle < 135) {
                    nearestSide = 'bottom';
                } else if (angle >= -135 && angle < -45) {
                    nearestSide = 'top';
                } else {
                    nearestSide = 'left';
                }
                
                const nodePoint = getNodePosition(note, nearestSide);
                const distance = Math.sqrt(Math.pow(point.x - nodePoint.x, 2) + Math.pow(point.y - nodePoint.y, 2));
                
                return { side: nearestSide, distance: distance };
            }
            function onDrawingLine(e) {
                if (!isDrawingLine || !tempLine) return;
                const startPos = getNodePosition(startNodeInfo.note, startNodeInfo.side);
                const { x, y } = getBoardCoordinates(e.clientX, e.clientY);
                let endPos = { x, y };
                let targetNote = null;
                const allNotes = board.querySelectorAll('.sticky-note');
                for (const note of allNotes) {
                    if (note === startNodeInfo.note) continue;
                    const noteX = parseFloat(note.style.left);
                    const noteY = parseFloat(note.style.top);
                    const noteWidth = note.offsetWidth;
                    const noteHeight = note.offsetHeight;
                    if (x > noteX && x < (noteX + noteWidth) && y > noteY && y < (noteY + noteHeight)) {
                        targetNote = note;
                        break;
                    }
                }
                if (currentTargetNote && currentTargetNote !== targetNote) {
                    currentTargetNote.classList.remove('connection-target');
                    tempSnapTarget = null;
                }
                if (targetNote) {
                    currentTargetNote = targetNote;
                    currentTargetNote.classList.add('connection-target');
                    const nearest = getNearestNode(targetNote, endPos);
                    endPos = getNodePosition(targetNote, nearest.side);
                    tempSnapTarget = { note: targetNote, side: nearest.side };
                } else {
                    currentTargetNote = null;
                    tempSnapTarget = null;
                }
                const offset = 50;
                let c1 = { ...startPos };
                let c2 = { ...endPos };
                if (startNodeInfo.side === 'top') c1.y -= offset;
                if (startNodeInfo.side === 'bottom') c1.y += offset;
                if (startNodeInfo.side === 'left') c1.x -= offset;
                if (startNodeInfo.side === 'right') c1.x += offset;
                if (tempSnapTarget) {
                    if (tempSnapTarget.side === 'top') c2.y -= offset;
                    if (tempSnapTarget.side === 'bottom') c2.y += offset;
                    if (tempSnapTarget.side === 'left') c2.x -= offset;
                    if (tempSnapTarget.side === 'right') c2.x += offset;
                }
                tempLine.setAttribute('d', `M${startPos.x} ${startPos.y} C ${c1.x} ${c1.y}, ${c2.x} ${c2.y}, ${endPos.x} ${endPos.y}`);
            }
            function onEndDrawingLine(e) {
                document.removeEventListener('mousemove', onDrawingLine);
                if (!isDrawingLine) return;
                isDrawingLine = false;
                if (tempSnapTarget) {
                    const newConnection = {
                        id: `conn_${crypto.randomUUID()}`,
                        fromId: startNodeInfo.note.id,
                        fromSide: startNodeInfo.side,
                        toId: tempSnapTarget.note.id,
                        toSide: tempSnapTarget.side
                    };
                    const exists = connections.some(c =>
                        (c.fromId === newConnection.fromId && c.toId === newConnection.toId && c.fromSide === newConnection.fromSide && c.toSide === newConnection.toSide) ||
                        (c.fromId === newConnection.toId && c.toId === newConnection.fromId && c.fromSide === newConnection.toSide && c.toSide === newConnection.fromSide)
                    );
                    if (!exists) {
                        connections.push(newConnection);
                        drawConnections();
                        saveState();
                    }
                }
                if (tempLine) tempLine.remove();
                if (currentTargetNote) {
                    currentTargetNote.classList.remove('connection-target');
                }
                tempLine = null;
                startNodeInfo = null;
                currentTargetNote = null;
                tempSnapTarget = null;
            }
            function getNodePosition(note, side) {
                const noteX = parseFloat(note.style.left);
                const noteY = parseFloat(note.style.top);
                const noteWidth = note.offsetWidth;
                const noteHeight = note.offsetHeight;
                switch (side) {
                    case 'top': return { x: noteX + noteWidth / 2, y: noteY };
                    case 'right': return { x: noteX + noteWidth, y: noteY + noteHeight / 2 };
                    case 'bottom': return { x: noteX + noteWidth / 2, y: noteY + noteHeight };
                    case 'left': return { x: noteX, y: noteY + noteHeight / 2 };
                    default: return { x: noteX, y: noteY };
                }
            }
            function drawConnections() {
                while (boardSvg.children.length > 1) {
                    if (boardSvg.lastChild.tagName === 'path') {
                        boardSvg.removeChild(boardSvg.lastChild);
                    } else {
                        break;
                    }
                }
                
                connections.forEach(conn => {
                    const fromEl = document.getElementById(conn.fromId);
                    const toEl = document.getElementById(conn.toId);
                    if (!fromEl || !toEl) return;
                    
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    path.setAttribute('class', 'connection-line');
                    path.dataset.connId = conn.id;
                    
                    // [NEW] 添加點擊選取關連線的事件
                    path.addEventListener('click', (e) => {
                        e.stopPropagation();
                        selectConnection(conn.id);
                    });
                    
                    path.addEventListener('dblclick', (e) => {
                        e.stopPropagation();
                        if (!conn.label) {
                            conn.label = '文字';
                            conn.labelColor = '#ffffff'; 
                            conn.labelBgColor = '#000000'; 
                            saveState();
                        }
                        drawConnectionLabel(conn);
                        const labelEl = document.getElementById(`label_${conn.id}`);
                        if (labelEl) {
                            labelEl.focus();
                            document.execCommand('selectAll', false, null);
                        }
                    });

                    const startPos = getNodePosition(fromEl, conn.fromSide);
                    const endPos = getNodePosition(toEl, conn.toSide);
                    
                    let pathData = '';
                    
                    if (currentConnectionStyle === 'round') {
                        // 折線（圓角） - 根據方向決定折線方式
                        const radius = 20;
                        
                        // 判斷主要是水平還是垂直連接
                        const isHorizontal = (conn.fromSide === 'left' || conn.fromSide === 'right') && 
                                            (conn.toSide === 'left' || conn.toSide === 'right');
                        const isVertical = (conn.fromSide === 'top' || conn.fromSide === 'bottom') && 
                                          (conn.toSide === 'top' || conn.toSide === 'bottom');
                        
                        if (isVertical) {
                            // 垂直折線
                            const midY = conn.controlY !== undefined ? conn.controlY : (startPos.y + endPos.y) / 2;
                            const dx = endPos.x - startPos.x;
                            pathData = `M${startPos.x} ${startPos.y} L${startPos.x} ${midY - radius} Q${startPos.x} ${midY} ${startPos.x + (dx > 0 ? radius : -radius)} ${midY} L${endPos.x - (dx > 0 ? radius : -radius)} ${midY} Q${endPos.x} ${midY} ${endPos.x} ${midY + radius} L${endPos.x} ${endPos.y}`;
                        } else {
                            // 水平折線
                            const midX = conn.controlX !== undefined ? conn.controlX : (startPos.x + endPos.x) / 2;
                            const dy = endPos.y - startPos.y;
                            pathData = `M${startPos.x} ${startPos.y} L${midX - radius} ${startPos.y} Q${midX} ${startPos.y} ${midX} ${startPos.y + (dy > 0 ? radius : -radius)} L${midX} ${endPos.y - (dy > 0 ? radius : -radius)} Q${midX} ${endPos.y} ${midX + radius} ${endPos.y} L${endPos.x} ${endPos.y}`;
                        }
                    } else {
                        // 三次貝茲曲線 - 根據連接方向計算控制點
                        const dx = Math.abs(endPos.x - startPos.x);
                        const dy = Math.abs(endPos.y - startPos.y);
                        const offsetX = Math.max(dx * 0.5, 50);
                        const offsetY = Math.max(dy * 0.5, 50);
                        
                        let c1x, c1y, c2x, c2y;
                        
                        if (conn.control1X !== undefined && conn.control1Y !== undefined) {
                            c1x = conn.control1X;
                            c1y = conn.control1Y;
                        } else {
                            // 根據起始方向設置第一個控制點
                            if (conn.fromSide === 'right') {
                                c1x = startPos.x + offsetX;
                                c1y = startPos.y;
                            } else if (conn.fromSide === 'left') {
                                c1x = startPos.x - offsetX;
                                c1y = startPos.y;
                            } else if (conn.fromSide === 'bottom') {
                                c1x = startPos.x;
                                c1y = startPos.y + offsetY;
                            } else { // top
                                c1x = startPos.x;
                                c1y = startPos.y - offsetY;
                            }
                        }
                        
                        if (conn.control2X !== undefined && conn.control2Y !== undefined) {
                            c2x = conn.control2X;
                            c2y = conn.control2Y;
                        } else {
                            // 根據結束方向設置第二個控制點
                            if (conn.toSide === 'right') {
                                c2x = endPos.x + offsetX;
                                c2y = endPos.y;
                            } else if (conn.toSide === 'left') {
                                c2x = endPos.x - offsetX;
                                c2y = endPos.y;
                            } else if (conn.toSide === 'bottom') {
                                c2x = endPos.x;
                                c2y = endPos.y + offsetY;
                            } else { // top
                                c2x = endPos.x;
                                c2y = endPos.y - offsetY;
                            }
                        }
                        
                        pathData = `M${startPos.x} ${startPos.y} C ${c1x} ${c1y}, ${c2x} ${c2y}, ${endPos.x} ${endPos.y}`;
                    }
                    
                    path.setAttribute('d', pathData);
                    boardSvg.appendChild(path);
                    
                    if (conn.label) {
                        drawConnectionLabel(conn, startPos, c1, c2, endPos);
                    }
                });
            }

            function drawConnectionLabel(conn, startPos, c1, c2, endPos) {
                let labelEl = document.getElementById(`label_${conn.id}`);
                if (!labelEl) {
                    labelEl = document.createElement('div');
                    labelEl.id = `label_${conn.id}`;
                    labelEl.className = 'connection-label';
                    labelEl.contentEditable = true;
                    labelEl.spellcheck = false;
                    board.appendChild(labelEl);
                    
                    labelEl.addEventListener('mousedown', (e) => {
                        e.stopPropagation(); 
                        clearSelection(); // 這會同時清除便利貼和關連線選取
                        labelEl.classList.add('selected');
                        const rect = labelEl.getBoundingClientRect();
                        contextMenu.style.top = `${rect.top - 50}px`;
                        contextMenu.style.left = `${rect.left}px`;
                        
                        window.selectedLabel = labelEl;
                        window.selectedLabelConnId = conn.id;
                        updateToolbarStates(); // [FIX] 更新工具列狀態以隱藏無用按鈕
                        contextMenu.classList.add('visible');
                    });
                    
                    labelEl.addEventListener('blur', () => {
                        // [FIX] 如果標籤正在被刪除，不要保存資料
                        if (labelEl.dataset.isDeleting === 'true') {
                            return;
                        }
                        
                        // [NEW] 如果文字方塊沒有字，自動刪除標籤
                        const text = labelEl.innerText.trim();
                        if (text === '') {
                            conn.label = '';
                            conn.labelColor = null;
                            labelEl.remove();
                        } else {
                            conn.label = labelEl.innerText;
                        }
                        
                        labelEl.classList.remove('selected');
                        window.selectedLabel = null;
                        window.selectedLabelConnId = null;
                        contextMenu.classList.remove('visible'); // [FIX] 隱藏工具列
                        saveState();
                    });
                    
                    labelEl.addEventListener('dblclick', (e) => {
                        e.stopPropagation();
                        document.execCommand('selectAll', false, null);
                    });
                }
                
                labelEl.innerText = conn.label;
                labelEl.style.color = conn.labelColor || '#ffffff';
                
                if (!startPos) {
                    const fromEl = document.getElementById(conn.fromId);
                    const toEl = document.getElementById(conn.toId);
                    if (fromEl && toEl) {
                        startPos = getNodePosition(fromEl, conn.fromSide);
                        endPos = getNodePosition(toEl, conn.toSide);
                        const offset = 50;
                        c1 = { ...startPos };
                        c2 = { ...endPos };
                        if (conn.fromSide === 'top') c1.y -= offset;
                        if (conn.fromSide === 'bottom') c1.y += offset;
                        if (conn.fromSide === 'left') c1.x -= offset;
                        if (conn.fromSide === 'right') c1.x += offset;
                        if (conn.toSide === 'top') c2.y -= offset;
                        if (conn.toSide === 'bottom') c2.y += offset;
                        if (conn.toSide === 'left') c2.x -= offset;
                        if (conn.toSide === 'right') c2.x += offset;
                    }
                }
                
                if (startPos && endPos) {
                    const midX = 0.125 * startPos.x + 0.375 * c1.x + 0.375 * c2.x + 0.125 * endPos.x;
                    const midY = 0.125 * startPos.y + 0.375 * c1.y + 0.375 * c2.y + 0.125 * endPos.y;
                    
                    labelEl.style.left = `${midX}px`;
                    labelEl.style.top = `${midY}px`; 
                }
            }

            function updateConnectionsForNote(note) {
                connections.forEach(conn => {
                    if (conn.fromId === note.id || conn.toId === note.id) {
                        const path = boardSvg.querySelector(`[data-conn-id="${conn.id}"]`);
                        if (!path) return;
                        const fromEl = document.getElementById(conn.fromId);
                        const toEl = document.getElementById(conn.toId);
                        if (!fromEl || !toEl) return;
                        const startPos = getNodePosition(fromEl, conn.fromSide);
                        const endPos = getNodePosition(toEl, conn.toSide);
                        
                        let pathData = '';
                        
                        if (currentConnectionStyle === 'round') {
                            // 折線（圓角） - 使用自訂控制點或預設中點
                            const midX = conn.controlX !== undefined ? conn.controlX : (startPos.x + endPos.x) / 2;
                            const radius = 20;
                            const dy = endPos.y - startPos.y;
                            pathData = `M${startPos.x} ${startPos.y} L${midX - radius} ${startPos.y} Q${midX} ${startPos.y} ${midX} ${startPos.y + (dy > 0 ? radius : -radius)} L${midX} ${endPos.y - (dy > 0 ? radius : -radius)} Q${midX} ${endPos.y} ${midX + radius} ${endPos.y} L${endPos.x} ${endPos.y}`;
                        } else {
                            // 三次貝茲曲線 - 使用自訂控制點或預設值
                            const offset = Math.abs(endPos.x - startPos.x) * 0.5;
                            let c1x = conn.control1X !== undefined ? conn.control1X : startPos.x + (conn.fromSide === 'right' ? offset : conn.fromSide === 'left' ? -offset : 0);
                            let c1y = conn.control1Y !== undefined ? conn.control1Y : startPos.y + (conn.fromSide === 'bottom' ? offset : conn.fromSide === 'top' ? -offset : 0);
                            let c2x = conn.control2X !== undefined ? conn.control2X : endPos.x + (conn.toSide === 'right' ? offset : conn.toSide === 'left' ? -offset : 0);
                            let c2y = conn.control2Y !== undefined ? conn.control2Y : endPos.y + (conn.toSide === 'bottom' ? offset : conn.toSide === 'top' ? -offset : 0);
                            pathData = `M${startPos.x} ${startPos.y} C ${c1x} ${c1y}, ${c2x} ${c2y}, ${endPos.x} ${endPos.y}`;
                        }
                        
                        path.setAttribute('d', pathData);
                        
                        if (conn.label) {
                            drawConnectionLabel(conn, startPos, null, null, endPos);
                        }
                    }
                });
            }
            function removeConnectionsForNote(note) {
                const connectionsToRemove = connections.filter(conn => conn.fromId === note.id || conn.toId === note.id);
                connectionsToRemove.forEach(conn => {
                    const path = boardSvg.querySelector(`[data-conn-id="${conn.id}"]`);
                    if (path) path.remove();
                    const labelEl = document.getElementById(`label_${conn.id}`);
                    if (labelEl) labelEl.remove();
                });
                connections = connections.filter(conn => conn.fromId !== note.id && conn.toId !== note.id);
            }
            
            // [NEW] 選取關連線
            function selectConnection(connId) {
                // 清除之前選取的關連線
                if (selectedConnection) {
                    const oldPath = boardSvg.querySelector(`[data-conn-id="${selectedConnection}"]`);
                    if (oldPath) oldPath.classList.remove('selected');
                    hideConnectionControlPoints();
                }
                
                // 清除選取的便利貼
                clearSelection();
                
                // 選取新的關連線
                selectedConnection = connId;
                const path = boardSvg.querySelector(`[data-conn-id="${connId}"]`);
                if (path) {
                    path.classList.add('selected');
                    showConnectionControlPoints(connId);
                }
            }
            
            // [NEW] 清除關連線選取
            function clearConnectionSelection() {
                if (selectedConnection) {
                    const path = boardSvg.querySelector(`[data-conn-id="${selectedConnection}"]`);
                    if (path) path.classList.remove('selected');
                    hideConnectionControlPoints();
                    selectedConnection = null;
                }
            }
            
            // [NEW] 顯示線條控制點
            function showConnectionControlPoints(connId) {
                const conn = connections.find(c => c.id === connId);
                if (!conn) return;
                
                const fromEl = document.getElementById(conn.fromId);
                const toEl = document.getElementById(conn.toId);
                if (!fromEl || !toEl) return;
                
                const startPos = getNodePosition(fromEl, conn.fromSide);
                const endPos = getNodePosition(toEl, conn.toSide);
                
                // 如果是折線樣式，顯示中點控制點
                if (currentConnectionStyle === 'round') {
                    const midX = conn.controlX !== undefined ? conn.controlX : (startPos.x + endPos.x) / 2;
                    // Y軸固定在起點和終點的中間
                    const midY = (startPos.y + endPos.y) / 2;
                    
                    // 創建控制點
                    const controlPoint = document.createElement('div');
                    controlPoint.className = 'connection-control-point';
                    controlPoint.id = `control-${connId}`;
                    controlPoint.style.left = midX + 'px';
                    controlPoint.style.top = midY + 'px';
                    
                    // 控制點拖動（只能左右移動）
                    controlPoint.addEventListener('mousedown', (e) => {
                        e.stopPropagation();
                        let isDraggingControl = true;
                        
                        function onControlDrag(moveEvent) {
                            if (!isDraggingControl) return;
                            const { x } = getBoardCoordinates(moveEvent.clientX, moveEvent.clientY);
                            
                            // 只更新X座標，Y座標保持在中線上
                            controlPoint.style.left = x + 'px';
                            controlPoint.style.top = midY + 'px';
                            
                            conn.controlX = x;
                            // 不儲存controlY，讓它始終保持在中間
                            delete conn.controlY;
                            
                            drawConnections();
                        }
                        
                        function onControlDragEnd() {
                            isDraggingControl = false;
                            document.removeEventListener('mousemove', onControlDrag);
                            document.removeEventListener('mouseup', onControlDragEnd);
                            saveState();
                        }
                        
                        document.addEventListener('mousemove', onControlDrag);
                        document.addEventListener('mouseup', onControlDragEnd);
                    });
                    
                    board.appendChild(controlPoint);
                } else if (currentConnectionStyle === 'cubic') {
                    // 三次貝茲：顯示兩個控制點
                    const offset = Math.abs(endPos.x - startPos.x) * 0.5;
                    let c1x = conn.control1X !== undefined ? conn.control1X : startPos.x + (conn.fromSide === 'right' ? offset : conn.fromSide === 'left' ? -offset : 0);
                    let c1y = conn.control1Y !== undefined ? conn.control1Y : startPos.y + (conn.fromSide === 'bottom' ? offset : conn.fromSide === 'top' ? -offset : 0);
                    let c2x = conn.control2X !== undefined ? conn.control2X : endPos.x + (conn.toSide === 'right' ? offset : conn.toSide === 'left' ? -offset : 0);
                    let c2y = conn.control2Y !== undefined ? conn.control2Y : endPos.y + (conn.toSide === 'bottom' ? offset : conn.toSide === 'top' ? -offset : 0);
                    
                    // 創建第一個控制點
                    const cp1 = document.createElement('div');
                    cp1.className = 'connection-control-point';
                    cp1.id = `control1-${connId}`;
                    cp1.style.left = c1x + 'px';
                    cp1.style.top = c1y + 'px';
                    cp1.style.borderColor = '#3b82f6';
                    
                    cp1.addEventListener('mousedown', (e) => createControlPointDragHandler(e, conn, 'control1', cp1));
                    board.appendChild(cp1);
                    
                    // 創建第二個控制點
                    const cp2 = document.createElement('div');
                    cp2.className = 'connection-control-point';
                    cp2.id = `control2-${connId}`;
                    cp2.style.left = c2x + 'px';
                    cp2.style.top = c2y + 'px';
                    cp2.style.borderColor = '#10b981';
                    
                    cp2.addEventListener('mousedown', (e) => createControlPointDragHandler(e, conn, 'control2', cp2));
                    board.appendChild(cp2);
                }
            }
            
            function createControlPointDragHandler(e, conn, controlType, controlPoint) {
                e.stopPropagation();
                let isDraggingControl = true;
                
                function onControlDrag(moveEvent) {
                    if (!isDraggingControl) return;
                    const { x, y } = getBoardCoordinates(moveEvent.clientX, moveEvent.clientY);
                    controlPoint.style.left = x + 'px';
                    controlPoint.style.top = y + 'px';
                    
                    if (controlType === 'control1') {
                        conn.control1X = x;
                        conn.control1Y = y;
                    } else {
                        conn.control2X = x;
                        conn.control2Y = y;
                    }
                    
                    drawConnections();
                }
                
                function onControlDragEnd() {
                    isDraggingControl = false;
                    document.removeEventListener('mousemove', onControlDrag);
                    document.removeEventListener('mouseup', onControlDragEnd);
                    saveState();
                }
                
                document.addEventListener('mousemove', onControlDrag);
                document.addEventListener('mouseup', onControlDragEnd);
            }
            
            // [NEW] 隱藏線條控制點
            function hideConnectionControlPoints() {
                board.querySelectorAll('.connection-control-point').forEach(cp => cp.remove());
            }
            
            // [NEW] 刪除選取的關連線
            function deleteSelectedConnection() {
                if (!selectedConnection) return;
                
                const conn = connections.find(c => c.id === selectedConnection);
                if (!conn) return;
                
                // 移除 SVG 路徑
                const path = boardSvg.querySelector(`[data-conn-id="${selectedConnection}"]`);
                if (path) path.remove();
                
                // 移除標籤
                const labelEl = document.getElementById(`label_${selectedConnection}`);
                if (labelEl) labelEl.remove();
                
                // 移除控制點
                hideConnectionControlPoints();
                
                // 從連接陣列中移除
                connections = connections.filter(c => c.id !== selectedConnection);
                
                selectedConnection = null;
                saveState();
            }

            // --- 座標轉換 ---
            function getBoardCoordinates(clientX, clientY, raw = false) {
                const rect = boardContainer.getBoundingClientRect();
                if (raw) {
                     return { x: clientX - rect.left, y: clientY - rect.top };
                }
                const x = (clientX - rect.left - panX) / scale;
                const y = (clientY - rect.top - panY) / scale;
                return { x, y };
            }

            // --- History (Undo/Redo) ---
            function saveState() {
                if (isRestoring) return;
                const notesState = [];
                board.querySelectorAll('.sticky-note').forEach(note => {
                    const editable = note.querySelector('.editable');
                    const noteTitle = note.querySelector('.note-title-text');
                    const noteContent = note.querySelector('.note-content');
                    
                    let content = '';
                    if (noteTitle && noteContent) {
                        // 新格式：標題|||內容
                        content = noteTitle.innerHTML + '|||' + noteContent.innerHTML;
                    } else if (editable) {
                        // 舊格式
                        content = editable.innerHTML;
                    }
                    
                    notesState.push({
                        id: note.id,
                        x: parseFloat(note.style.left),
                        y: parseFloat(note.style.top),
                        isTitle: note.classList.contains('note-title'),
                        color: note.dataset.color,
                        content: content,
                        isGroup: note.classList.contains('group-container'),
                        width: note.style.width || null,
                        height: note.style.height || null,
                        isTextNode: note.dataset.isTextNode === 'true',
                        isImage: note.dataset.isImage === 'true',
                        imgSrc: note.dataset.imgSrc || '',
                        rotation: parseFloat(note.dataset.rotation || 0),
                        collapsed: note.classList.contains('collapsed')
                    });
                });
                const currentState = {
                    notes: notesState,
                    connections: connections,
                    settings: {
                        fontSize: currentFontSize,
                        minHeight: currentMinHeight,
                        connectionStyle: currentConnectionStyle
                    }
                };
                if (historyPointer > -1 && JSON.stringify(history[historyPointer]) === JSON.stringify(currentState)) {
                    return;
                }
                history = history.slice(0, historyPointer + 1);
                history.push(currentState);
                historyPointer++;

                updateFirestoreDebounced(currentState);
            }
            function restoreState(state) {
                if (!state) return;
                isRestoring = true;
                
                const nodesToRemove = board.querySelectorAll('.sticky-note');
                nodesToRemove.forEach(n => n.remove());
                
                board.querySelectorAll('.connection-label').forEach(l => l.remove());

                connections = [];
                drawConnections();
                
                if (state.settings) {
                    currentFontSize = state.settings.fontSize || 14;
                    currentMinHeight = state.settings.minHeight || 100;
                    currentConnectionStyle = state.settings.connectionStyle || 'cubic';
                } else {
                    currentFontSize = 14;
                    currentMinHeight = 100;
                    currentConnectionStyle = 'cubic';
                }
                connectionStyleSelect.value = currentConnectionStyle;
                applySettings(); 
                
                if (state.notes) {
                    state.notes.forEach(noteState => {
                        const options = {
                            id: noteState.id,
                            x: noteState.x,
                            y: noteState.y,
                            isTitle: noteState.isTitle,
                            color: noteState.color,
                            content: noteState.content,
                            isGroup: noteState.isGroup,
                            width: noteState.width,
                            height: noteState.height,
                            isTextNode: noteState.isTextNode,
                            isImage: noteState.isImage,
                            imgSrc: noteState.imgSrc,
                            rotation: noteState.rotation
                        };
                        const restoredNote = createNote(options, true);
                        if (noteState.collapsed && restoredNote) {
                            restoredNote.classList.add('collapsed');
                        }
                    });
                }
                connections = state.connections || [];
                drawConnections();
                isRestoring = false;
                clearSelection();
            }
            function undo() {
                if (historyPointer <= 0) {
                     if (historyPointer === 0 && history.length > 0) {
                         historyPointer = -1;
                         restoreState({ notes: [], connections: [] });
                     }
                    return;
                }
                historyPointer--;
                restoreState(history[historyPointer]);
            }
            function redo() {
                if (historyPointer < history.length - 1) {
                    historyPointer++;
                    restoreState(history[historyPointer]);
                }
            }
            
            // --- 頂部工具列功能 ---
            
            addGroupBtn.addEventListener('mousedown', (e) => {
                e.preventDefault();
                startDraggingFromButton('group', e);
            });

            addTextBtn.addEventListener('mousedown', (e) => {
                e.preventDefault();
                startDraggingFromButton('text', e);
            });

            // 從按鈕拖曳元素到畫布
            function startDraggingFromButton(type, startEvent) {
                let dragPreview = null;
                let isDragging = false;
                let offsetX = 10;
                let offsetY = 10;
                
                function onMouseMove(e) {
                    if (!isDragging) {
                        isDragging = true;
                        
                        // 創建拖曳預覽
                        dragPreview = document.createElement('div');
                        dragPreview.style.position = 'fixed';
                        dragPreview.style.pointerEvents = 'none';
                        dragPreview.style.zIndex = '10000';
                        dragPreview.style.opacity = '0.7';
                        dragPreview.style.padding = '1rem';
                        dragPreview.style.borderRadius = '0.5rem';
                        dragPreview.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.2)';
                        
                        if (type === 'group') {
                            dragPreview.style.width = '400px';
                            dragPreview.style.height = '300px';
                            dragPreview.style.backgroundColor = '#e5e7eb';
                            dragPreview.innerHTML = '<div style="font-weight: 600; color: #6b7280;">群組標題</div>';
                        } else if (type === 'text') {
                            dragPreview.style.padding = '0.5rem 1rem';
                            dragPreview.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
                            dragPreview.style.color = 'white';
                            dragPreview.style.fontSize = '0.875rem';
                            dragPreview.innerHTML = '輸入文字';
                        }
                        
                        document.body.appendChild(dragPreview);
                    }
                    
                    if (dragPreview) {
                        dragPreview.style.left = (e.clientX + offsetX) + 'px';
                        dragPreview.style.top = (e.clientY + offsetY) + 'px';
                    }
                }
                
                function onMouseUp(e) {
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                    
                    if (dragPreview) {
                        dragPreview.remove();
                    }
                    
                    // 如果有拖曳並且在畫布上放開
                    if (isDragging) {
                        const boardRect = boardContainer.getBoundingClientRect();
                        if (e.clientX >= boardRect.left && e.clientX <= boardRect.right &&
                            e.clientY >= boardRect.top && e.clientY <= boardRect.bottom) {
                            
                            // 使用與預覽相同的偏移量
                            const { x, y } = getBoardCoordinates(e.clientX + offsetX, e.clientY + offsetY);
                            
                            if (type === 'group') {
                                createNote({ 
                                    x: x, 
                                    y: y,
                                    isGroup: true, 
                                    color: 'bg-gray-200' 
                                });
                            } else if (type === 'text') {
                                createNote({ 
                                    x: x, 
                                    y: y,
                                    isTextNode: true,
                                });
                            }
                        }
                    }
                }
                
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            }
            
            clearBtn.addEventListener('click', () => {
                clearModal.classList.remove('hidden');
            });
            cancelClearBtn.addEventListener('click', () => {
                clearModal.classList.add('hidden');
            });
            confirmClearBtn.addEventListener('click', () => {
                restoreState({ notes: [], connections: [] });
                history = [];
                historyPointer = -1;
                saveState(); 
                clearModal.classList.add('hidden');
            });

            exportBtn.addEventListener('click', () => {
                const state = history[historyPointer];
                if (!state) state = { notes: [], connections: [] }; 
                
                const jsonString = JSON.stringify(state, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'affinity-board-export.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            });

            importBtn.addEventListener('click', () => {
                importInput.click();
            });
            importInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const state = JSON.parse(event.target.result);
                        if (state && state.notes && state.connections) {
                            restoreState(state);
                            history = [state]; 
                            historyPointer = 0;
                        } else {
                            throw new Error('無效的檔案格式');
                        }
                    } catch (err) {
                        console.error('匯入失敗:', err);
                    }
                };
                reader.readAsText(file);
                importInput.value = ''; 
            });

            screenshotBtn.addEventListener('click', () => {
                const uisToHide = [headerToolbar, helpButton, contextMenu, alignToolbar, ...document.querySelectorAll('.connector-node'), ...document.querySelectorAll('.resize-handle'), selectionBox];
                uisToHide.forEach(el => { if (el) el.style.visibility = 'hidden'; });
                
                const selected = [...selectedNotes];
                clearSelection();
                
                html2canvas(boardContainer, {
                    backgroundColor: '#f1f5f9',
                    useCORS: true,
                    logging: false,
                    x: board.getBoundingClientRect().left,
                    y: board.getBoundingClientRect().top,
                    width: board.getBoundingClientRect().width,
                    height: board.getBoundingClientRect().height
                }).then(canvas => {
                    const imgData = canvas.toDataURL('image/png');
                    const a = document.createElement('a');
                    a.href = imgData;
                    a.download = 'affinity-board.png';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);

                    uisToHide.forEach(el => { if (el) el.style.visibility = ''; });
                    selected.forEach(n => addNoteToSelection(n));
                    updateToolbarStates();
                    
                }).catch(err => {
                    console.error('截圖失敗:', err);
                    uisToHide.forEach(el => { if (el) el.style.visibility = ''; });
                    selected.forEach(n => addNoteToSelection(n));
                    updateToolbarStates();
                });
            });
            
            if (helpButton && helpModal) {
                helpButton.addEventListener('click', () => {
                    helpModal.classList.remove('hidden');
                });
            }
            if (helpModalCloseBtn && helpModal) {
                helpModalCloseBtn.addEventListener('click', () => {
                    helpModal.classList.add('hidden');
                });
            }
            if (helpModalOverlay && helpModal) {
                helpModalOverlay.addEventListener('click', () => {
                    helpModal.classList.add('hidden');
                });
            }

            if (settingsButton) {
                settingsButton.addEventListener('click', () => {
                    settingsModal.classList.remove('hidden');
                    fontSizeSlider.value = currentFontSize;
                    fontSizeValue.textContent = `${currentFontSize} px`;
                    cardHeightSlider.value = currentMinHeight;
                    cardHeightValue.textContent = `${currentMinHeight} px`;
                });
            }
            if (closeSettingsButton) {
                closeSettingsButton.addEventListener('click', () => {
                    settingsModal.classList.add('hidden');
                });
            }
            if (settingsModalOverlay) {
                settingsModalOverlay.addEventListener('click', () => {
                    settingsModal.classList.add('hidden');
                });
            }

            fontSizeSlider.addEventListener('input', (e) => {
                currentFontSize = parseInt(e.target.value, 10);
                fontSizeValue.textContent = `${currentFontSize} px`;
                applySettings(); 
            });
            fontSizeSlider.addEventListener('change', () => {
                saveState(); 
            });

            cardHeightSlider.addEventListener('input', (e) => {
                currentMinHeight = parseInt(e.target.value, 10);
                cardHeightValue.textContent = `${currentMinHeight} px`;
                applySettings(); 
            });
            cardHeightSlider.addEventListener('change', () => {
                saveState();
            });
            
            // 線條樣式選擇器
            connectionStyleSelect.addEventListener('change', (e) => {
                currentConnectionStyle = e.target.value;
                localStorage.setItem('affinity_connection_style', currentConnectionStyle);
                drawConnections();
            });
            
            // 讀取儲存的線條樣式
            const savedConnectionStyle = localStorage.getItem('affinity_connection_style');
            if (savedConnectionStyle) {
                currentConnectionStyle = savedConnectionStyle;
                connectionStyleSelect.value = savedConnectionStyle;
            }

            applySettings();
            saveState(); 
        });
    </script>
</body>
</html>
