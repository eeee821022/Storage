<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Data Validator (Web Version)</title>

    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18.2.0/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18.2.0/umd/react-dom.production.min.js"></script>

    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Google Fonts -->
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=JetBrains+Mono:wght@400;700&display=swap"
        rel="stylesheet">

    <!-- External Prompt Configuration -->
    <script src="miterSaw_Prompt.js"></script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc;
            color: #1e293b;
        }

        .font-mono {
            font-family: 'JetBrains Mono', monospace;
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f5f9;
        }

        ::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }

        /* Animations */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .animate-in {
            animation: fadeIn 0.3s ease-out forwards;
        }
    </style>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useCallback, useRef } = React;

        // ==========================================
        // CONSTANTS & PROMPTS
        // ==========================================

        // MiterSawPrompt is loaded from miterSaw_Prompt.js into window.PROMPT_REGISTRY
        // If the file is missing, we initialize an empty registry to avoid crash
        window.PROMPT_REGISTRY = window.PROMPT_REGISTRY || {};

        const UPDATE_DATE_COL = "Update Date";
        const HIDDEN_COLS = ["Brand Logo", "Image"];
        const CHUNK_SIZE = 10;
        const BASE_REQUEST_DELAY = 12000;
        const MAX_RETRIES = 3;

        // ==========================================
        // UTILS
        // ==========================================

        const calculateBladeRange = (diameterStr) => {
            if (!diameterStr) return "";
            const d = parseFloat(diameterStr.replace(/[^0-9.]/g, ''));
            if (isNaN(d)) return "";
            if (d <= 191) return "Ø0~191mm";
            if (d <= 222) return "Ø191~222mm";
            if (d <= 267) return "Ø222~267mm";
            if (d <= 279) return "Ø267~279mm";
            if (d <= 333) return "Ø279~333mm";
            if (d <= 371) return "Ø333~371mm";
            return "Ø371mm +";
        };

        // ==========================================
        // SERVICES
        // ==========================================

        // Google Sheets Service
        const fetchSheetNames = async (scriptUrl) => {
            const res = await fetch(`${scriptUrl}?action=getSheets`, { redirect: 'follow' });
            const data = await res.json();
            if (Array.isArray(data)) return data;
            throw new Error("Invalid sheet list received");
        };

        const fetchSheetData = async (scriptUrl, sheetName) => {
            const url = `${scriptUrl}?action=getData&sheet=${encodeURIComponent(sheetName)}`;
            const res = await fetch(url, { redirect: 'follow' });
            return await res.json();
        };

        // Gemini Service (Raw Fetch Implementation)
        const callGeminiAPI = async (dataChunk, prompt, modelName, apiKey) => {
            if (!apiKey) throw new Error("API Key is mandatory");

            const url = `https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent?key=${apiKey}`;

            const payload = {
                contents: [{
                    parts: [{
                        text: prompt + "\n\nData JSON:\n" + JSON.stringify(dataChunk)
                    }]
                }],
                generationConfig: {
                    responseMimeType: "application/json"
                },
                tools: [{ googleSearch: {} }] // Enable Google Search grounding
            };

            const response = await fetch(url, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errText = await response.text();
                // Check specifically for Quota Exceeded (429)
                if (response.status === 429) throw new Error("429 Quota Exceeded");
                throw new Error(`Gemini API Error: ${response.status} ${response.statusText} - ${errText}`);
            }

            const resJson = await response.json();

            try {
                const candidate = resJson.candidates?.[0];
                if (!candidate) throw new Error("No candidates returned");

                const text = candidate.content?.parts?.[0]?.text;
                if (!text) throw new Error("No text content in response");

                const parsed = JSON.parse(text);
                const groundingChunks = candidate.groundingMetadata?.groundingChunks || [];

                return { data: parsed, groundingChunks, rawResponse: resJson };
            } catch (e) {
                throw new Error("Failed to parse AI response: " + e.message);
            }
        };

        const listAvailableModels = async (apiKey) => {
            if (!apiKey) return ['gemini-2.0-flash-exp', 'gemini-1.5-pro']; // Fallback
            try {
                const url = `https://generativelanguage.googleapis.com/v1beta/models?key=${apiKey}`;
                const res = await fetch(url);
                const data = await res.json();
                if (data.models) {
                    return data.models
                        .filter(m => m.supportedGenerationMethods?.includes("generateContent"))
                        .map(m => m.name.replace('models/', ''))
                        .sort();
                }
                return ['gemini-2.0-flash-exp', 'gemini-1.5-pro'];
            } catch (e) {
                console.error("Failed to list models", e);
                return ['gemini-2.0-flash-exp', 'gemini-1.5-pro'];
            }
        };

        // ==========================================
        // MAIN DATA VALIDATOR COMPONENT
        // ==========================================

        const App = () => {
            // -- State: Config --
            const [scriptUrl, setScriptUrl] = useState(localStorage.getItem('AI_VALIDATOR_URL') || '');
            const [apiKey, setApiKey] = useState(localStorage.getItem('GOOGLE_AI_KEY') || '');

            // -- State: Data --
            const [sheetNames, setSheetNames] = useState([]);
            const [selectedSheet, setSelectedSheet] = useState("");
            const [selectedCountry, setSelectedCountry] = useState("USA");
            const [rawRows, setRawRows] = useState([]);

            // -- State: Status --
            const [isConnected, setIsConnected] = useState(false);
            const [isConnecting, setIsConnecting] = useState(false);
            const [isProcessing, setIsProcessing] = useState(false);
            const [isWaitingQuota, setIsWaitingQuota] = useState(false);
            const [progressPercent, setProgressPercent] = useState(0);

            // -- State: Models & Prompts --
            const [processedBatches, setProcessedBatches] = useState([]);
            const [model, setModel] = useState("gemini-2.5-flash");
            const [availableModels, setAvailableModels] = useState([]);
            const [excludedColumns, setExcludedColumns] = useState("A,B");

            const [logHistory, setLogHistory] = useState([]);
            const [activeLogType, setActiveLogType] = useState('none');
            const [selectedLogIndex, setSelectedLogIndex] = useState(0);

            // -- Effects --
            useEffect(() => {
                if (apiKey) {
                    localStorage.setItem('GOOGLE_AI_KEY', apiKey);
                    listAvailableModels(apiKey).then(list => {
                        // Updated Model Priority List based on latest available models
                        const priorityModels = [
                            'gemini-2.5-flash',
                            'gemini-2.5-flash-lite',
                            'gemini-3-flash',
                            'gemini-2.0-flash-exp',
                            'gemini-1.5-pro'
                        ];
                        const items = Array.from(new Set([...priorityModels, ...list]));
                        setAvailableModels(items.sort());
                    });
                }
            }, [apiKey]);

            const systemPrompt = useMemo(() => {
                // Currently generic, but expandable
                const config = window.PROMPT_REGISTRY["Miter Saw Validator"];
                if (!config) return "System Prompt Config Not Found. Please check miterSaw_Prompt.js";

                const sheet = selectedSheet.toLowerCase();
                let type = "Power Tools";
                if (sheet.includes('mts') || sheet.includes('miter')) type = "Miter Saws";
                if (sheet.includes('table')) type = "Table Saws";
                return config.systemPromptTemplate(type, selectedCountry);
            }, [selectedSheet, selectedCountry]);

            // -- Handlers --
            const handleConnect = async () => {
                if (!scriptUrl) return alert("Please enter GAS Script URL");
                setIsConnecting(true);
                setIsConnected(false);
                try {
                    const data = await fetchSheetNames(scriptUrl);
                    setSheetNames(data);
                    setIsConnected(true);
                    localStorage.setItem('AI_VALIDATOR_URL', scriptUrl);
                } catch (e) {
                    alert("Connection failed: " + e.message);
                } finally {
                    setIsConnecting(false);
                }
            };

            const handleLoadSheetData = async (sheetName) => {
                setSelectedSheet(sheetName);
                if (!sheetName || !isConnected) return;
                try {
                    const data = await fetchSheetData(scriptUrl, sheetName);
                    const sanitizeKey = (k) => k.replace(/[\n\r]/g, " ").trim();
                    const cleaned = data
                        .filter(row => (row['Model #'] || row['機型'] || row['Brand'] || row['品牌']))
                        .map(row => {
                            const newRow = {};
                            Object.keys(row).forEach(k => {
                                const cleanK = sanitizeKey(k);
                                if (!cleanK.startsWith('_')) newRow[cleanK] = row[k];
                            });
                            // Normalize Date
                            const dateVal = newRow[UPDATE_DATE_COL] || newRow["更新日期"] || "";
                            delete newRow["更新日期"];
                            newRow[UPDATE_DATE_COL] = dateVal;
                            return newRow;
                        });
                    setRawRows(cleaned);
                    setProcessedBatches([]);
                    setLogHistory([]);
                } catch (e) {
                    alert("Read failed: " + e.message);
                }
            };

            // -- Table Headers Logic --
            const fullHeadersOrder = useMemo(() => {
                if (rawRows.length === 0) return [];
                const currentKeys = Object.keys(rawRows[0]);
                const fixedOrder = [...HIDDEN_COLS, UPDATE_DATE_COL];
                const rest = currentKeys.filter(k => !fixedOrder.some(fo => fo.toLowerCase() === k.toLowerCase()));
                return [...fixedOrder, ...rest];
            }, [rawRows]);

            const displayHeaders = useMemo(() => {
                return fullHeadersOrder.filter(h => !HIDDEN_COLS.includes(h));
            }, [fullHeadersOrder]);

            const parseExcludedColumns = useCallback(() => {
                if (!excludedColumns || rawRows.length === 0) return [];
                const input = excludedColumns.split(',').map(s => s.trim().toUpperCase());
                const headers = fullHeadersOrder;
                return input.map(val => {
                    if (/^[A-Z]+$/.test(val)) { // Convert A, B, C to Header Name
                        let colIndex = 0;
                        for (let i = 0; i < val.length; i++) colIndex = colIndex * 26 + (val.charCodeAt(i) - 64);
                        return headers[colIndex - 1];
                    }
                    return val;
                }).filter(h => h);
            }, [excludedColumns, rawRows, fullHeadersOrder]);

            // -- Processing Logic --
            const startBatchProcessing = async () => {
                if (rawRows.length === 0 || isProcessing) return;
                if (!apiKey) return alert("Please enter API Key first!");

                setIsProcessing(true);
                setProgressPercent(0);
                setProcessedBatches([]);
                setLogHistory([]);

                const today = new Date().toISOString().split('T')[0];
                const groups = {};
                // Group by Brand
                rawRows.forEach(row => {
                    const brandVal = String(row['Brand'] || row['品牌'] || 'Unknown').trim();
                    if (!groups[brandVal]) groups[brandVal] = [];
                    groups[brandVal].push(row);
                });

                const brandKeys = Object.keys(groups);
                let totalItemsProcessed = 0;

                for (let i = 0; i < brandKeys.length; i++) {
                    const brand = brandKeys[i];
                    const allBrandData = groups[brand];
                    const currentPrompt = systemPrompt.replace(/{{BRAND}}/g, brand);

                    for (let chunkIdx = 0; chunkIdx < allBrandData.length; chunkIdx += CHUNK_SIZE) {
                        const batchData = allBrandData.slice(chunkIdx, chunkIdx + CHUNK_SIZE);
                        let success = false;
                        let retryCount = 0;

                        while (!success && retryCount < MAX_RETRIES) {
                            try {
                                if (totalItemsProcessed > 0 || retryCount > 0) {
                                    const delay = retryCount > 0 ? 30000 : BASE_REQUEST_DELAY;
                                    if (retryCount > 0) setIsWaitingQuota(true);
                                    await new Promise(r => setTimeout(r, delay));
                                    setIsWaitingQuota(false);
                                }

                                const { data: result, groundingChunks } = await callGeminiAPI(batchData, currentPrompt, model, apiKey);
                                const lockedCols = parseExcludedColumns();

                                const finalizeRow = (item, original) => {
                                    if (original) {
                                        lockedCols.forEach(col => { if (col) item[col] = original[col]; });
                                    }
                                    if (item["Blade Diameter"]) {
                                        item["Blade Range"] = calculateBladeRange(item["Blade Diameter"]);
                                    }
                                    if (original) {
                                        const changed = displayHeaders.some(h =>
                                            h !== UPDATE_DATE_COL &&
                                            String(item[h] || "").trim() !== String(original[h] || "").trim()
                                        );
                                        item[UPDATE_DATE_COL] = changed ? `${today} Corrected` : (original[UPDATE_DATE_COL] || "");
                                    } else {
                                        item[UPDATE_DATE_COL] = `${today} New Item`;
                                    }
                                    return item;
                                };

                                const corrected = (result.corrected || []).map((item, idx) => finalizeRow(item, batchData[idx]));
                                const newItems = (result.new_items || []).map((item) => finalizeRow(item));
                                const groundingUrls = groundingChunks?.map((c) => c.web).filter(w => w && w.uri) || [];

                                setProcessedBatches(prev => [...prev, { brand, original: batchData, corrected, newItems, groundingUrls }]);

                                setLogHistory(prev => [{
                                    timestamp: new Date().toLocaleTimeString(),
                                    brand: `${brand} (Batch ${Math.floor(chunkIdx / CHUNK_SIZE) + 1})`,
                                    prompt: currentPrompt,
                                    request: batchData,
                                    response: result
                                }, ...prev]);

                                setSelectedLogIndex(0);
                                success = true;
                            } catch (e) {
                                console.error(`Audit Error [${brand}]:`, e);
                                if (e.message.includes('Quota') || e.message.includes('429')) {
                                    retryCount++;
                                    if (retryCount >= MAX_RETRIES) {
                                        alert(`Quota Exceeded. Pausing. Try Flash-Lite model.`);
                                        break;
                                    }
                                    continue;
                                }
                                alert(`Error: ${e.message}`);
                                break;
                            }
                        }
                        totalItemsProcessed++;
                    }
                    setProgressPercent(Math.floor(((i + 1) / brandKeys.length) * 100));
                }
                setIsProcessing(false);
                setIsWaitingQuota(false);
            };

            const copyDataSheet = useCallback(() => {
                if (processedBatches.length === 0) {
                    alert("No data to copy");
                    return;
                }
                let tsv = displayHeaders.join('\t') + '\n';
                processedBatches.forEach(batch => {
                    const rows = [...batch.corrected, ...batch.newItems];
                    rows.forEach(row => {
                        const line = displayHeaders.map(h => row[h] || '').join('\t');
                        tsv += line + '\n';
                    });
                });
                navigator.clipboard.writeText(tsv).then(() => alert("Copied to clipboard (TSV)")).catch(err => alert("Copy failed: " + err));
            }, [processedBatches, displayHeaders]);

            const getActiveContent = () => {
                const entry = logHistory[selectedLogIndex];
                if (!entry) return "No logs.";
                return activeLogType === 'prompt' ? entry.prompt : JSON.stringify(entry.response, null, 2);
            };

            const downloadActiveLog = () => {
                const content = getActiveContent();
                const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url; link.download = `log_${activeLogType}.txt`;
                document.body.appendChild(link); link.click(); document.body.removeChild(link);
            };

            // -- RENDER --
            return (
                <div className="container mx-auto p-4 max-w-full text-slate-800 pb-20">
                    <header className="mb-6 flex flex-col md:flex-row justify-between items-center bg-white p-6 rounded-2xl shadow-sm border border-slate-100 gap-4">
                        <div>
                            <h1 className="text-2xl font-black text-slate-800 tracking-tight flex items-center gap-2">
                                <span>AI DATA VALIDATOR</span>
                                <span className="text-[10px] bg-blue-100 text-blue-600 px-2 py-0.5 rounded-full">WEB EDITION</span>
                            </h1>
                            <p className="text-slate-400 text-[9px] font-bold uppercase tracking-[0.2em] mt-1">Audit Engine v3.1 | Single File Port</p>
                        </div>
                        <div className="flex flex-col gap-2 w-full md:w-auto">
                            <div className="flex gap-2 items-center">
                                <input
                                    type="password" value={apiKey} onChange={(e) => setApiKey(e.target.value)} placeholder="Enter Gemini API Key..."
                                    className="flex-1 md:w-64 px-4 py-2 text-xs border border-slate-200 rounded-xl outline-none focus:ring-2 focus:ring-purple-500 bg-slate-50"
                                />
                            </div>
                            <div className="flex gap-2 items-center">
                                <input
                                    type="text" value={scriptUrl} onChange={(e) => setScriptUrl(e.target.value)} placeholder="GAS Script URL"
                                    className="flex-1 md:w-64 px-4 py-2 text-xs border border-slate-200 rounded-xl outline-none focus:ring-2 focus:ring-blue-500 bg-slate-50"
                                />
                                <button
                                    onClick={handleConnect} disabled={isConnecting}
                                    className={`px-6 py-2 rounded-xl text-xs font-black transition-all shadow-sm ${isConnecting ? 'bg-slate-100 text-slate-400' : isConnected ? 'bg-green-600 text-white' : 'bg-slate-800 text-white'
                                        }`}
                                >
                                    {isConnecting ? '...' : isConnected ? 'OK' : 'CONN'}
                                </button>
                            </div>
                        </div>
                    </header>

                    <div className="grid grid-cols-1 lg:grid-cols-12 gap-6">
                        {/* Sidebar Config */}
                        <aside className="lg:col-span-3 space-y-4">
                            <div className="bg-white p-5 rounded-2xl shadow-sm border border-slate-100 space-y-4">
                                <div>
                                    <label className="text-[10px] font-black text-slate-400 block mb-2 uppercase">Region</label>
                                    <select value={selectedCountry} onChange={(e) => setSelectedCountry(e.target.value)} className="w-full p-2 border rounded-xl text-sm bg-orange-50 font-bold text-orange-700">
                                        <option value="USA">USA</option><option value="DEU">DEU</option><option value="TW">TW</option><option value="JP">JP</option>
                                    </select>
                                </div>
                                <div>
                                    <label className="text-[10px] font-black text-slate-400 block mb-2 uppercase">Sheet</label>
                                    <select value={selectedSheet} onChange={(e) => handleLoadSheetData(e.target.value)} className="w-full p-2 border rounded-xl text-sm bg-slate-50">
                                        <option value="" disabled>Select Sheet...</option>
                                        {sheetNames.map(n => <option key={n} value={n}>{n}</option>)}
                                    </select>
                                </div>
                            </div>

                            <div className="bg-white p-5 rounded-2xl shadow-sm border border-slate-100 space-y-4">
                                <div>
                                    <label className="text-[10px] font-black text-slate-400 block mb-2 uppercase">Model</label>
                                    <select value={model} onChange={(e) => setModel(e.target.value)} className="w-full p-2 border rounded-xl text-sm bg-blue-50 font-bold text-blue-700">
                                        {availableModels.map(m => <option key={m} value={m}>{m}</option>)}
                                    </select>
                                </div>
                                <div>
                                    <label className="text-[10px] font-black text-slate-400 block mb-2 uppercase">Lock Cols</label>
                                    <input type="text" value={excludedColumns} onChange={(e) => setExcludedColumns(e.target.value)} placeholder="A,B" className="w-full p-2 border rounded-xl text-xs" />
                                </div>
                            </div>

                            <button
                                onClick={startBatchProcessing} disabled={isProcessing || !selectedSheet}
                                className={`w-full text-white font-black py-4 rounded-2xl shadow-xl transition-all active:scale-95 disabled:opacity-50 ${isWaitingQuota ? 'bg-orange-500 animate-pulse' : 'bg-blue-600 hover:bg-blue-700'
                                    }`}
                            >
                                {isWaitingQuota ? 'WAITING QUOTA...' : isProcessing ? `AUDITING ${progressPercent}%` : 'START AUDIT'}
                            </button>
                        </aside>

                        {/* Main Content */}
                        <main className="lg:col-span-9 space-y-4">
                            {/* Toolbar */}
                            <div className="flex flex-wrap gap-2 p-3 bg-slate-100 rounded-2xl border border-slate-200 shadow-sm">
                                <button onClick={() => setActiveLogType('prompt')} className="px-5 py-2.5 bg-white border border-slate-300 rounded-xl text-xs font-bold text-slate-700 hover:bg-slate-50">1. View Prompt</button>
                                <button onClick={() => setActiveLogType('reply')} className="px-5 py-2.5 bg-white border border-slate-300 rounded-xl text-xs font-bold text-slate-700 hover:bg-slate-50">2. View Response</button>
                                <div className="flex-1"></div>
                                <button onClick={copyDataSheet} className="px-5 py-2.5 bg-indigo-600 text-white rounded-xl text-xs font-bold hover:bg-indigo-700 shadow-lg">3. Copy C+</button>
                            </div>

                            {/* Data Table */}
                            <div className="bg-white rounded-2xl shadow-sm border border-slate-100 h-[600px] overflow-hidden flex flex-col">
                                <div className="p-4 border-b bg-slate-50 text-[10px] font-black text-slate-500 uppercase flex justify-between">
                                    <span>Preview Table</span>
                                    {processedBatches.length > 0 && <span className="text-blue-600 font-black animate-pulse">DONE</span>}
                                </div>
                                <div className="flex-1 overflow-auto">
                                    {processedBatches.length === 0 ? (
                                        <div className="h-full flex items-center justify-center text-slate-300 font-bold uppercase text-xs">Ready</div>
                                    ) : (
                                        <div className="space-y-6">
                                            {/* Sources */}
                                            {processedBatches.some(b => b.groundingUrls?.length) && (
                                                <div className="p-2 bg-yellow-50 border-b border-yellow-100 flex flex-wrap gap-2">
                                                    {Array.from(new Set(processedBatches.flatMap(b => b.groundingUrls || []).map(u => u.uri))).map((uri, i) => (
                                                        <a key={i} href={uri} target="_blank" className="text-[9px] bg-white border border-yellow-200 px-2 rounded hover:bg-yellow-100 text-yellow-700 truncate max-w-[200px]">{uri}</a>
                                                    ))}
                                                </div>
                                            )}
                                            {/* Table */}
                                            <table className="w-full text-[10px] border-collapse table-fixed">
                                                <thead className="bg-slate-50 sticky top-0 font-bold text-slate-600">
                                                    <tr>{displayHeaders.map(h => <th key={h} className="p-2 border-r bg-slate-50 w-[120px] truncate">{h}</th>)}</tr>
                                                </thead>
                                                <tbody>
                                                    {processedBatches.map((batch, bIdx) => (
                                                        <React.Fragment key={bIdx}>
                                                            <tr className="bg-blue-600 text-white"><td colSpan={displayHeaders.length} className="p-1 px-4 font-bold uppercase">BRAND: {batch.brand}</td></tr>
                                                            {[...batch.corrected, ...batch.newItems].map((row, rIdx) => {
                                                                const original = batch.original[rIdx];
                                                                return (
                                                                    <tr key={rIdx} className="hover:bg-slate-50 border-b group">
                                                                        {displayHeaders.map(h => {
                                                                            const isChanged = original && String(row[h] || "").trim() !== String(original[h] || "").trim() && h !== UPDATE_DATE_COL;
                                                                            return (
                                                                                <td key={h} className="p-2 border-r border-slate-100 truncate">
                                                                                    <span className={`${isChanged ? 'text-red-600 font-black bg-red-50' : ''} ${!original ? 'text-blue-700 italic' : ''}`}>
                                                                                        {row[h] || '-'}
                                                                                    </span>
                                                                                </td>
                                                                            );
                                                                        })}
                                                                    </tr>
                                                                );
                                                            })}
                                                        </React.Fragment>
                                                    ))}
                                                </tbody>
                                            </table>
                                        </div>
                                    )}
                                </div>
                            </div>

                            {/* Logs Modal */}
                            {activeLogType !== 'none' && (
                                <div className="bg-slate-900 rounded-2xl p-6 text-white font-mono text-[11px] space-y-4 shadow-2xl animate-in">
                                    <div className="flex justify-between items-center border-b border-slate-800 pb-4">
                                        <div className="flex flex-col gap-2">
                                            <h3 className="text-blue-400 font-black uppercase">{activeLogType === 'prompt' ? '>>> SYSTEM PROMPT' : '<<< AI RAW RESPONSE'}</h3>
                                            <select value={selectedLogIndex} onChange={(e) => setSelectedLogIndex(Number(e.target.value))} className="bg-slate-800 text-blue-300 text-[10px] rounded p-1 border border-slate-700">
                                                {logHistory.map((l, idx) => <option key={idx} value={idx}>{l.brand} - {l.timestamp}</option>)}
                                            </select>
                                        </div>
                                        <div className="flex gap-2">
                                            <button onClick={downloadActiveLog} className="px-4 py-2 bg-blue-600 rounded-lg font-bold">DL</button>
                                            <button onClick={() => setActiveLogType('none')} className="px-4 py-2 bg-slate-800 rounded-lg text-slate-400 font-bold hover:text-white">X</button>
                                        </div>
                                    </div>
                                    <pre className="whitespace-pre-wrap overflow-x-auto max-h-[300px] text-slate-300 scrollbar-thin scrollbar-thumb-slate-700">
                                        {getActiveContent()}
                                    </pre>
                                </div>
                            )}

                        </main>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>