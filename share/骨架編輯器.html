<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D 關節骨架編輯器</title>
    <!-- 載入 Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 設定字體為 Inter，並添加一些基礎樣式 */
        body { font-family: 'Inter', sans-serif; background-color: #1f2937; }
        #pose-canvas {
            background-color: #0d121b; /* 深色背景 */
            border: 1px solid #374151;
            cursor: grab;
            transition: border 0.1s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }
        #pose-canvas.grabbing { cursor: grabbing; }
        /* 隱藏預設的 range input 焦點線，使用 custom focus ring */
        input[type=range]:focus { outline: none; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #60a5fa;
            cursor: pointer;
            border-radius: 9999px;
            box-shadow: 0 0 2px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body class="p-4 md:p-8 min-h-screen flex flex-col items-center">

    <div class="max-w-4xl w-full">
        <h1 class="text-3xl font-bold text-white mb-2">2D 關節骨架編輯器</h1>
        <p class="text-gray-400 mb-6">點擊線段選取刪除，點擊端點拖曳。端點靠近時會自動吸附重連 (CAD 拉線概念)。新增模式下可點擊空白處創建新的線段起點。</p>

        <div class="flex flex-col gap-4 mb-6 p-4 bg-gray-800 rounded-lg shadow-xl">
            
            <!-- AI 姿勢捕捉區塊 -->
            <div class="flex flex-col md:flex-row gap-4 items-center">
                <input type="file" id="image-input" accept="image/*" class="flex-1 p-2 text-sm text-white bg-gray-700 rounded-lg file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100"/>
                <button id="ai-capture-btn" class="w-full md:w-auto px-6 py-2 bg-purple-600 text-white font-semibold rounded-lg shadow-md hover:bg-purple-700 transition duration-150 disabled:opacity-50" disabled>
                    AI 捕捉姿勢並覆蓋
                </button>
            </div>

            <!-- 底圖控制區塊 -->
            <div id="bg-controls" class="pt-4 border-t border-gray-700 space-y-3">
                <button id="toggle-bg-btn" class="w-full px-4 py-2 bg-yellow-600 text-white font-semibold rounded-lg shadow-md hover:bg-yellow-700 transition duration-150 disabled:opacity-50" disabled>
                    顯示/隱藏底圖
                </button>
                <div class="flex flex-wrap gap-4">
                    <div class="flex-1 min-w-[200px] space-y-1">
                        <label class="text-white text-sm block">縮放 (<span id="scale-value">1.00</span>)</label>
                        <input type="range" id="bg-scale-slider" min="0.1" max="3.0" step="0.01" value="1.0" class="w-full h-2 bg-gray-700 rounded-lg appearance-none" disabled>
                    </div>
                    <div class="flex-1 min-w-[200px] space-y-1">
                        <label class="text-white text-sm block">X 偏移 (<span id="offset-x-value">0</span>px)</label>
                        <input type="range" id="bg-offset-x-slider" min="-500" max="500" step="5" value="0" class="w-full h-2 bg-gray-700 rounded-lg appearance-none" disabled>
                    </div>
                    <div class="flex-1 min-w-[200px] space-y-1">
                        <label class="text-white text-sm block">Y 偏移 (<span id="offset-y-value">0</span>px)</label>
                        <input type="range" id="bg-offset-y-slider" min="-500" max="500" step="5" value="0" class="w-full h-2 bg-gray-700 rounded-lg appearance-none" disabled>
                    </div>
                </div>
            </div>


            <!-- 編輯器控制區 -->
            <div class="flex flex-col md:flex-row gap-4 pt-4 border-t border-gray-700">
                <button id="add-joint-btn" class="flex-1 px-4 py-2 bg-indigo-600 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700 transition duration-150">
                    新增線段 (CAD 模式切換)
                </button>
                <button id="delete-joint-btn" class="flex-1 px-4 py-2 bg-red-600 text-white font-semibold rounded-lg shadow-md hover:bg-red-700 transition duration-150">
                    刪除選取線段 (Delete 鍵)
                </button>
                <button id="save-btn" class="flex-1 px-4 py-2 bg-green-600 text-white font-semibold rounded-lg shadow-md hover:bg-green-700 transition duration-150">
                    儲存姿勢 (下載檔案)
                </button>
                <button id="load-btn" class="flex-1 px-4 py-2 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 transition duration-150">
                    載入姿勢 (從雲端)
                </button>
            </div>
        </div>

        <!-- 畫布容器和狀態訊息 -->
        <div class="relative w-full h-[600px] bg-gray-900 rounded-lg overflow-hidden">
            <canvas id="pose-canvas" class="w-full h-full"></canvas>
            <div id="status-message" class="absolute top-2 left-2 p-2 text-sm text-yellow-300 bg-gray-800 bg-opacity-70 rounded-md transition duration-300 pointer-events-none opacity-0">
                狀態訊息...
            </div>
            <div id="user-info" class="absolute bottom-2 right-2 p-2 text-xs text-gray-400 bg-gray-800 bg-opacity-70 rounded-md">
                用戶 ID: 載入中...
            </div>
        </div>
    </div>

    <!-- 模組化 JavaScript (包含 Firebase 和 Canvas 邏輯) -->
    <script type="module">
        // --- 1. Firebase 核心引用 ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- 2. 環境變數和 Firebase 初始化 ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let db, auth, userId = null;
        let isAuthReady = false;

        if (Object.keys(firebaseConfig).length > 0) {
            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
        } else {
            console.error("Firebase 配置遺失。應用程式將無法使用持久性儲存功能。");
        }

        const skeletonDocPath = (uid) => `artifacts/${appId}/users/${uid}/skeletons/current_pose`;
        const userInfoEl = document.getElementById('user-info');
        
        // 模組所需：將 Base64 轉換為 ArrayBuffer（為 TTS 預留，儘管在此應用程式中未使用）
        const base64ToArrayBuffer = (base64) => { /* ... TTS utility ... */ };
        // 模組所需：將 PCM 轉換為 WAV Blob（為 TTS 預留，儘管在此應用程式中未使用）
        const pcmToWav = (pcmData, sampleRate) => { /* ... TTS utility ... */ };

        // --- 3. 認證和初始化流程 ---
        const authPromise = new Promise(resolve => {
            if (auth) {
                onAuthStateChanged(auth, async (user) => {
                    if (!user) {
                        try {
                            if (initialAuthToken) {
                                await signInWithCustomToken(auth, initialAuthToken);
                            } else {
                                await signInAnonymously(auth);
                            }
                            user = auth.currentUser;
                        } catch (error) {
                            console.error("Firebase 登入失敗:", error);
                        }
                    }
                    if (user) {
                        userId = user.uid;
                        isAuthReady = true;
                        userInfoEl.textContent = `用戶 ID: ${userId}`;
                        resolve();
                    } else {
                        userInfoEl.textContent = `用戶 ID: 匿名 (未登入)`;
                        resolve(); // 即使失敗也繼續，但不使用 Firestore
                    }
                });
            } else {
                // 沒有 Firebase Config 時，視為 Auth Ready，但不執行 Firebase 操作
                isAuthReady = true;
                resolve();
            }
        });

        // --- 4. 畫布和繪圖邏輯 ---
        const canvas = document.getElementById('pose-canvas');
        const ctx = canvas.getContext('2d');
        let width, height;

        // 關節資料結構
        let joints = [];
        let nextJointId = 0; // 用於生成唯一的關節 ID

        // 被選中的線段 (子節點的 ID)
        let selectedBoneId = null;

        // 預設骨架 (保持不變)
        const initialSkeleton = [
            { id: 0, x: 400, y: 150, parentId: null, name: 'Root' },
            { id: 1, x: 400, y: 250, parentId: 0, name: 'Pelvis' },
            { id: 2, x: 400, y: 350, parentId: 1, name: 'Chest' },
            { id: 3, x: 400, y: 50, parentId: 2, name: 'Head' },
            { id: 4, x: 300, y: 350, parentId: 2, name: 'LShoulder' },
            { id: 5, x: 200, y: 300, parentId: 4, name: 'LElbow' },
            { id: 6, x: 100, y: 300, parentId: 5, name: 'LHand' },
            { id: 7, x: 500, y: 350, parentId: 2, name: 'RShoulder' },
            { id: 8, x: 600, y: 300, parentId: 7, name: 'RElbow' },
            { id: 9, x: 700, y: 300, parentId: 8, name: 'RHand' },
            { id: 10, x: 350, y: 450, parentId: 1, name: 'LHip' },
            { id: 11, x: 300, y: 550, parentId: 10, name: 'LKnee' },
            { id: 12, x: 250, y: 550, parentId: 11, name: 'LFoot' },
            { id: 13, x: 450, y: 450, parentId: 1, name: 'RHip' },
            { id: 14, x: 500, y: 550, parentId: 13, name: 'RKnee' },
            { id: 15, x: 550, y: 550, parentId: 14, name: 'RFoot' },
        ];
        
        // 確保 IDs 從最高的初始 ID 開始
        nextJointId = initialSkeleton.reduce((max, joint) => Math.max(max, joint.id), -1) + 1;
        joints = initialSkeleton.map(j => ({ ...j, id: j.id.toString(), parentId: j.parentId !== null ? j.parentId.toString() : null }));

        // --- 互動變數初始化 ---
        let isDragging = false;
        let selectedJointId = null; // 用於拖曳和選取端點
        let dragOffsetX = 0;
        let dragOffsetY = 0;
        let isAddingJoint = false; // 新增模式狀態
        
        // CAD新增模式變數
        let startJointId = null; 
        let tempJoint = null; // Used for drawing the line preview in CAD mode

        // --- 背景底圖狀態變數 ---
        let bgImage = new Image();
        let isBackgroundLoaded = false;
        let isBackgroundVisible = false;
        let bgScale = 1.0;
        let bgOffsetX = 0;
        let bgOffsetY = 0;
        // ------------------------

        // 調整畫布尺寸以符合容器
        const resizeCanvas = () => {
            width = canvas.clientWidth;
            height = canvas.clientHeight;
            canvas.width = width;
            canvas.height = height;
            draw();
        };

        const drawJoint = (joint, isSelected = false) => {
            ctx.beginPath();
            let size = isSelected ? 8 : 6;
            // 選取狀態下顯示更亮的顏色
            let color = isSelected ? '#10b981' : '#34d399'; 
            let strokeColor = isSelected ? '#ffffff' : '#000000';

            // --- 圓形頭部優化：頭部尺寸放大，並參與吸附 ---
            if (joint.name === 'Head') {
                size = isSelected ? 22 : 20; // 頭部尺寸放大
            }
            
            // 如果處於新增模式，則將選取的節點顯示為紅色
            if (isAddingJoint && isSelected) {
                color = '#ef4444';
            }

            // 繪製關節端點
            ctx.arc(joint.x, joint.y, size, 0, Math.PI * 2);
            ctx.fillStyle = color; 
            ctx.fill();
            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = isSelected ? 2 : 1;
            ctx.stroke();
        };

        const drawBone = (joint, parentJoint, isSelected = false) => {
            ctx.beginPath();
            ctx.moveTo(parentJoint.x, parentJoint.y);
            ctx.lineTo(joint.x, joint.y);
            // 選取線段時變為白色
            ctx.strokeStyle = isSelected ? '#ffffff' : '#60a5fa'; // 藍色
            ctx.lineWidth = 4;
            ctx.stroke();
        };

        const draw = () => {
            if (!ctx) return;
            ctx.clearRect(0, 0, width, height);

            // --- 1. 繪製底圖 (如果已載入且可見) ---
            if (isBackgroundLoaded && isBackgroundVisible) {
                const imgW = bgImage.width * bgScale;
                const imgH = bgImage.height * bgScale;
                
                // 計算起始位置 (居中 + 偏移)
                const startX = (width - imgW) / 2 + bgOffsetX;
                const startY = (height - imgH) / 2 + bgOffsetY;

                ctx.save();
                ctx.globalAlpha = 0.5; // 讓底圖半透明，方便看到骨架
                ctx.drawImage(bgImage, startX, startY, imgW, imgH);
                ctx.restore();
            }

            // 2. 繪製骨骼 (連線)
            for (const joint of joints) {
                if (joint.parentId !== null) {
                    const parentJoint = joints.find(j => j.id === joint.parentId);
                    if (parentJoint) {
                        // 檢查是否為選中線段
                        const isSelected = (joint.id === selectedBoneId);
                        drawBone(joint, parentJoint, isSelected);
                    }
                }
            }
            // ----------------------------------------

            // --- CAD 模式：繪製暫時線段 ---
            if (isAddingJoint && startJointId !== null && tempJoint !== null) {
                const startJoint = joints.find(j => j.id === startJointId);
                if (startJoint) {
                    // 繪製從起點到滑鼠位置的暫時骨骼線
                    ctx.beginPath();
                    ctx.moveTo(startJoint.x, startJoint.y);
                    ctx.lineTo(tempJoint.x, tempJoint.y);
                    ctx.strokeStyle = '#fcd34d'; // 黃色預覽線
                    ctx.lineWidth = 4;
                    ctx.stroke();

                    // 繪製滑鼠位置的暫時端點
                    ctx.beginPath();
                    ctx.arc(tempJoint.x, tempJoint.y, 6, 0, Math.PI * 2);
                    ctx.fillStyle = '#fcd34d';
                    ctx.fill();
                }
            }
            // --------------------------------

            // 3. 繪製關節 (節點/端點)
            for (const joint of joints) {
                // 檢查是否為被拖曳的端點，或被點擊選中的端點
                const isJointSelected = (joint.id === selectedJointId);
                drawJoint(joint, isJointSelected);
            }
        };

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // **NEW FUNCTION**: 刪除所有沒有連線的非 Root 節點 (強化線段概念)
        const cleanupIsolatedNodes = () => {
            const initialJointCount = joints.length;
            
            // 找出所有非 Root 且沒有任何連線 (無父節點 and 無子節點) 的節點
            joints = joints.filter(joint => {
                // 檢查是否是 Root 節點 (ID 0)
                if (joint.id === '0' && joint.parentId === null) {
                    // 只有當 ID 0 有孩子，才保留它。如果 ID 0 沒有孩子，它也算孤立，但我們在 deleteJoint 已經允許刪除它。
                    const hasChildren = joints.some(c => c.parentId === '0');
                    return hasChildren; 
                }
                
                const hasParent = joint.parentId !== null;
                const hasChildren = joints.some(c => c.parentId === joint.id);
                
                // 如果是 Root 節點 (ID 0)，我們在 deleteJoint 處理
                if (joint.id === '0') return true; 

                // 如果有父節點 OR 有子節點，則保留它
                return hasParent || hasChildren;
            });

            if (joints.length < initialJointCount) {
                draw(); // 如果有移除節點，則需要重繪
            }
        };


        // --- 5. 互動邏輯 (拖曳、新增和刪除) ---
        
        const getJointAtPoint = (x, y) => {
            // 點擊區域優化：增大半徑到 15 像素
            const HIT_RADIUS = 15; 
            for (let i = joints.length - 1; i >= 0; i--) {
                const joint = joints[i];
                const distance = Math.sqrt((joint.x - x) ** 2 + (joint.y - y) ** 2);
                const currentHitRadius = joint.name === 'Head' ? 20 : HIT_RADIUS; // 頭部更容易點擊
                if (distance < currentHitRadius) { 
                    return joint;
                }
            }
            return null;
        };
        
        // **線段選取**：檢查點擊是否在線段上
        const getBoneAtPoint = (x, y) => {
            // 線段點擊容忍度
            const TOLERANCE = 8; 

            for (const joint of joints) {
                if (joint.parentId !== null) {
                    const P1 = joints.find(j => j.id === joint.parentId);
                    const P2 = joint; // 子節點 (線段的終點)

                    if (!P1) continue;

                    // 檢查點到線段的距離
                    const length2 = (P2.x - P1.x) ** 2 + (P2.y - P1.y) ** 2;
                    if (length2 === 0) continue; // 零長度線段跳過

                    const t = ((x - P1.x) * (P2.x - P1.x) + (y - P1.y) * (P2.y - P1.y)) / length2;
                    
                    if (t >= 0 && t <= 1) {
                        // 點的投影落在線段內部
                        const projectionX = P1.x + t * (P2.x - P1.x);
                        const projectionY = P1.y + t * (P2.y - P1.y);
                        
                        const distance = Math.sqrt((x - projectionX) ** 2 + (y - projectionY) ** 2);
                        
                        if (distance < TOLERANCE) {
                            return joint.id; // 返回子節點 ID 作為線段 ID
                        }
                    }
                }
            }
            return null;
        };


        // 遞迴刪除關節及其所有子節點
        const deleteJoint = (jointIdToDelete) => {
            // FIX: 允許刪除 Root 節點，但必須是孤立的
            if (jointIdToDelete === '0') {
                const hasChildren = joints.some(c => c.parentId === '0');
                if (hasChildren) {
                    showStatusMessage("Root 節點無法刪除，請先移除所有與其直接相連的線段。", 3000);
                    return;
                }
                // 如果沒有孩子，則允許執行刪除邏輯
            }

            const jointToDelete = joints.find(j => j.id === jointIdToDelete);
            if (!jointToDelete) return;

            // 遞迴找出所有子孫節點 (Cascading delete)
            const descendantsToDelete = [];
            const findDescendants = (parentId) => {
                const children = joints.filter(j => j.parentId === parentId);
                for (const child of children) {
                    descendantsToDelete.push(child.id);
                    findDescendants(child.id);
                }
            };

            // 包含節點本身
            descendantsToDelete.push(jointIdToDelete);
            
            // 過濾掉所有要刪除的節點
            joints = joints.filter(j => !descendantsToDelete.includes(j.id));

            selectedJointId = null; // 清除選取端點狀態
            selectedBoneId = null; // 清除選取線段狀態
            
            // 呼叫清理邏輯：移除任何孤立的非 Root 節點
            cleanupIsolatedNodes(); 
            
            draw();
            showStatusMessage(`已刪除線段 (終點 ID: ${jointIdToDelete}) 及其 ${descendantsToDelete.length - 1} 個子節點。`, 3000);
            persistPoseToFirestore();
        };
        
        // 處理滑鼠/觸控開始
        const handleDown = (clientX, clientY) => {
            const rect = canvas.getBoundingClientRect();
            const x = clientX - rect.left;
            const y = clientY - rect.top;
            
            const joint = getJointAtPoint(x, y);
            const boneId = getBoneAtPoint(x, y);

            // 1. 處理新增模式 (CAD 畫線起點)
            if (isAddingJoint) {
                if (joint) {
                    // Option 1: 從現有關節開始畫線
                    startJointId = joint.id;
                    showStatusMessage(`從關節 ${joint.id} 開始畫線...`, 1500);
                } else {
                    // Option 2: 點擊空白處，創建一個新的根節點作為起點
                    const newRootJoint = {
                        id: (nextJointId++).toString(),
                        x: x, 
                        y: y,
                        parentId: null, // 設為根節點
                        name: 'RootJoint' + nextJointId
                    };
                    joints.push(newRootJoint);
                    startJointId = newRootJoint.id;
                    showStatusMessage('已在空白處建立新線段起點。', 1500);
                }

                selectedJointId = null; 
                selectedBoneId = null; 
            } else if (joint) {
                // 2. 處理拖曳/選取端點 (非 CAD 模式)
                isDragging = true;
                selectedJointId = joint.id;
                selectedBoneId = null; // 點擊端點優先，清除線段選取
                dragOffsetX = x - joint.x;
                dragOffsetY = y - joint.y;
                canvas.classList.add('grabbing');
            } else if (boneId) {
                // 3. 處理選取線段
                selectedBoneId = boneId;
                selectedJointId = null; // 清除選取端點
            } 
            else {
                // 4. 處理點擊空白處 (清空選取)
                isDragging = false;
                selectedJointId = null;
                selectedBoneId = null;
            }
            draw();
        };

        // 處理滑鼠/觸控移動
        const handleMove = (clientX, clientY) => {
            const rect = canvas.getBoundingClientRect();
            let x = clientX - rect.left;
            let y = clientY - rect.top;

            // 限制在畫布範圍內
            x = Math.max(0, Math.min(width, x));
            y = Math.max(0, Math.min(height, y));

            // --- CAD 模式：繪製暫時線段 ---
            if (isAddingJoint && startJointId !== null) {
                const snappedJoint = getJointAtPoint(x, y);
                if (snappedJoint && snappedJoint.id !== startJointId) {
                    tempJoint = { x: snappedJoint.x, y: snappedJoint.y };
                } else {
                    tempJoint = { x, y };
                }
                draw();
                return;
            }
            // --------------------------------

            if (!isDragging) return;

            const jointToMove = joints.find(j => j.id === selectedJointId);
            if (jointToMove) {
                jointToMove.x = x - dragOffsetX;
                jointToMove.y = y - dragOffsetY;
                draw();
            }
        };

        // 處理滑鼠/觸控結束
        const handleUp = () => {
            let shouldPersist = false;
            
            // 檢查是否是拖曳行為 (移動端點)
            if (isDragging) {
                shouldPersist = true;
            }

            // --- CAD 新增線段邏輯 ---
            if (isAddingJoint && startJointId !== null && tempJoint !== null) {
                const startJoint = joints.find(j => j.id === startJointId);
                const endX = tempJoint.x;
                const endY = tempJoint.y;
                let message = '取消畫線 (距離太短或起終點重疊)。'; // 預設消息

                // 只有在 startJoint 存在的情況下才嘗試創建
                if (startJoint) {
                    // FIX 1: 檢查是否為零長度線段
                    const distance = Math.sqrt((startJoint.x - endX) ** 2 + (startJoint.y - endY) ** 2);
                    
                    if (distance < 5) { // 設置一個小於 5 像素的容忍度，視為零長度
                        
                        // 如果是空白處創建的臨時根節點，則移除它
                        if (startJoint.parentId === null) { 
                            joints = joints.filter(j => j.id !== startJoint.id);
                        }
                    } else {
                        // 正常創建線段
                        const snapTarget = getJointAtPoint(endX, endY);
                        
                        let newJointX = endX;
                        let newJointY = endY;
                        let newParentId = startJoint.id; 

                        if (snapTarget && snapTarget.id !== startJointId) {
                            // 檢查循環依賴
                            let isCyclic = false;
                            let checkId = snapTarget.id;
                            while (checkId !== null) {
                                if (checkId === startJointId) {
                                    isCyclic = true; 
                                    break;
                                }
                                const parent = joints.find(j => j.id === checkId);
                                checkId = parent ? parent.parentId : null;
                            }

                            if (!isCyclic) {
                                newJointX = snapTarget.x;
                                newJointY = snapTarget.y;
                                message = `新增線段完成，終點已吸附至節點 ${snapTarget.id}。`;
                            } else {
                                message = '新增線段完成。 (避免循環連接)';
                            }
                        } else {
                            message = '新增線段完成。';
                        }

                        // Create the new joint
                        const newJoint = {
                            id: (nextJointId++).toString(),
                            x: newJointX,
                            y: newJointY,
                            parentId: newParentId, 
                            name: 'NewJoint' + nextJointId
                        };
                        joints.push(newJoint);
                        selectedJointId = newJoint.id;
                        shouldPersist = true; // 成功新增線段，需要儲存
                    }
                }
                
                // FIX 2: 退出 CAD 模式，無論畫線是否成功
                startJointId = null;
                tempJoint = null;
                isAddingJoint = false;
                document.getElementById('add-joint-btn').classList.remove('bg-red-600');
                document.getElementById('add-joint-btn').classList.add('bg-indigo-600');
                
                showStatusMessage(message, 2000);
                draw();

            } 
            // --- 結束 CAD 新增線段邏輯 ---
            
            // --- 拖曳模式下的吸附/重連邏輯 ---
            else if (isDragging) {
                isDragging = false;
                canvas.classList.remove('grabbing');
                
                const jointToMove = joints.find(j => j.id === selectedJointId);
                if (jointToMove) {
                    let message = `關節 ${selectedJointId} 動作已調整。`;

                    const SNAP_DISTANCE = 20; 
                    let snapTargetId = null;
                    let minDistance = Infinity;
                    
                    for (const targetJoint of joints) {
                        if (targetJoint.id === jointToMove.id) continue;
                        if (jointToMove.id === '0') continue; 
                        
                        const distance = Math.sqrt((jointToMove.x - targetJoint.x) ** 2 + (jointToMove.y - targetJoint.y) ** 2);
                        
                        if (distance < SNAP_DISTANCE && distance < minDistance) {
                            
                            // 檢查：不允許連接到自己的子孫節點 (防止迴圈/無限鏈)
                            let isDescendant = false;
                            let checkId = targetJoint.id;
                            
                            while (checkId !== null) {
                                if (checkId === jointToMove.id) {
                                    isDescendant = true; 
                                    break;
                                }
                                const parent = joints.find(j => j.id === checkId);
                                checkId = parent ? parent.parentId : null;
                            }
                            
                            if (!isDescendant) {
                                snapTargetId = targetJoint.id;
                                minDistance = distance;
                            }
                        }
                    }

                    if (snapTargetId !== null) {
                        // **修復**：如果吸附成功，將移動中的關節 (子節點) 的父節點 ID 更改為目標節點 ID
                        jointToMove.parentId = snapTargetId;
                        
                        // **修復**：將關節位置移動到吸附點，防止線段長度變為零而「消失」
                        const targetJoint = joints.find(j => j.id === snapTargetId);
                        if (targetJoint) {
                            jointToMove.x = targetJoint.x;
                            jointToMove.y = targetJoint.y;
                        }

                        message = `關節 ${selectedJointId} 已吸附並重連至節點 ${snapTargetId}。`;
                        
                    } else if (jointToMove.parentId !== null) {
                        message = `關節 ${selectedJointId} 動作已調整。`;
                    }
                    
                    showStatusMessage(message, 2000);
                    draw();
                }
            }

            // 確保每次主要操作後，都進行孤立點清理和持久化儲存
            cleanupIsolatedNodes(); 
            if (shouldPersist) {
                persistPoseToFirestore();
            }
        };

        // 滑鼠事件
        canvas.addEventListener('mousedown', (e) => handleDown(e.clientX, e.clientY));
        document.addEventListener('mousemove', (e) => handleMove(e.clientX, e.clientY));
        document.addEventListener('mouseup', handleUp);

        // 觸控事件
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            handleDown(touch.clientX, touch.clientY);
        });
        document.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            handleMove(touch.clientX, touch.clientY);
        });
        document.addEventListener('touchend', handleUp);
        document.addEventListener('touchcancel', handleUp);


        // --- 6. UI 按鈕事件和狀態訊息 ---
        
        // 新增：刪除選取的線段
        const deleteSelectedBone = () => {
            if (selectedBoneId !== null) {
                // 刪除線段，即刪除該線段的子節點
                deleteJoint(selectedBoneId);
            } else if (selectedJointId !== null) {
                // 如果沒有選中線段，但選中了端點，則刪除端點
                 deleteJoint(selectedJointId);
            }
             else {
                showStatusMessage("請先點擊畫布上的線段或端點來選取它。", 2000);
            }
        };

        const addJointBtn = document.getElementById('add-joint-btn');
        addJointBtn.addEventListener('click', () => {
            isAddingJoint = !isAddingJoint;
            
            // 清理模式狀態
            startJointId = null; 
            tempJoint = null;
            selectedBoneId = null;
            
            if (isAddingJoint) {
                addJointBtn.classList.remove('bg-indigo-600');
                addJointBtn.classList.add('bg-red-600');
                showStatusMessage('已進入「新增線段」模式：點擊起點並拖曳 (可點擊空白處創建新起點)。', 3000);
            } else {
                addJointBtn.classList.remove('bg-red-600');
                addJointBtn.classList.add('bg-indigo-600');
                showStatusMessage('已退出「新增線段」模式。', 1500);
            }
            // 取消選取，避免使用者意外刪除
            selectedJointId = null;
            draw();
        });

        const deleteJointBtn = document.getElementById('delete-joint-btn');
        deleteJointBtn.addEventListener('click', deleteSelectedBone); // 綁定到刪除線段邏輯

        // 鍵盤事件：處理刪除鍵
        document.addEventListener('keydown', (e) => {
            // 檢查是否是 Delete (Del) 或 Backspace 鍵
            if (e.key === 'Delete' || e.key === 'Backspace') {
                e.preventDefault(); // 阻止瀏覽器後退
                deleteSelectedBone();
            }
        });

        // --- 底圖控制 UI 元素 (保持不變) ---
        const toggleBgBtn = document.getElementById('toggle-bg-btn');
        const scaleSlider = document.getElementById('bg-scale-slider');
        const offsetXSlider = document.getElementById('bg-offset-x-slider');
        const offsetYSlider = document.getElementById('bg-offset-y-slider');
        const scaleValueSpan = document.getElementById('scale-value');
        const offsetXValueSpan = document.getElementById('offset-x-value');
        const offsetYValueSpan = document.getElementById('offset-y-value');
        const bgControlsElements = [toggleBgBtn, scaleSlider, offsetXSlider, offsetYSlider];

        // 啟用/禁用底圖控制項
        const setBgControlsEnabled = (enabled) => {
            bgControlsElements.forEach(el => el.disabled = !enabled);
            toggleBgBtn.textContent = isBackgroundVisible ? '隱藏底圖' : '顯示底圖';
        };

        // 綁定底圖控制事件
        toggleBgBtn.addEventListener('click', () => {
            if (isBackgroundLoaded) {
                isBackgroundVisible = !isBackgroundVisible;
                toggleBgBtn.textContent = isBackgroundVisible ? '隱藏底圖' : '顯示底圖';
                draw();
            }
        });

        scaleSlider.addEventListener('input', (e) => {
            bgScale = parseFloat(e.target.value);
            scaleValueSpan.textContent = bgScale.toFixed(2);
            draw();
        });

        offsetXSlider.addEventListener('input', (e) => {
            bgOffsetX = parseInt(e.target.value);
            offsetXValueSpan.textContent = bgOffsetX;
            draw();
        });

        offsetYSlider.addEventListener('input', (e) => {
            bgOffsetY = parseInt(e.target.value);
            offsetYValueSpan.textContent = bgOffsetY;
            draw();
        });


        const statusEl = document.getElementById('status-message');
        let statusTimeout;
        const showStatusMessage = (message, duration = 2000) => {
            clearTimeout(statusTimeout);
            statusEl.textContent = message;
            statusEl.classList.remove('opacity-0');
            statusTimeout = setTimeout(() => {
                statusEl.classList.add('opacity-0');
            }, duration);
        };

        // --- 7. Firestore 儲存/載入邏輯 (Persistence) ---

        // 僅將資料儲存到 Firestore (無下載)
        const persistPoseToFirestore = async () => {
            if (!isAuthReady || !db || !userId) {
                console.warn("Firestore 尚未就緒或用戶未登入。無法儲存。");
                return;
            }

            const dataToSave = {
                joints: JSON.stringify(joints), // 將複雜數組序列化
                nextJointId: nextJointId,
                bgScale: bgScale,
                bgOffsetX: bgOffsetX,
                bgOffsetY: bgOffsetY,
                timestamp: Date.now()
            };

            try {
                const docRef = doc(db, skeletonDocPath(userId));
                await setDoc(docRef, dataToSave);
            } catch (e) {
                console.error("儲存文件錯誤: ", e);
            }
        };

        // 載入姿勢 (從雲端)
        const loadPoseFromFirestore = async () => {
            if (!isAuthReady || !db || !userId) {
                console.warn("Firestore 尚未就緒或用戶未登入。無法載入。");
                showStatusMessage("警告：無法載入。Firebase 未初始化或用戶未登入。", 3000);
                return;
            }

            try {
                const docRef = doc(db, skeletonDocPath(userId));
                const docSnap = await getDoc(docRef);

                if (docSnap.exists()) {
                    const data = docSnap.data();
                    // 載入 joints
                    const loadedJoints = JSON.parse(data.joints || '[]'); 
                    joints = loadedJoints.map(j => ({
                        ...j,
                        id: j.id.toString(),
                        parentId: j.parentId !== null ? j.parentId.toString() : null 
                    }));
                    nextJointId = data.nextJointId || joints.reduce((max, joint) => Math.max(max, parseInt(joint.id)), -1) + 1;
                    
                    // 載入背景圖參數 (不再嘗試載入圖片本身)
                    const savedScale = data.bgScale !== undefined ? data.bgScale : null;

                    // 重設圖片相關狀態
                    isBackgroundLoaded = false;
                    isBackgroundVisible = false;
                    bgImage.src = '';
                    
                    if (savedScale !== null) {
                        // 載入參數
                        bgScale = savedScale;
                        bgOffsetX = data.bgOffsetX !== undefined ? data.bgOffsetX : 0;
                        bgOffsetY = data.bgOffsetY !== undefined ? data.bgOffsetY : 0;
                        
                        // 如果當前會話已經載入圖片 (檢查 bgImage.src 是否有 data URL)
                        if (bgImage.src.startsWith('data:')) {
                            isBackgroundLoaded = true;
                            isBackgroundVisible = true;
                            showStatusMessage("姿勢及底圖參數已載入。圖片已在畫布上顯示。", 2000);
                        } else {
                            // 圖片已從伺服器遺失
                            isBackgroundLoaded = false;
                            isBackgroundVisible = false;
                            showStatusMessage("姿勢及底圖參數已載入。**圖片已遺失 (檔案過大無法儲存)**，請重新上傳。", 4000);
                        }

                        // 更新 UI 控制項
                        scaleSlider.value = bgScale;
                        offsetXSlider.value = bgOffsetX;
                        offsetYSlider.value = bgOffsetY;
                        scaleValueSpan.textContent = bgScale.toFixed(2);
                        offsetXValueSpan.textContent = bgOffsetX;
                        offsetYValueSpan.textContent = bgOffsetY;
                        setBgControlsEnabled(true);
                        draw();

                    } else {
                        // 沒有底圖參數的情況
                        isBackgroundLoaded = false;
                        isBackgroundVisible = false;
                        setBgControlsEnabled(false);
                        showStatusMessage("姿勢已成功載入！(無底圖參數)", 2000);
                        draw();
                    }


                } else {
                    showStatusMessage("找不到儲存的姿勢。使用預設骨架。", 2000);
                    // 如果沒有資料，重新使用初始骨架
                    joints = initialSkeleton.map(j => ({ ...j, id: j.id.toString(), parentId: j.parentId !== null ? j.parentId.toString() : null }));
                    nextJointId = initialSkeleton.reduce((max, joint) => Math.max(max, joint.id), -1) + 1;
                    isBackgroundLoaded = false;
                    setBgControlsEnabled(false);
                    draw();
                }
            } catch (e) {
                console.error("載入文件錯誤: ", e);
                showStatusMessage("錯誤：載入失敗。", 3000);
            }
        };

        // --- 8. 儲存與下載邏輯 (新功能) ---
        
        // 執行本地檔案下載
        const downloadJointsData = () => {
            const data = {
                joints: joints,
                nextJointId: nextJointId,
                bgScale: bgScale,
                bgOffsetX: bgOffsetX,
                bgOffsetY: bgOffsetY,
                info: "此數據為骨架節點和參數，圖片資料因檔案過大限制未儲存。",
            };
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'pose_editor_skeleton.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        };

        // 綁定「儲存姿勢」按鈕：先雲端儲存，再本地下載
        document.getElementById('save-btn').addEventListener('click', async () => {
            // 1. 儲存到 Firestore (Persistence)
            await persistPoseToFirestore(); 
            
            // 2. 觸發下載 (User Request)
            downloadJointsData();
            showStatusMessage("已儲存到雲端並下載到本機。", 2000);
        });
        
        document.getElementById('load-btn').addEventListener('click', loadPoseFromFirestore);


        // --- 9. AI 捕捉邏輯 (保持不變) ---
        const aiCaptureBtn = document.getElementById('ai-capture-btn');
        const imageInput = document.getElementById('image-input');
        const AI_MODEL_NAME = "gemini-2.5-flash-preview-09-2025";
        const API_KEY = ""; // Canvas 將自動提供 API Key

        // 輔助函式：將檔案轉換為 Base64 字串
        const fileToBase64 = (file) => {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => {
                    // 保留 'data:image/jpeg;base64,' 等前綴
                    resolve(reader.result); 
                };
                reader.onerror = error => reject(error);
                reader.readAsDataURL(file);
            });
        };

        // 結構化輸出的 JSON Schema
        const POSE_SCHEMA = {
            type: "ARRAY",
            items: {
                type: "OBJECT",
                properties: {
                    "id": { "type": "STRING", "description": "Unique joint ID." },
                    "x_norm": { "type": "NUMBER", "description": "Normalized X coordinate (0 to 1000)." },
                    "y_norm": { "type": "NUMBER", "description": "Normalized Y coordinate (0 to 1000)." },
                    "parentId": { "type": "STRING", "description": "ID of the parent joint, or null for the root joint." },
                    "name": { "type": "STRING", "description": "Name of the joint (e.g., Head, LShoulder). Use 'Head' for the head." }
                },
                required: ["id", "x_norm", "y_norm", "parentId", "name"]
            }
        };

        // 呼叫 Gemini Vision API 進行骨骼捕捉
        const fetchAICapture = async (base64Data, mimeType) => {
            showStatusMessage("AI 正在分析影像，捕捉骨骼點...", 60000);
            aiCaptureBtn.disabled = true;

            // 提取純淨 Base64 數據（不含前綴）
            const cleanBase64Data = base64Data.split(',')[1]; 

            const userPrompt = `請分析這張圖片中的人物姿勢。識別出主要的關節點 (例如：頭, 頸, 肩膀, 手肘, 手腕, 骨盆, 臀部, 膝蓋, 腳踝)。將所有關節的座標正規化到 0 到 1000 的範圍內 (x_norm 和 y_norm)。
            請為每個關節指定一個獨一無二的 ID，從 0 開始，並且必須使用字串格式。
            請根據人體結構建立一個邏輯上的父子關係 (parentId)，Root 關節的 parentId 為 null。請確保連線符合人體工學，例如：手肘連向肩膀，膝蓋連向臀部。
            請以嚴格的 JSON 陣列格式輸出結果，不要包含任何額外的文字或 Markdown 標記。`;

            const payload = {
                contents: [{
                    parts: [
                        { text: userPrompt },
                        {
                            inlineData: {
                                mimeType: mimeType,
                                data: cleanBase64Data
                            }
                        }
                    ]
                }],
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: POSE_SCHEMA
                },
            };

            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${AI_MODEL_NAME}:generateContent?key=${API_KEY}`;
            
            for (let i = 0; i < 3; i++) { // 嘗試 3 次，使用指數退避
                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        throw new Error(`API 錯誤: ${response.status} ${response.statusText}`);
                    }

                    const result = await response.json();
                    
                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        
                        const jsonText = result.candidates[0].content.parts[0].text;
                        return JSON.parse(jsonText);
                    } else {
                        throw new Error("API 回應結構不正確或內容遺失。");
                    }

                } catch (error) {
                    // 不在控制台記錄重試錯誤
                    if (i < 2) {
                        const delay = Math.pow(2, i) * 1000;
                        await new Promise(resolve => setTimeout(resolve, delay));
                    } else {
                        throw new Error(`AI 骨骼捕捉失敗: ${error.message}`);
                    }
                }
            }
        };

        // 處理 AI 捕捉結果並更新畫布
        const applyAIPose = (aiJoints, base64Src) => {
            if (!aiJoints || aiJoints.length === 0) {
                showStatusMessage("AI 未能捕捉到關節點。", 3000);
                return;
            }

            // 1. 找到最大的 ID，更新 nextJointId
            nextJointId = aiJoints.reduce((max, joint) => Math.max(max, parseInt(joint.id) || 0), -1) + 1;
            
            // 2. 將正規化座標 (0-1000) 轉換為畫布座標 (width/height)
            joints = aiJoints.map(j => ({
                ...j,
                id: j.id.toString(),
                x: (j.x_norm / 1000) * width,
                y: (j.y_norm / 1000) * height,
                parentId: j.parentId !== null ? j.parentId.toString() : null,
                // 確保 Head 關節名稱正確，以便繪製大圓形頭部
                name: j.name && j.name.toLowerCase().includes('head') ? 'Head' : (j.name || 'Joint')
            }));
            
            selectedJointId = null;

            // --- 3. 處理背景圖 ---
            isBackgroundLoaded = false;
            bgImage.onload = () => {
                isBackgroundLoaded = true;
                isBackgroundVisible = true; // 捕捉後預設顯示
                
                // 重置底圖參數為預設值
                bgScale = 1.0;
                bgOffsetX = 0;
                bgOffsetY = 0;
                scaleSlider.value = bgScale;
                offsetXSlider.value = bgOffsetX;
                offsetYSlider.value = bgOffsetY;
                scaleValueSpan.textContent = bgScale.toFixed(2);
                offsetXValueSpan.textContent = bgOffsetX;
                offsetYValueSpan.textContent = bgOffsetY;

                setBgControlsEnabled(true);
                draw();
            };
            bgImage.src = base64Src; // 載入底圖

            showStatusMessage(`AI 捕捉完成，已載入 ${joints.length} 個關節！`, 3000);
            persistPoseToFirestore();
        };

        const handleAICapture = async () => {
            const file = imageInput.files[0];
            if (!file) {
                showStatusMessage("請先選擇一張圖片。", 2000);
                return;
            }

            try {
                // 1. 讀取 Base64 (包含前綴)
                const base64Data = await fileToBase64(file);
                
                // 2. 呼叫 AI API 獲取結構化 JSON
                // 傳遞 mimeType 以便 API 正確處理
                const aiJoints = await fetchAICapture(base64Data, file.type);
                
                // 3. 處理並應用姿勢和底圖
                applyAIPose(aiJoints, base64Data);

            } catch (error) {
                console.error("AI 捕捉流程失敗:", error);
                showStatusMessage(`AI 捕捉失敗: ${error.message}`, 5000);
            } finally {
                aiCaptureBtn.disabled = !imageInput.files.length;
            }
        };

        // UI 啟用/禁用邏輯
        imageInput.addEventListener('change', () => {
            aiCaptureBtn.disabled = !imageInput.files.length;
        });
        aiCaptureBtn.addEventListener('click', handleAICapture);


        // --- 10. 啟動應用程式 ---
        const initApp = async () => {
            // 等待認證完成
            await authPromise;
            
            // 首次載入嘗試載入資料，如果失敗則使用預設骨架
            loadPoseFromFirestore(); 
            resizeCanvas();
            // 初始化時檢查是否有圖片可供捕捉
            aiCaptureBtn.disabled = !imageInput.files.length;
            setBgControlsEnabled(isBackgroundLoaded); // 預設禁用
        };

        window.onload = initApp;

    </script>
</body>
</html>