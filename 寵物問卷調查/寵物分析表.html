<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ¨ç´åˆ†æå„€è¡¨æ¿</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0/dist/chartjs-plugin-datalabels.min.js"></script>
    <!-- Font Awesome for swap icon/settings icon -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <!-- ** å¼•å…¥ D3.js å’Œ D3-Sankey (æ–°å¢) ** -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-sankey@0.12.3/dist/d3-sankey.min.js"></script>
    <!-- ** æˆªåœ–åŠŸèƒ½ ** -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        body { font-family: 'Inter', 'Noto Sans TC', sans-serif; }
        .chart-container {
            position: relative;
            width: 100%;
            transition: height 0.3s ease-in-out;
            min-height: 500px;
        }
        /* -- é‚„åŸï¼šå–®ä¸€æ¬„ä½åœ–è¡¨å®¹å™¨ (é•·æ¢åœ–) -- */
        .small-chart-container {
            position: relative;
            width: 100%;
            /* ä¿®æ­£ï¼šç§»é™¤å›ºå®šé«˜åº¦ï¼Œäº¤çµ¦ JS å‹•æ…‹è¨ˆç®— */
        }
        
        /* --- ç¯©é¸å™¨æ¨£å¼ --- */
        .filter-dropdown summary {
            cursor: pointer; padding: 0.5rem 1rem; border: 1px solid #d1d5db;
            border-radius: 0.375rem; background-color: white;
            transition: background-color 0.2s, border-color 0.2s;
            overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
        }
        .filter-dropdown summary:hover { background-color: #f9fafb; }
        .filter-dropdown[open] summary { border-bottom-left-radius: 0; border-bottom-right-radius: 0; }
        .filter-dropdown .filter-panel {
            max-height: 250px; overflow-y: auto; border: 1px solid #d1d5db; border-top: none;
            padding: 0.75rem; background-color: white; z-index: 10; position: absolute;
            width: 100%; border-bottom-left-radius: 0.375rem; border-bottom-right-radius: 0.375rem;
        }
        .filter-dropdown { position: relative; }
        
        /* å¤šé‡é¸å–æ¡†æ¨£å¼ */
        .multi-select-box {
            border: 1px solid #d1d5db; border-radius: 0.375rem;
            padding: 0.5rem; max-height: 150px; overflow-y: auto;
            background-color: white;
        }
        .multi-select-box label { display: block; margin-bottom: 0.25rem; }
        
        .question-annotation {
            background-color: #f3f4f6;
            border: 1px solid #e5e7eb;
            border-radius: 0.375rem;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            font-size: 0.875rem;
            color: #4b5563;
            min-height: 40px;
            font-style: italic;
        }
        .filter-active {
            background-color: #fefce8 !important; /* bg-yellow-50 */
            border-color: #fde047 !important; /* border-yellow-300 */
            font-weight: 600; /* semibold */
        }
        
        /* --- æ¨™è¨˜æ¨£å¼ (ç®­é ­/åˆ†ä½æ•¸/å¹³å‡) --- */
        #markerContainer {
             position: absolute; top: 0; left: 0; width: 100%; height: 100%;
             pointer-events: none; overflow: hidden;
        }
        /* 1. ä¸Šæ–¹åœ–ä¾‹ç®­é ­ (è—è‰²) */
        .chart-arrow {
            position: absolute; display: none; pointer-events: none; z-index: 10;
            width: 0; height: 0;
            border-left: 6px solid transparent; border-right: 6px solid transparent; 
            border-top: 8px solid #2563eb; /* blue-600 */
            transform: translateX(-50%);
            filter: drop-shadow(0 1px 1px rgba(0,0,0,0.2));
        }
        /* 2. ä¸‹æ–¹åˆ†ä½æ•¸æ¨™è¨˜ (ç´…è‰²/ç²‰è‰²) */
        .quantile-marker {
            position: absolute; display: none; pointer-events: none; z-index: 10;
            width: 0; height: 0;
            border-left: 6px solid transparent; border-right: 6px solid transparent;
            border-bottom: 8px solid #dc2626; /* red-600 */
            transform: translateX(-50%);
        }
        .quantile-marker-q2 { /* ä¸­ä½æ•¸ Q2 */
            border-left-width: 8px; border-right-width: 8px;
            border-bottom-width: 10px;
            border-bottom-color: #f472b6; /* pink-400 */
        }
         /* 3. å¹³å‡æ•¸æ¨™ç±¤ (é•·æ¢åœ–æœ«ç«¯) */
        .average-label {
            position: absolute; display: none; pointer-events: none; z-index: 10;
            background-color: rgba(0, 0, 0, 0.0); /* é€æ˜èƒŒæ™¯ */
            color: white; /* ç™½è‰²æ–‡å­— */
            padding: 2px 5px;
            font-size: 0.8rem;
            font-weight: bold;
            transform: translate(-95%, -50%); /* å¾€å·¦æ¨ 95%ï¼Œå‚ç›´ç½®ä¸­ */
            text-shadow: 0 1px 2px rgba(0,0,0,0.5); /* æ–‡å­—é™°å½± */
        }
        /* --- çµæŸæ¨™è¨˜æ¨£å¼ --- */

        /* åœ–ä¾‹æ¨£å¼ */
        #arrowSelectContainer label { font-size: 0.875rem; font-weight: 600; color: #4b5563; }
        #arrowSelect { margin-left: 0.5rem; padding: 0.25rem 0.5rem; border: 1px solid #d1d5db; border-radius: 0.375rem; font-size: 0.875rem; }
        .legend-item { cursor: pointer; transition: opacity 0.2s; }
        .legend-item-hidden { opacity: 0.5; text-decoration: line-through; }
        
        /* -- æ”¶æŠ˜å€å¡Šæ¨£å¼ -- */
        details summary {
            cursor: pointer;
            font-size: 1.25rem;
            font-weight: 700;
            color: #1e3a8a; /* text-blue-900 */
            background-color: #eef2ff; /* bg-indigo-50 */
            padding: 0.75rem 1.25rem;
            border-radius: 0.5rem;
            transition: background-color 0.2s;
        }
        details[open] summary {
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
        }
        details summary:hover {
            background-color: #e0e7ff; /* bg-indigo-100 */
        }
        details > div {
            border: 1px solid #e0e7ff;
            border-top: none;
            padding: 1.5rem;
            border-bottom-left-radius: 0.5rem;
            border-bottom-right-radius: 0.5rem;
        }

        /* --- è¨­å®š Modal æ¨£å¼ --- */
        .modal {
            display: none; position: fixed; z-index: 50; left: 0; top: 0;
            width: 100%; height: 100%; overflow: auto;
            background-color: rgba(0,0,0,0.4); 
        }
        .modal-content {
            background-color: #fefefe; margin: 10% auto; padding: 20px;
            border: 1px solid #888; width: 90%; max-width: 500px;
            border-radius: 0.5rem; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
        }
        .close-button {
            color: #aaa; float: right; font-size: 28px; font-weight: bold;
            line-height: 1; cursor: pointer; transition: color 0.2s;
        }
        .close-button:hover, .close-button:focus { color: #000; text-decoration: none; }

        /* --- Sankey å°ˆç”¨æ¨£å¼ (å„ªåŒ–) --- */
        #sankeyChart svg { 
            width: 100%; 
            height: 100%; 
            max-height: 600px; /* é™åˆ¶æ¡‘åŸºåœ–æœ€å¤§é«˜åº¦ */
        }
        .sankey-link {
            fill: none;
            stroke-opacity: 0.4; /* èª¿æ•´é€æ˜åº¦ï¼Œè®“æµå‹•æ„Ÿæ›´å¼· */
            transition: stroke-opacity 0.2s;
        }
        .sankey-link:hover {
            stroke-opacity: 0.7; /* æ»‘é¼ æ‡¸åœæ™‚æ›´æ˜é¡¯ */
        }
        .sankey-node rect {
            fill-opacity: 1; /* ç¯€é»å¯¦è‰² */
            shape-rendering: crispEdges;
            cursor: pointer;
            border-radius: 4px; /* å¢åŠ åœ“è§’ */
            transition: fill-opacity 0.2s;
            /* ä¿®æ­£ï¼šç§»é™¤ç¯€é»æ¡†ç·š */
            stroke-width: 0; 
        }
        /* ä¿®æ­£ Sankey æ¨™ç±¤ï¼Œè®“åœ–ä¾‹å–ä»£åŸæœ¬çš„æ¨™ç±¤ */
        .sankey-node text {
            display: none; /* éš±è— D3 å…§å»ºçš„æ¨™ç±¤ */
        }
        /* æ–°å¢ Sankey åœ–ä¾‹æ¨£å¼ */
        .sankey-legend-item {
            font-size: 0.875rem;
            color: #4b5563;
            margin-bottom: 0.25rem;
            word-break: break-word;
        }

        /* --- å–®æ¬„åˆ†ææ’ç‰ˆä¿®æ­£æ¨£å¼ --- */
        .small-chart-header {
             /* ç¢ºä¿æ¨™é¡Œå’Œåœ–ä¾‹å°é½Š */
             min-height: 20px;
             line-height: 1.2;
        }

    </style>
</head>
<body class="bg-gray-100 text-gray-800">
    
    <!-- é ‚éƒ¨è¨­å®šæŒ‰éˆ• -->
    <div class="fixed top-4 right-4 z-40">
        <!-- ** ä¿®æ­£ï¼šä½¿ç”¨ w-10 h-10 ç¢ºä¿æ­£åœ“å½¢ ** -->
        <button id="settingsButton" class="w-10 h-10 flex justify-center items-center bg-white rounded-full shadow-lg text-blue-600 hover:bg-gray-50 transition" title="è¨­å®š"><i class="fas fa-cog text-xl"></i></button>
    </div>

    <!-- è¨­å®š Modal è¦–çª— -->
    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <span class="close-button" id="closeSettingsModal">&times;</span>
            <h2 class="text-2xl font-bold text-blue-800 mb-6">åœ–è¡¨å¤–è§€è¨­å®š</h2>

            <div class="space-y-6">
                <!-- 1. æ•¸å€¼æ¨™ç±¤å­—é«”å¤§å° -->
                <div>
                    <label for="datalabelsSize" class="block text-lg font-medium text-gray-700 mb-2">
                        æ•¸å€¼æ¨™ç±¤å­—é«”å¤§å° (<span id="datalabelsSizeValue">13</span> px)
                    </label>
                    <input type="range" id="datalabelsSize" min="8" max="16" value="13" step="1" 
                           class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg">
                    <p class="text-sm text-gray-500 mt-1">æ§åˆ¶é•·æ¢åœ–ä¸Šç™¾åˆ†æ¯”/ç­†æ•¸æ–‡å­—çš„å¤§å°ã€‚</p>
                </div>
                
                <!-- 2. BAR çš„ç²—åº¦ (Category Percentage / Bar Percentage) -->
                <div>
                    <label for="barThickness" class="block text-lg font-medium text-gray-700 mb-2">
                        é•·æ¢åœ–ç²—åº¦ (Bar Thickness: <span id="barThicknessValue">0.5</span>)
                    </label>
                    <!-- ** ä¿®æ­£ï¼šé è¨­å€¼æ”¹ç‚º 0.5ï¼Œstep æ”¹ç‚º 0.05 ** -->
                    <input type="range" id="barThickness" min="0.3" max="1.0" value="0.5" step="0.05" 
                           class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg">
                    <p class="text-sm text-gray-500 mt-1">1.0 ç‚ºç·Šå¯†æ’åˆ—ï¼Œ0.3 ç‚ºæœ€å¤§é–“è·ã€‚</p>
                </div>
            </div>
        </div>
    </div>


    <div class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-blue-800">æ¨ç´åˆ†æå„€è¡¨æ¿</h1>
            <p class="text-gray-600 mt-2">å‹•æ…‹é•·æ¢åœ–åˆ†æ</p>
        </header>

        <!-- è¨­å®šæ­¥é©Ÿ -->
        <div id="setupInstructions" class="max-w-4xl mx-auto mb-8 p-6 bg-blue-50 border-2 border-blue-200 rounded-lg">
            <h2 class="text-xl font-bold text-blue-800 mb-4">ğŸ“‹ è¨­å®šç‹€æ…‹</h2>
            <p class="text-gray-700">è³‡æ–™å°‡æ–¼é é¢é–‹å•Ÿæ™‚è‡ªå‹•è¼‰å…¥ã€‚å¦‚éœ€è®Šæ›´è³‡æ–™ä¾†æºï¼Œè«‹ä¿®æ”¹ç¨‹å¼ç¢¼å…§ <code>DEFAULT_SCRIPT_URL</code> è®Šæ•¸ã€‚</p>
        </div>

        <!-- è¼‰å…¥ä¸­ -->
        <!-- ä¿®æ­£ 2.1: åˆå§‹æ™‚ç§»é™¤ hiddenï¼Œè®“è¼‰å…¥ç•«é¢é¡¯ç¤º -->
        <div id="loading" class="text-center p-8"> 
            <div class="inline-block animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600"></div>
            <p class="mt-4 text-lg" id="loadingMessage">æ­£åœ¨è¼‰å…¥è³‡æ–™ï¼Œè«‹ç¨å€™...</p>
            <!-- ä¿®æ­£ 2.3: æ–°å¢éŒ¯èª¤è³‡è¨Šé¡¯ç¤ºå€å¡Š (åˆå§‹éš±è—) -->
            <div id="debugInfoContainer" class="hidden mt-4 max-w-xl mx-auto">
                <h3 class="font-bold text-gray-700">è¼‰å…¥æ—¥èªŒ:</h3>
                <div id="debugInfo" class="mt-2 text-sm text-red-600 text-left bg-white p-4 rounded shadow border border-gray-200"></div>
            </div>
        </div>

        <!-- å„€è¡¨æ¿ -->
        <main id="dashboard" class="hidden lg:grid lg:grid-cols-3 lg:gap-6">
            <div class="lg:col-span-2 space-y-6">
                
                <!-- 
                  =================================
                  å€å¡Š 1: æ¨ç´åˆ†æ (äº¤å‰æ¯”è¼ƒ)
                  =================================
                -->
                <details id="pivotSection" open>
                    <!-- ä¿®æ­£åç¨± -->
                    <summary>æ¨ç´åˆ†æ</summary>
                    <div class="space-y-6">
                        <div class="p-4 bg-white rounded-lg shadow-md">
                            <div class="flex flex-col md:flex-row items-start md:items-center gap-4 mb-4">
                                <div class="w-full md:flex-1">
                                    <div id="yAxisQuestion" class="question-annotation">è«‹é¸æ“‡ã€Œåˆ—ã€æ¬„ä½...</div>
                                    <label for="yAxisSelect" class="block text-sm font-medium text-gray-700">æ¨ç´åˆ†æã€Œåˆ—ã€</label>
                                    <select id="yAxisSelect" class="mt-1 block w-full py-2 px-3 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm"></select>
                                </div>
                                <div class="w-full md:w-auto flex justify-center">
                                    <button id="swapAxesButton" class="p-2 mt-0 md:mt-10 bg-gray-200 text-gray-700 rounded-full hover:bg-gray-300 transition" title="äº¤æ›ã€Œåˆ—ã€èˆ‡ã€Œæ¬„ã€"><i class="fas fa-exchange-alt"></i></button>
                                </div>
                                <div class="w-full md:flex-1">
                                    <div id="colorByQuestion" class="question-annotation">è«‹é¸æ“‡ã€Œæ¬„ã€æ¬„ä½...</div>
                                    <label for="colorBySelectContainer" class="block text-sm font-medium text-gray-700">æ¨ç´åˆ†æã€Œæ¬„ã€</label>
                                    <!-- ã€Œæ¬„ã€çš„å®¹å™¨ (å–®é¸) -->
                                    <div id="colorBySelectContainer" class="mt-1">
                                        <select id="colorBySelect" class="block w-full py-2 px-3 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                                            <option value="none">ä¸åˆ†çµ„ (å–®ä¸€é¡è‰²)</option>
                                        </select>
                                    </div>
                                </div>
                            </div>
                            <div class="mt-4">
                                <label for="valueSelect" class="block text-sm font-medium text-gray-700">æ¨ç´åˆ†æã€Œå€¼ã€ (Value)</label>
                                <select id="valueSelect" class="mt-1 block w-full py-2 px-3 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                                    <option value="count" selected>ç­†æ•¸ (COUNTA)</option>
                                    <option value="percent">å„åˆ—ä½”æ¯” (%)</option>
                                </select>
                                <!-- ** ä¿®æ­£ 2ï¼šç§»é™¤å…±ç”¨æç¤º ** -->
                                <!-- <p class="mt-1 text-xs text-gray-500">æ­¤é¸é …æœƒåŒæ™‚å¥—ç”¨åˆ°ä¸‹æ–¹çš„ã€Œå–®ä¸€æ¬„ä½åˆ†æã€ã€‚</p> -->
                            </div>
                        </div>
                        <div class="bg-white p-4 md:p-6 rounded-lg shadow-lg">
                            <div id="chartHeader" class="flex justify-between items-start mb-2">
                                <h3 id="yAxisChartTitle" class="text-lg font-bold text-gray-800"></h3>
                                <div id="customLegendContainer" class="text-right space-y-2">
                                    <h3 id="cAxisChartTitle" class="text-lg font-bold text-gray-800"></h3>
                                    <div id="customLegend" class="flex flex-wrap gap-x-4 gap-y-1 justify-end"></div>
                                    <div id="arrowSelectContainer" class="text-right mt-2 hidden">
                                        <label for="arrowSelect">ç®­é ­:</label>
                                        <select id="arrowSelect"><option value="">è«‹é¸æ“‡</option></select>
                                    </div>
                                </div>
                            </div>
                            <div class="chart-container">
                                <canvas id="mainChart"></canvas>
                                <!-- å®¹å™¨ï¼šæ”¾ç½®æ‰€æœ‰æ¨™è¨˜ (ç®­é ­/åˆ†ä½æ•¸/å¹³å‡) -->
                                <div id="markerContainer"></div>
                            </div>
                        </div>
                    </div>
                </details>
                
                <!-- 
                  =================================
                  å€å¡Š 3: æ¡‘åŸºåœ– (Sankey Diagram)
                  =================================
                -->
                <details id="sankeySection" open>
                    <!-- ä¿®æ­£åç¨± -->
                    <summary>æ¡‘åŸºåˆ†æ</summary>
                    <div class="space-y-6">
                        <div class="p-4 bg-white rounded-lg shadow-md">
                            <div class="flex flex-col md:flex-row items-start md:items-center gap-4 mb-4">
                                <div class="w-full md:flex-1">
                                    <label for="sankeySourceSelect" class="block text-sm font-medium text-gray-700">æµå‹•ã€Œä¾†æºã€ (Source)</label>
                                    <select id="sankeySourceSelect" class="mt-1 block w-full py-2 px-3 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm"></select>
                                </div>
                                <!-- æ–°å¢æ¡‘åŸºåœ–äº¤æ›æŒ‰éˆ• -->
                                <div class="w-full md:w-auto flex justify-center">
                                    <button id="swapSankeyAxesButton" class="p-2 mt-0 md:mt-10 bg-gray-200 text-gray-700 rounded-full hover:bg-gray-300 transition" title="äº¤æ›ã€Œä¾†æºã€èˆ‡ã€Œç›®æ¨™ã€"><i class="fas fa-exchange-alt"></i></button>
                                </div>
                                <div class="w-full md:flex-1">
                                    <label for="sankeyTargetSelect" class="block text-sm font-medium text-gray-700">æµå‹•ã€Œç›®æ¨™ã€ (Target)</label>
                                    <select id="sankeyTargetSelect" class="mt-1 block w-full py-2 px-3 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm"></select>
                                </div>
                            </div>
                            <div class="mt-4">
                                <label for="sankeyMinThreshold" class="block text-sm font-medium text-gray-700">æœ€å°ç­†æ•¸é–€æª» (Min Count: <span id="sankeyMinThresholdValue">3</span>)</label>
                                <input type="range" id="sankeyMinThreshold" min="1" max="10" value="3" step="1" 
                                    class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg">
                                <p class="text-xs text-gray-500 mt-1">ä½æ–¼æ­¤é–€æª»çš„é€£ç·šå°‡è¢«å¿½ç•¥ï¼Œä»¥ç°¡åŒ–åœ–è¡¨ã€‚</p>
                            </div>
                        </div>

                        <div class="bg-white p-4 md:p-6 rounded-lg shadow-lg">
                            <h3 class="text-lg font-bold text-gray-800 mb-4">è³‡æ–™æµå‹•è·¯å¾‘</h3>
                            <!-- æ¡‘åŸºåœ–ä¾‹ -->
                            <div class="flex flex-col md:flex-row justify-between mb-4">
                                <div id="sankeySourceLegend" class="w-full md:w-1/2 pr-4 space-y-1">
                                    <h4 class="text-sm font-semibold text-gray-700 mb-2" id="sourceLegendTitle">ä¾†æºåœ–ä¾‹ (Source)</h4>
                                </div>
                                <div id="sankeyTargetLegend" class="w-full md:w-1/2 pl-4 space-y-1 md:text-right">
                                    <h4 class="text-sm font-semibold text-gray-700 mb-2" id="targetLegendTitle">ç›®æ¨™åœ–ä¾‹ (Target)</h4>
                                </div>
                            </div>

                            <div id="sankeyChart" class="w-full overflow-x-auto">
                                <!-- D3 ç¹ªè£½ SVG å€å¡Š -->
                            </div>
                        </div>
                    </div>
                </details>


                <!-- 
                  =================================
                  å€å¡Š 2: å–®ä¸€æ¬„ä½åˆ†æ (å„€è¡¨æ¿)
                  =================================
                -->
                <details id="smallMultiplesSection" class="mt-6">
                    <!-- ä¿®æ­£åç¨± -->
                    <summary>å–®æ¬„åˆ†æ</summary>
                    <div>
                        <!-- ** ä¿®æ­£ 2ï¼šæ–°å¢ç¨ç«‹çš„ã€Œå€¼ã€åˆ‡æ›å™¨ ** -->
                        <div class="p-4 bg-white rounded-lg shadow-md mb-6">
                            <div class="mb-4">
                                <label for="smallValueSelect" class="block text-sm font-medium text-gray-700">æ¨ç´åˆ†æã€Œå€¼ã€ (Value)</label>
                                <select id="smallValueSelect" class="mt-1 block w-full py-2 px-3 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                                    <option value="count" selected>ç­†æ•¸ (COUNTA)</option>
                                    <option value="percent">å„åˆ—ä½”æ¯” (%)</option>
                                </select>
                            </div>

                            <label class="block text-sm font-medium text-gray-700 mb-2">è«‹é¸æ“‡è¦åˆ†æçš„æ¬„ä½ (å¯è¤‡é¸)</label>
                            
                            <!-- ** æ–°å¢ Q2 & Q3ï¼šåŠŸèƒ½æŒ‰éˆ• ** -->
                            <div class="flex flex-wrap gap-2 mb-2">
                                <button id="sm-select-all" class="text-xs bg-blue-500 text-white px-2 py-1 rounded hover:bg-blue-600">å…¨é¸</button>
                                <button id="sm-deselect-all" class="text-xs bg-gray-500 text-white px-2 py-1 rounded hover:bg-gray-600">å…¨éƒ¨æ¸…é™¤</button>
                                <button id="sm-download-screenshot" class="text-xs bg-green-600 text-white px-2 py-1 rounded hover:bg-green-700 ml-auto">
                                    <i class="fas fa-camera mr-1"></i> ä¸‹è¼‰æˆªåœ–
                                </button>
                            </div>
                            <div id="sm-screenshot-status" class="text-sm text-green-700 hidden mb-2"></div>
                            
                            <div id="smallMultiplesControls" class="multi-select-box">
                                <!-- JS æœƒå‹•æ…‹å¡«å…¥æ­¤è™• -->
                            </div>
                        </div>
                        
                        <!-- æ”¾ç½®å¤šå€‹å°åœ–è¡¨ -->
                        <!-- ** ä¿®æ­£ 1ï¼šç§»é™¤é–“è· ** -->
                        <div id="smallMultiplesContainer" class="space-y-0">
                            <!-- JS æœƒå‹•æ…‹å¡«å…¥åœ–è¡¨ -->
                        </div>
                    </div>
                </details>
                
            </div>
            
            <!-- 
              =================================
              å´é‚Šæ¬„: ç¯©é¸å™¨ (å…±ç”¨)
              =================================
            -->
            <div class="lg:col-span-1">
                <div class="bg-white p-4 rounded-lg shadow-md sticky top-8">
                    <h3 class="text-lg font-bold text-gray-800 mb-4">æ™ºæ…§ç¯©é¸ (å¯è¤‡é¸)</h3>
                    <div id="filtersContainer" class="space-y-4 max-h-[80vh] overflow-y-auto pr-2"></div>
                </div>
            </div>
        </main>
    </div>

    <script>
        Chart.register(ChartDataLabels);

        // ** ä¿®æ­£ 1.1: è¨­å®šé è¨­ Apps Script ç¶²å€ **
        const DEFAULT_SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbwSC-co1UtcQ0V2faXXuPIr5F7s3pri4ukLq9Tyu5unMfeVseAHsr_F04D0yzDssU-wbA/exec';
        
        // --- è¨­å®šé è¨­å€¼ (å·²ä¿®æ”¹) ---
        let DATALABELS_FONT_SIZE = 13; // é è¨­æ”¹ç‚º 13px
        let BAR_CATEGORY_PERCENTAGE = 0.5; // é è¨­æ”¹ç‚º 0.5
        let BAR_PERCENTAGE = 0.5; // é è¨­æ”¹ç‚º 0.5

        // 1. é«˜å°æ¯”åº¦çš„ã€Œé¡åˆ¥ã€èª¿è‰²ç›¤ (ç”¨æ–¼æ–‡å­—é¡åˆ¥ï¼Œæˆ–å°‘é‡çš„æ•¸å€¼é¡åˆ¥)
        const CATEGORICAL_PALETTE = ['#1e40af','#dc2626','#16a34a','#ea580c','#9333ea','#0891b2','#ca8a04','#db2777','#65a30d','#7c3aed','#0d9488','#c026d3','#475569','#f59e0b','#059669','#be185d'];
        // 2. ã€Œå†·è‡³æš–ã€æ¼¸å±¤èª¿è‰²ç›¤ (ç”¨æ–¼ 4 å€‹ä»¥ä¸Šçš„æ•¸å€¼é¡åˆ¥)
        const GRADIENT_PALETTE = ['#2563eb','#3b82f6','#06b6d4','#10b981','#84cc16','#eab308','#f59e0b','#f97316','#ef4444','#dc2626']; // 10-step cold-to-warm
        
        // ** FIXED_ANSWER_COLORS: æ ¹æ“šã€Œåˆ†æé¡Œç›®åœ–ä¾‹æ•´ç†ã€æ–‡ä»¶å…¨é¢æ›´æ–° **
        const FIXED_ANSWER_COLORS = {
            // 1.1 å¯µç‰©é¡å‹
            "çŠ¬": "#9AD8F5", // å·²å°‡ #FB8500 æ›´æ”¹ç‚º #9AD8F5
            "è²“": "#F35555",
            
            // 1.2 é£¼é¤Šæ•¸é‡
            "1 éš»": "#9AD8F5",
            "2 éš»": "#023047",
            "2+ éš»": "#F35555", 
            
            // 1.3 å¹´é½¡
            "0-1æ­²": "#9AD8F5",
            "1-3æ­²": "#22BDB5",
            "3-6æ­²": "#023047",
            "6-9æ­²": "#FFB703",
            "10æ­²ä»¥ä¸Š": "#F35555",
            
            // 1.4 å±…ä½å‹æ…‹
            "å–®é–“(3-10åª)": "#9AD8F5",
            "å¤šé–“(å«å®¢å»³)": "#22BDB5",
            "é€å¤©(ç¨æ£Ÿ)": "#FFB703",
            "åˆ¥å¢…(æœ‰åº­é™¢)": "#F35555",

            // 2.x, 3.x (Likert Scale)
            "1": "#9AD8F5", 
            "2": "#22BDB5", 
            "3": "#023047", 
            "4": "#FFB703",
            "5": "#F35555",

            // 3.4 å°ˆå¿ƒæ™‚é–“ (æ•¸å€¼)
            "3.4_0": "#BED1DB", // ä½¿ç”¨é¡Œç›®éµå‰ç¶´ä»¥é¿å…èˆ‡ 4.1 è¡çª
            "3.4_0.5": "#9AD8F5",
            "3.4_1": "#5ECBD5",
            "3.4_1.5": "#22BDB5",
            "3.4_2": "#12777E",
            "3.4_2.5": "#023047",
            "3.4_3": "#425236",
            "3.4_3.5": "#817425",
            "3.4_4": "#FFB703",
            "3.4_4.5": "#F9862C",
            "3.4_5": "#F35555",
            
            // 4.1 é£Ÿå“ä¿å¥èŠ±è²» (æ•¸å€¼)
            "4.1_0": "#BED1DB",
            "4.1_500": "#9AD8F5",
            "4.1_1000": "#5ECBD5",
            "4.1_1500": "#22BDB5",
            "4.1_2000": "#12777E",
            "4.1_2500": "#023047",
            "4.1_3000": "#425236",
            "4.1_3500": "#817425",
            "4.1_4000": "#FFB703",
            "4.1_4500": "#F9862C",
            "4.1_5000": "#F35555",

            // 4.3 ç§‘æŠ€ç”¨å“æ•¸é‡
            "4.3_0": "#9AD8F5", 
            "4.3_1": "#22BDB5", 
            "4.3_2": "#023047", 
            "4.3_3": "#FFB703", 
            "4.3_4": "#F9862C", 
            "4.3_5": "#F35555",
            
            // 5.1 ä¸å¥½ç¶“é©—
            "5.1_3": "#9AD8F5",
            "5.1_2": "#22BDB5",
            "5.1_1": "#FFB703",
            "5.1_0": "#F35555",
            
            // 5.2 é¡˜æ„æ·»è³¼
            "æ˜¯": "#9AD8F5", // å·²å°‡ #FB8500 æ›´æ”¹ç‚º #9AD8F5
            "å¦": "#F35555",
            
            // 5.4 é¡˜æ„è³¼è²·é‡‘é¡ (æ¨™ç±¤ç‚º -2000 åˆ° 2000)
            "-2000": "#F35555",
            "-1500": "#F9862C",
            "-1000": "#FFB703",
            "-500": "#817425",
            "0": "#023047", // é€™è£¡çš„ "0" èˆ‡ 3.4/4.1 çš„ "0" é¡è‰²ä¸åŒï¼Œä½† 5.4 é¡Œçµ„å„ªå…ˆä½¿ç”¨ï¼Œå› æ­¤ä¸åŠ å‰ç¶´
            "500": "#12777E", // åŒæ¨£ä¸åŠ å‰ç¶´ï¼Œäº¤çµ¦ CUSTOM_SORT_ORDERS è™•ç†
            "1000": "#22BDB5",
            "1500": "#5ECBD5",
            "2000": "#9AD8F5",
            
            // 6.1 æ€§åˆ¥
            "ç”·æ€§": "#9AD8F5", // å·²å°‡ #FB8500 æ›´æ”¹ç‚º #9AD8F5
            "å¥³æ€§": "#F35555",
            
            // 6.2 å¹´é½¡
            "24æ­²ä»¥ä¸‹": "#9AD8F5", // å·²å°‡ #FB8500 æ›´æ”¹ç‚º #9AD8F5
            "25 - 34æ­²": "#22BDB5",
            "35 - 44æ­²": "#023047",
            "45 - 54æ­²": "#FFB703",
            "55æ­²ä»¥ä¸Š": "#F35555",
            
            // 6.3, 6.4, 6.5, 6.6 (æ˜¯/å¦)
            "6.3_æ˜¯": "#9AD8F5", // å·²å°‡ #FB8500 æ›´æ”¹ç‚º #9AD8F5
            "6.3_å¦": "#F35555",
            "6.4_æ˜¯": "#9AD8F5", // å·²å°‡ #FB8500 æ›´æ”¹ç‚º #9AD8F5
            "6.4_å¦": "#F35555",
            "6.5_æœ‰": "#9AD8F5", 
            "6.5_ç„¡": "#F35555", 
            "6.6_æ˜¯": "#9AD8F5", // å·²å°‡ #FB8500 æ›´æ”¹ç‚º #9AD8F5
            "6.6_å¦": "#F35555",
            
            // 6.7 æœˆæ”¶å…¥
            "ç„¡é–’éŒ¢": "#9AD8F5",
            "å°åº·": "#22BDB5",
            "å¯Œè£•": "#FFB703",
            "å¤šåˆ°æ²’åœ°æ–¹èŠ±": "#F35555"
        };
        
        const QUESTION_MAP = {'1.1_å¯µç‰©é¡å‹':'æ‚¨ç›®å‰é£¼é¤Šçš„å¯µç‰©é¡å‹ç‚ºï¼Ÿ','1.2_é£¼é¤Šæ•¸é‡':'æ‚¨ç›®å‰é£¼é¤Šçš„å¯µç‰©æ•¸é‡ç‚ºï¼Ÿ','1.3_Age_Oldest':'æ‚¨ç›®å‰é£¼é¤Šçš„å¯µç‰©ä¸­ï¼Œæœ€å¹´é•·çš„å¹´ç´€ç‚ºï¼Ÿ','1.3_Age_Youngest':'æ‚¨ç›®å‰é£¼é¤Šçš„å¯µç‰©ä¸­ï¼Œæœ€å¹´å¹¼çš„å¹´ç´€ç‚ºï¼Ÿ','1.4_å±…ä½å‹æ…‹':'æ‚¨ç›®å‰çš„å±…ä½å‹æ…‹ç‚ºï¼Ÿ','2.1_è¦–ç‚ºå®¶äºº':'æˆ‘è¦–æˆ‘çš„å¯µç‰©ç‚ºå®¶äºº','2.2_æƒ…æ„Ÿæ…°è—‰':'å¯µç‰©æ˜¯æˆ‘çš„é‡è¦æƒ…æ„Ÿæ…°è—‰','2.3_å°å¯µèªªè©±':'æˆ‘ç¶“å¸¸å°æˆ‘çš„å¯µç‰©èªªè©±','2.4_æ“”å¿ƒæƒ³å¿µ':'ç•¶æˆ‘ä¸åœ¨å¯µç‰©èº«é‚Šæ™‚ï¼Œæˆ‘æœƒæ“”å¿ƒæˆ–æƒ³å¿µç‰ ','2.5_å¿«æ¨‚ä¾†æº':'å¯µç‰©æ˜¯æˆ‘å¿«æ¨‚çš„é‡è¦ä¾†æº','2.6_åƒå­©å­':'æˆ‘å¸¸è¦ºå¾—æˆ‘çš„å¯µç‰©åƒæˆ‘çš„å­©å­','2.7_å¡«è£œç©ºç¼º':'å¯µç‰©å¡«è£œäº†æˆ‘ç”Ÿæ´»ä¸­çš„ç©ºç¼º','2.8_æ—¥å¸¸è©±é¡Œ':'å¯µç‰©æ˜¯æˆ‘æ—¥å¸¸ç”Ÿæ´»ä¸­çš„é‡è¦è©±é¡Œ','3.1_å……æ»¿æ´»åŠ›':'æˆ‘å¸Œæœ›æˆ‘çš„å¯µç‰©ç¸½æ˜¯å……æ»¿æ´»åŠ›','3.2_æ“”å¿ƒç¨è™•':'æˆ‘æ“”å¿ƒå¯µç‰©ç¨è™•æ™‚æ„Ÿåˆ°å­¤å–®æˆ–ç„¦æ…®','3.3_é¡˜æ„é™ªä¼´':'æˆ‘é¡˜æ„èŠ±æ›´å¤šæ™‚é–“é™ªä¼´æˆ‘çš„å¯µç‰©','3.4_å°ˆå¿ƒæ™‚é–“':'æˆ‘æ¯å¤©éƒ½æœƒæœ‰ä¸€æ®µå°ˆå¿ƒé™ªä¼´å¯µç‰©çš„æ™‚é–“','4.1_é£Ÿå“ä¿å¥èŠ±è²»':'æ‚¨å¹³å‡æ¯æœˆåœ¨å¯µç‰©ã€Œé£Ÿå“èˆ‡ä¿å¥å“ã€ä¸ŠèŠ±è²»å¤šå°‘ï¼Ÿ','4.2_ç©å…·å¨›æ¨‚èŠ±è²»':'æ‚¨å¹³å‡æ¯æœˆåœ¨å¯µç‰©ã€Œç©å…·èˆ‡å¨›æ¨‚ç”¨å“ã€ä¸ŠèŠ±è²»å¤šå°‘ï¼Ÿ','4.3_ç§‘æŠ€ç”¨å“æ•¸é‡':'æ‚¨ç›®å‰æ“æœ‰å¤šå°‘ã€Œå¯µç‰©ç§‘æŠ€ç”¨å“ã€ï¼ˆå¦‚ï¼šè‡ªå‹•é¤µé£Ÿå™¨ã€é£²æ°´å™¨ã€å¯µç‰©æ”å½±æ©Ÿã€æ™ºèƒ½ç©å…·ç­‰ï¼‰ï¼Ÿ','4.4_æœ€é«˜ç”¢å“é‡‘é¡':'æ‚¨é¡˜æ„ç‚ºå–®ä¸€ã€Œå¯µç‰©ç§‘æŠ€ç”¢å“ã€æ”¯ä»˜çš„æœ€é«˜é‡‘é¡ç´„ç‚ºï¼Ÿ','5.1_ä¸å¥½ç¶“é©—':'æ‚¨éå»æ˜¯å¦æœ‰ä½¿ç”¨å¯µç‰©ç§‘æŠ€ç”¢å“çš„ä¸è‰¯ç¶“é©—ï¼Ÿ','5.2_é¡˜æ„æ·»è³¼':'æœªä¾† 6 å€‹æœˆå…§ï¼Œæ‚¨æ˜¯å¦è€ƒæ…®æ·»è³¼ neuen ã€Œå¯µç‰©ç§‘æŠ€ç”¢å“ã€ï¼Ÿ','5.3_é¡˜æ„è³¼è²·é‡‘é¡':'è‹¥æœ‰ä¸€æ¬¾ã€Œå¯µç‰©é™ªä¼´æ©Ÿå™¨äººã€ï¼Œæ‚¨é¡˜æ„è³¼è²·çš„é‡‘é¡ç¯„åœæ˜¯ï¼Ÿ','5.4_é–‹å¿ƒä½¿ç”¨':'æˆ‘æ¨‚æ–¼çœ‹åˆ°å¯µç‰©é–‹å¿ƒä½¿ç”¨ç§‘æŠ€ç”¢å“','5.4_å®‰å…¨ä½¿ç”¨':'æˆ‘æœ€æ“”å¿ƒå¯µç‰©ç§‘æŠ€ç”¢å“çš„å®‰å…¨æ€§','5.4_ç¯€çœæ™‚é–“':'æˆ‘å¸Œæœ›å¯µç‰©ç§‘æŠ€ç”¢å“èƒ½å¹«æˆ‘ç¯€çœç…§é¡§æ™‚é–“','5.4_æŒä¹…è€ç”¨':'æˆ‘é‡è¦–å¯µç‰©ç§‘æŠ€ç”¢å“çš„æŒä¹…è€ç”¨æ€§','5.4_å®¹æ˜“æ¸…æ½”':'æˆ‘å¸Œæœ›å¯µç‰©ç§‘æŠ€ç”¢å“å®¹æ˜“æ¸…æ½”','6.1_æ€§åˆ¥':'æ‚¨çš„æ€§åˆ¥','6.2_å¹´é½¡':'æ‚¨çš„å¹´é½¡','6.3_å–®èº«':'æ‚¨ç›®å‰çš„å©šå§»ç‹€æ³','6.4_ç¨å±…':'æ‚¨ç›®å‰æ˜¯å¦ç¨å±…','6.5_å­å¥³':'æ‚¨ç›®å‰æ˜¯å¦æœ‰å­å¥³åŒä½','6.6_å¯µç‰©ç›¸é—œèƒŒæ™¯':'æ‚¨æ˜¯å¦å…·æœ‰å¯µç‰©ç›¸é—œèƒŒæ™¯ï¼ˆå¦‚ï¼šç¸é†«ã€å¯µç‰©ç¾å®¹ã€è¨“ç·´å¸«ç­‰ï¼‰ï¼Ÿ','6.7_æœˆæ”¶å…¥':'æ‚¨çš„å€‹äººå¹³å‡æœˆæ”¶å…¥'};
        
        // ** CUSTOM_SORT_ORDERS: æ ¹æ“šã€Œåˆ†æé¡Œç›®åœ–ä¾‹æ•´ç†ã€æ–‡ä»¶å…¨é¢æ›´æ–° **
        const CUSTOM_SORT_ORDERS = {
            '1.1_å¯µç‰©é¡å‹': ["çŠ¬", "è²“"],
            '1.2_é£¼é¤Šæ•¸é‡': ["1 éš»", "2 éš»", "2+ éš»"],
            '1.3_Age_Oldest': ["0-1æ­²", "1-3æ­²", "3-6æ­²", "6-9æ­²", "10æ­²ä»¥ä¸Š"],
            '1.3_Age_Youngest': ["0-1æ­²", "1-3æ­²", "3-6æ­²", "6-9æ­²", "10æ­²ä»¥ä¸Š"],
            '1.4_å±…ä½å‹æ…‹': ["å–®é–“(3-10åª)", "å¤šé–“(å«å®¢å»³)", "é€å¤©(ç¨æ£Ÿ)", "åˆ¥å¢…(æœ‰åº­é™¢)"],
            
            // Likert Scale (2.x, 3.x)
            '2.1_è¦–ç‚ºå®¶äºº': ["1", "2", "3", "4", "5"],
            '2.2_æƒ…æ„Ÿæ…°è—‰': ["1", "2", "3", "4", "5"],
            '2.3_å°å¯µèªªè©±': ["1", "2", "3", "4", "5"],
            '2.4_æ“”å¿ƒæƒ³å¿µ': ["1", "2", "3", "4", "5"],
            '2.5_å¿«æ¨‚ä¾†æº': ["1", "2", "3", "4", "5"],
            '2.6_åƒå­©å­': ["1", "2", "3", "4", "5"],
            '2.7_å¡«è£œç©ºç¼º': ["1", "2", "3", "4", "5"],
            '2.8_æ—¥å¸¸è©±é¡Œ': ["1", "2", "3", "4", "5"],
            '3.1_å……æ»¿æ´»åŠ›': ["1", "2", "3", "4", "5"],
            '3.2_æ“”å¿ƒç¨è™•': ["1", "2", "3", "4", "5"],
            '3.3_é¡˜æ„é™ªä¼´': ["1", "2", "3", "4", "5"],
            
            // 3.4 å°ˆå¿ƒæ™‚é–“
            '3.4_å°ˆå¿ƒæ™‚é–“': ["0", "0.5", "1", "1.5", "2", "2.5", "3", "3.5", "4", "4.5", "5"],
            
            // 4.1 é£Ÿå“ä¿å¥èŠ±è²»
            '4.1_é£Ÿå“ä¿å¥èŠ±è²»': ["0", "500", "1000", "1500", "2000", "2500", "3000", "3500", "4000", "4500", "5000"],
            
            // 4.3 ç§‘æŠ€ç”¨å“æ•¸é‡
            '4.3_ç§‘æŠ€ç”¨å“æ•¸é‡': ["0", "1", "2", "3", "4", "5"],
            
            // 5.1 ä¸å¥½ç¶“é©— (0-3 æ’åº)
            '5.1_ä¸å¥½ç¶“é©—': ["0", "1", "2", "3"],
            
            // 5.2 é¡˜æ„æ·»è³¼
            '5.2_é¡˜æ„æ·»è³¼': ["æ˜¯", "å¦"],
            
            // 5.4 é¡Œçµ„ (ç§»é™¤ NT$ å’Œ +)
            '5.4_é–‹å¿ƒä½¿ç”¨': ["-2000", "-1500", "-1000", "-500", "0", "500", "1000", "1500", "2000"],
            '5.4_å®‰å…¨ä½¿ç”¨': ["-2000", "-1500", "-1000", "-500", "0", "500", "1000", "1500", "2000"],
            '5.4_ç¯€çœæ™‚é–“': ["-2000", "-1500", "-1000", "-500", "0", "500", "1000", "1500", "2000"],
            '5.4_æŒä¹…è€ç”¨': ["-2000", "-1500", "-1000", "-500", "0", "500", "1000", "1500", "2000"],
            '5.4_å®¹æ˜“æ¸…æ½”': ["-2000", "-1500", "-1000", "-500", "0", "500", "1000", "1500", "2000"],
            
            // 6.x å€‹äººåŸºæœ¬è³‡è¨Š
            '6.1_æ€§åˆ¥': ["ç”·æ€§", "å¥³æ€§"],
            '6.2_å¹´é½¡': ["24æ­²ä»¥ä¸‹", "25 - 34æ­²", "35 - 44æ­²", "45 - 54æ­²", "55æ­²ä»¥ä¸Š"],
            '6.3_å–®èº«': ["æ˜¯", "å¦"],
            '6.4_ç¨å±…': ["æ˜¯", "å¦"],
            '6.5_å­å¥³': ["æœ‰", "ç„¡"],
            '6.6_å¯µç‰©ç›¸é—œèƒŒæ™¯': ["æ˜¯", "å¦"],
            '6.7_æœˆæ”¶å…¥': ["ç„¡é–’éŒ¢", "å°åº·", "å¯Œè£•", "å¤šåˆ°æ²’åœ°æ–¹èŠ±"]
        };
        
        // --- ä½”æ¯”æ¨¡å¼ 25/50/75% è™›ç·šå¤–æ› ---
        const percentageGridLinesPlugin = {
            id: 'percentageGridLines',
            afterDraw: (chart) => {
                // ** ä¿®æ­£ï¼šæª¢æŸ¥åœ–è¡¨ IDï¼Œåªåœ¨ä¸»åœ–è¡¨ä¸Šé‹ä½œ **
                if (chart.canvas.id !== 'mainChart') return;
                
                const valueType = document.getElementById('valueSelect')?.value;
                if (valueType !== 'percent') {
                    return; // åªåœ¨ä½”æ¯”æ¨¡å¼ä¸‹ç¹ªè£½
                }
                const ctx = chart.ctx;
                const xAxis = chart.scales.x;
                const yAxis = chart.scales.y;
                const lines = [25, 50, 75]; // 25%, 50%, 75%

                ctx.save();
                ctx.strokeStyle = '#e0e0e0'; // æ·¡æ·¡çš„ç°è‰²
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 3]); // è™›ç·š

                lines.forEach(value => {
                    const xPos = xAxis.getPixelForValue(value);
                    ctx.beginPath();
                    ctx.moveTo(xPos, yAxis.top);
                    ctx.lineTo(xPos, yAxis.bottom);
                    ctx.stroke();
                });

                ctx.restore();
            }
        };
        Chart.register(percentageGridLinesPlugin); // è¨»å†Šå¤–æ›

        // --- Helper å‡½æ•¸ ---
        function parseNumericValue(val) {
            const valStr = String(val).trim(); // ** ä¿®æ­£ï¼šTrim ç©ºç™½ **
            // ç§»é™¤ NT$ æˆ–å…¶ä»–è²¨å¹£ç¬¦è™Ÿ
            const cleanedStr = valStr.replace(/[$NT$]/g, '').trim(); 
            
            const hasPlusSuffix = cleanedStr.endsWith('+') || cleanedStr.includes('ä»¥ä¸Š');
            // åŒ¹é…åŒ…å«æ­£è² è™Ÿã€ç©ºæ ¼æˆ–é€—è™Ÿçš„æ•¸å­—
            const numMatch = cleanedStr.match(/([+-]?[\s]*[\d,]+(\.\d+)?)/); 
            
            if (numMatch) {
                const numStr = numMatch[1].replace(/[,]/g, '').replace(/\s/g, '');
                const num = parseFloat(numStr);
                if (!isNaN(num)) {
                    // å°æ–¼æœ‰ + è™Ÿçµå°¾æˆ–ã€Œä»¥ä¸Šã€çš„ï¼Œæ¨™è¨˜ç‚ºæœ‰å¾Œç¶´
                    if (hasPlusSuffix && num >= 0) {
                        return { num: num, hasPlus: true, original: valStr, isNumeric: true };
                    }
                    return { num: num, hasPlus: false, original: valStr, isNumeric: true };
                }
            }
            return { num: null, hasPlus: false, original: valStr, isNumeric: false };
        }
        function smartSort(a, b) {
            const valA = parseNumericValue(a);
            const valB = parseNumericValue(b);
            if (!valA.isNumeric && !valB.isNumeric) {
                return String(a).localeCompare(String(b));
            }
            if (!valA.isNumeric) return 1;
            if (!valB.isNumeric) return -1;
            if (valA.hasPlus && !valB.hasPlus) return 1;
            if (!valA.hasPlus && valB.hasPlus) return -1;
            if (valA.num !== valB.num) {
                return valA.num - valB.num;
            }
            return valA.original.localeCompare(valB.original);
        }

        // ** ä¿®æ­£ 1.1ï¼šæ–°å¢å–å¾—é¡Œç›®å‰ç¶´çš„å‡½æ•¸ **
        function getQuestionPrefix(key) {
            // Extracts '1.1' from '1.1_å¯µç‰©é¡å‹', or '6.5' from '6.5_å­å¥³'
            const match = key.match(/^(\d+\.\d+)/);
            return match ? match[1] : key; // Return the prefix or the whole key if no match
        }

        // ** æ–°å¢ Q1ï¼šDebounce å‡½æ•¸ **
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        let chart; // ä¸»åœ–è¡¨ (æ¨ç´)
        let rawData = [];
        let allColumns = [];
        let controls = {};
        let isUpdatingFilters = false;
        let smallCharts = {}; // ** å„²å­˜å°åœ–è¡¨çš„ç‰©ä»¶ **
        
        // --- åˆå§‹åŒ– ---
        window.addEventListener('DOMContentLoaded', () => {
            // ** ä¿®æ­£ 1.1: è¨­å®šé è¨­ Apps Script ç¶²å€ **
            const DEFAULT_SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbwSC-co1UtcQ0V2faXXuPIr5F7s3pri4ukLq9Tyu5unMfeVseAHsr_F04D0yzDssU-wbA/exec';

            // ä¿®æ­£ 1.2: ç§»é™¤è¼‰å…¥æŒ‰éˆ•ç›¸é—œçš„ DOM å…ƒç´ 
            document.getElementById('setupInstructions').classList.remove('max-w-4xl', 'mx-auto', 'mb-8', 'p-6', 'bg-blue-50', 'border-2', 'border-blue-200', 'rounded-lg');
            document.getElementById('setupInstructions').innerHTML = `<h2 class="text-xl font-bold text-blue-800 mb-4">ğŸ“‹ è¨­å®šç‹€æ…‹</h2><p class="text-gray-700">è³‡æ–™å°‡æ–¼é é¢é–‹å•Ÿæ™‚è‡ªå‹•è¼‰å…¥ã€‚å¦‚éœ€è®Šæ›´è³‡æ–™ä¾†æºï¼Œè«‹ä¿®æ”¹ç¨‹å¼ç¢¼å…§ <code>DEFAULT_SCRIPT_URL</code> è®Šæ•¸ã€‚</p>`;
            
            const settingsModal = document.getElementById('settingsModal');
            const settingsButton = document.getElementById('settingsButton');
            const closeSettingsModal = document.getElementById('closeSettingsModal');
            const datalabelsSize = document.getElementById('datalabelsSize');
            const datalabelsSizeValue = document.getElementById('datalabelsSizeValue');
            const barThickness = document.getElementById('barThickness');
            const barThicknessValue = document.getElementById('barThicknessValue');
            
            // æ¡‘åŸºåœ–æ§åˆ¶é …
            const sankeySourceSelect = document.getElementById('sankeySourceSelect');
            const sankeyTargetSelect = document.getElementById('sankeyTargetSelect');
            const sankeyMinThreshold = document.getElementById('sankeyMinThreshold');
            const sankeyMinThresholdValue = document.getElementById('sankeyMinThresholdValue');
            // æ–°å¢æ¡‘åŸºåœ–äº¤æ›æŒ‰éˆ•
            const swapSankeyAxesButton = document.getElementById('swapSankeyAxesButton');

            settingsButton.addEventListener('click', () => settingsModal.style.display = 'block');
            closeSettingsModal.addEventListener('click', () => settingsModal.style.display = 'none');
            window.addEventListener('click', (event) => {
                if (event.target === settingsModal) {
                    settingsModal.style.display = 'none';
                }
            });

            // åˆå§‹åŒ–è¨­å®šå€¼é¡¯ç¤º (ä½¿ç”¨å…¨åŸŸè®Šæ•¸çš„é è¨­å€¼)
            datalabelsSize.value = DATALABELS_FONT_SIZE;
            datalabelsSizeValue.textContent = DATALABELS_FONT_SIZE;
            barThickness.value = BAR_CATEGORY_PERCENTAGE;
            barThicknessValue.textContent = BAR_CATEGORY_PERCENTAGE.toFixed(1);
            sankeyMinThresholdValue.textContent = sankeyMinThreshold.value;

            // ç¶å®šè¨­å®šèª¿æ•´äº‹ä»¶
            datalabelsSize.addEventListener('input', () => {
                DATALABELS_FONT_SIZE = parseInt(datalabelsSize.value);
                datalabelsSizeValue.textContent = DATALABELS_FONT_SIZE;
                if (chart) updateChartSettings(true); 
                updateSmallMultiplesSettings(true); 
            });

            barThickness.addEventListener('input', () => {
                BAR_CATEGORY_PERCENTAGE = parseFloat(barThickness.value);
                BAR_PERCENTAGE = parseFloat(barThickness.value);
                barThicknessValue.textContent = BAR_CATEGORY_PERCENTAGE.toFixed(1);
                if (chart) updateChartSettings(true); 
                updateSmallMultiplesSettings(true); 
            });
            
            // ç¶å®š Sankey æ§åˆ¶é …äº‹ä»¶
            sankeySourceSelect.addEventListener('change', updateSankeyChart);
            sankeyTargetSelect.addEventListener('change', updateSankeyChart);
            sankeyMinThreshold.addEventListener('input', () => {
                sankeyMinThresholdValue.textContent = sankeyMinThreshold.value;
                debounce(updateSankeyChart, 300)();
            });
            
            // æ¡‘åŸºåœ–äº¤æ›æŒ‰éˆ•äº‹ä»¶
            swapSankeyAxesButton.addEventListener('click', () => {
                const sourceValue = sankeySourceSelect.value;
                const targetValue = sankeyTargetSelect.value;
                sankeySourceSelect.value = targetValue;
                sankeyTargetSelect.value = sourceValue;
                updateSankeyChart();
            });

            // ** ä¿®æ­£ 1.4: é é¢è¼‰å…¥å¾Œè‡ªå‹•è¼‰å…¥æ•¸æ“š **
            initDashboard(DEFAULT_SCRIPT_URL);
        });

        document.addEventListener('click', (e) => {
            const openFilters = document.querySelectorAll('.filter-dropdown[open]');
            openFilters.forEach(filter => {
                if (!filter.contains(e.target)) {
                    filter.open = false;
                }
            });
        });

        async function loadData(scriptUrl) {
            const debugInfo = document.getElementById('debugInfo');
            const loadingMessage = document.getElementById('loadingMessage');
            try {
                loadingMessage.textContent = 'æ­£åœ¨å¾ Google Sheet æ“·å–è³‡æ–™...';
                
                const url = scriptUrl;
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`ä¼ºæœå™¨éŒ¯èª¤: ${response.status}`);
                }
                const jsonData = await response.json();
                if (jsonData.error) {
                    throw new Error(`Apps Script éŒ¯èª¤: ${jsonData.error}`);
                }
                if (!Array.isArray(jsonData) || jsonData.length === 0) {
                    throw new Error('æœªæ”¶åˆ°ä»»ä½•è³‡æ–™æˆ–è³‡æ–™æ ¼å¼ä¸ç¬¦ã€‚');
                }
                return jsonData;
            } catch (error) {
                // ä¿®æ­£ 2.2: å¦‚æœè¼‰å…¥å¤±æ•—ï¼Œé¡¯ç¤ºéŒ¯èª¤è³‡è¨Šï¼Œä¸¦å°‡ loading éš±è—
                document.getElementById('loading').classList.add('hidden');
                document.getElementById('dashboard').classList.add('hidden');
                document.getElementById('setupInstructions').classList.remove('hidden');
                const errorContainer = document.getElementById('debugInfo');
                if (errorContainer) {
                    errorContainer.innerHTML = `<p class="text-red-600 ml-4">âŒ <strong>è¼‰å…¥å¤±æ•—: ${error.message}</strong></p>`;
                    errorContainer.innerHTML += `<p class="text-red-700 ml-6 mt-2">è«‹æª¢æŸ¥ï¼š<br>1. ç¨‹å¼ç¢¼ä¸­ <code>DEFAULT_SCRIPT_URL</code> ç¶²å€æ˜¯å¦æ­£ç¢ºã€‚<br>2. Apps Script éƒ¨ç½²æ¬Šé™æ˜¯å¦è¨­å®šç‚ºã€Œä»»ä½•äººã€ã€‚<br>3. Google Sheet çš„æ¬„ä½æ˜¯å¦æœ‰è³‡æ–™ã€‚</p>`;
                    document.getElementById('debugInfoContainer').classList.remove('hidden');
                }
                return [];
            }
        }

        async function initDashboard(scriptUrl) {
            rawData = await loadData(scriptUrl);
            if (rawData.length > 0) {
                allColumns = Object.keys(rawData[0]);
                document.getElementById('loading').classList.add('hidden');
                document.getElementById('dashboard').classList.remove('hidden');
                document.getElementById('setupInstructions').classList.remove('hidden'); // é¡¯ç¤ºè¨­å®šç‹€æ…‹
                // ä¿®æ­£ 2.4: æˆåŠŸè¼‰å…¥å¾Œï¼Œéš±è—éŒ¯èª¤è³‡è¨Š
                document.getElementById('debugInfoContainer').classList.add('hidden');
                setupControls();
                createChart(); // å»ºç«‹ä¸»åœ–è¡¨
                updateChart(); // æ›´æ–°ä¸»åœ–è¡¨
                updateSankeyChart(); // å»ºç«‹æ¡‘åŸºåœ–
                updateSmallMultiples(); // æ›´æ–°å°åœ–è¡¨
            }
        }

        function updateAnnotations() {
            // ** ç°¡åŒ–ï¼šåªæ›´æ–°ä¸»åœ–è¡¨çš„è¨»é‡‹ **
            const yKey = controls.yAxisSelect.value;
            const cKey = controls.colorBySelect.value;
            const yEl = document.getElementById('yAxisQuestion');
            const cEl = document.getElementById('colorByQuestion');
            
            yEl.textContent = QUESTION_MAP[yKey] || 'æœªæ‰¾åˆ°å•é¡Œæè¿°';
            if (cKey === 'none') {
                cEl.textContent = 'æœªåˆ†çµ„';
            } else {
                cEl.textContent = QUESTION_MAP[cKey] || 'æœªæ‰¾åˆ°å•é¡Œæè¿°';
            }
        }

        function setupControls() {
            controls.yAxisSelect = document.getElementById('yAxisSelect');
            controls.colorBySelect = document.getElementById('colorBySelect'); // ** ç°¡åŒ–ï¼šå›ºå®šç‚ºå–®é¸ **
            controls.valueSelect = document.getElementById('valueSelect');
            controls.smallValueSelect = document.getElementById('smallValueSelect'); // ** ä¿®æ­£ 2ï¼šåŠ å…¥æ–°çš„æ§åˆ¶å™¨ **
            controls.swapButton = document.getElementById('swapAxesButton');
            controls.arrowSelect = document.getElementById('arrowSelect');
            
            // Sankey Controls
            controls.sankeySourceSelect = document.getElementById('sankeySourceSelect');
            controls.sankeyTargetSelect = document.getElementById('sankeyTargetSelect');

            // ** ç°¡åŒ–ï¼šç§»é™¤ (ç¸½è¨ˆ) é¸é … **
            controls.yAxisSelect.innerHTML = '';
            controls.colorBySelect.innerHTML = '<option value="none">ä¸åˆ†çµ„ (å–®ä¸€é¡è‰²)</option>';
            controls.sankeySourceSelect.innerHTML = '<option value="">è«‹é¸æ“‡</option>';
            controls.sankeyTargetSelect.innerHTML = '<option value="">è«‹é¸æ“‡</option>';

            allColumns.forEach(key => {
                controls.yAxisSelect.innerHTML += `<option value="${key}">${key}</option>`;
                controls.colorBySelect.innerHTML += `<option value="${key}">${key}</option>`;
                controls.sankeySourceSelect.innerHTML += `<option value="${key}">${key}</option>`;
                controls.sankeyTargetSelect.innerHTML += `<option value="${key}">${key}</option>`;
            });
            
            // ** æ–°å¢ï¼šè¨­å®šã€Œå–®ä¸€æ¬„ä½åˆ†æã€çš„è¤‡é¸æ¡† **
            const smallMultiplesControls = document.getElementById('smallMultiplesControls');
            let multiSelectHTML = '';
            allColumns.forEach(key => {
                multiSelectHTML += `
                    <label class="flex items-center">
                        <input type="checkbox" value="${key}" class="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500 small-multiple-checkbox">
                        <span class="ml-2 text-sm text-gray-900">${key}</span>
                    </label>
                `;
            });
            smallMultiplesControls.innerHTML = multiSelectHTML;
            
            // ** ç¶å®šæ–°è¤‡é¸æ¡†çš„äº‹ä»¶ **
            smallMultiplesControls.querySelectorAll('.small-multiple-checkbox').forEach(cb => {
                cb.addEventListener('change', updateSmallMultiples);
            });
            
            // ** æ–°å¢ Q2 & Q3ï¼šç¶å®šæŒ‰éˆ•äº‹ä»¶ **
            document.getElementById('sm-select-all').addEventListener('click', () => {
                smallMultiplesControls.querySelectorAll('.small-multiple-checkbox').forEach(cb => cb.checked = true);
                updateSmallMultiples();
            });
            document.getElementById('sm-deselect-all').addEventListener('click', (e) => {
                e.preventDefault();
                smallMultiplesControls.querySelectorAll('.small-multiple-checkbox').forEach(cb => cb.checked = false);
                updateSmallMultiples();
            });
            document.getElementById('sm-download-screenshot').addEventListener('click', downloadScreenshot);


            // --- ç¯©é¸å™¨ (å…±ç”¨) ---
            const filtersContainer = document.getElementById('filtersContainer');
            filtersContainer.innerHTML = '';
            allColumns.forEach(colKey => {
                const details = document.createElement('details');
                details.className = 'filter-dropdown';
                details.innerHTML = `<summary class="text-sm font-medium" title="${colKey}">${colKey}</summary><div class="filter-panel space-y-2" id="filter-${colKey}-panel"></div>`;
                filtersContainer.appendChild(details);
            });

            // --- ç¶å®šä¸»åœ–è¡¨äº‹ä»¶ ---
            controls.yAxisSelect.addEventListener('change', () => { 
                updateAnnotations(); 
                updateChart(); 
                updateSankeyChart(); // ç¯©é¸å™¨è®Šæ›´ä¹Ÿæ›´æ–° Sankey
            });
            controls.colorBySelect.addEventListener('change', () => {
                updateAnnotations();
                updateChart();
                updateSankeyChart(); // ç¯©é¸å™¨è®Šæ›´ä¹Ÿæ›´æ–° Sankey
            });
            controls.swapButton.addEventListener('click', () => {
                const yValue = controls.yAxisSelect.value;
                const cValue = controls.colorBySelect.value;
                controls.yAxisSelect.value = cValue;
                controls.colorBySelect.value = yValue;
                updateAnnotations();
                updateChart();
                updateSankeyChart(); // ç¯©é¸å™¨è®Šæ›´ä¹Ÿæ›´æ–° Sankey
            });
            controls.arrowSelect.addEventListener('change', updateArrowPosition);

            // ** ä¿®æ­£ 2ï¼šã€Œå€¼ã€å’Œã€Œç¯©é¸å™¨ã€éœ€è¦*åˆ†é–‹*æ›´æ–°å…©å€‹åœ–è¡¨å€å¡Š **
            controls.valueSelect.addEventListener('change', updateChart); // ** åªæ›´æ–°ä¸»åœ–è¡¨ **
            controls.smallValueSelect.addEventListener('change', updateSmallMultiples); // ** åªæ›´æ–°å°åœ–è¡¨ **

            updateFilterOptions(true); // updateFilterOptions å…§éƒ¨æœƒç¶å®šç¯©é¸å™¨çš„ change äº‹ä»¶
            updateAnnotations();
        }

        
        function updateFilterOptions(isInitial = false) {
            if (isUpdatingFilters) return;
            const selections = {};
            allColumns.forEach(key => {
                const panel = document.getElementById(`filter-${key}-panel`);
                if (panel) {
                    const checkedCbs = panel.querySelectorAll('input:checked');
                    selections[key] = Array.from(checkedCbs).map(cb => cb.value);
                }
            });

            allColumns.forEach(targetKey => {
                let availableValues = [...new Set(rawData.map(d => d[targetKey]))];
                
                // ** ä¿®æ­£ï¼šä½¿ç”¨ .trim() é€²è¡Œæ’åºåˆ—è¡¨æ¯”å° **
                if (CUSTOM_SORT_ORDERS[targetKey]) {
                    const customOrder = CUSTOM_SORT_ORDERS[targetKey];
                    const getSortIndex = (val) => {
                        const index = customOrder.indexOf(String(val).trim()); // ** Trim here **
                        return index === -1 ? Infinity : index;
                    };
                    availableValues.sort((a, b) => getSortIndex(a) - getSortIndex(b));
                } else {
                    availableValues.sort(smartSort);
                }
                
                const panel = document.getElementById(`filter-${targetKey}-panel`);
                if (!panel) return;
                const currentSelections = selections[targetKey] || [];
                panel.innerHTML = '';
                
                const buttonsDiv = document.createElement('div');
                buttonsDiv.className = 'flex gap-2 mb-2 sticky top-0 bg-white py-1';
                buttonsDiv.innerHTML = `
                    <button class="select-all-btn text-xs bg-blue-500 text-white px-2 py-1 rounded hover:bg-blue-600">å…¨é¸</button>
                    <button class="deselect-all-btn text-xs bg-gray-500 text-white px-2 py-1 rounded hover:bg-gray-600">æ¸…é™¤</button>
                `;
                panel.appendChild(buttonsDiv);
                
                availableValues.forEach(val => {
                    const valAsString = String(val);
                    const checkboxId = `cb-${targetKey}-${valAsString.replace(/[^a-zA-Z0-9]/g, '-')}`;
                    const isChecked = isInitial || currentSelections.includes(valAsString);
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'flex items-center';
                    itemDiv.innerHTML = `
                        <input type="checkbox" id="${checkboxId}" value="${valAsString}" class="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500 filter-checkbox" ${isChecked ? 'checked' : ''}>
                        <label for="${checkboxId}" class="ml-2 block text-sm text-gray-900">${valAsString}</label>
                    `;
                    panel.appendChild(itemDiv);
                });
                
                // ** ä¿®æ­£ 3ï¼šç¢ºèªç¯©é¸å™¨æœƒæ›´æ–°ä¸‰å€‹åœ–è¡¨ **
                panel.querySelector('.select-all-btn').addEventListener('click', (e) => {
                    e.preventDefault();
                    panel.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = true);
                    updateChart();
                    updateSmallMultiples(); 
                    updateSankeyChart(); // ç¯©é¸å™¨è®Šæ›´ä¹Ÿæ›´æ–° Sankey
                });
                panel.querySelector('.deselect-all-btn').addEventListener('click', (e) => {
                    e.preventDefault();
                    panel.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false);
                    updateChart();
                    updateSmallMultiples(); 
                    updateSankeyChart(); // ç¯©é¸å™¨è®Šæ›´ä¹Ÿæ›´æ–° Sankey
                });
                panel.querySelectorAll('.filter-checkbox').forEach(cb => {
                    cb.addEventListener('change', () => {
                        updateChart();
                        updateSmallMultiples(); 
                        updateSankeyChart(); // ç¯©é¸å™¨è®Šæ›´ä¹Ÿæ›´æ–° Sankey
                    });
                });
            });
        }

        // --- æ¨™è¨˜å»ºç«‹å‡½æ•¸ (Marker Creation Functions) ---
        // (é€™äº›åªçµ¦ä¸»åœ–è¡¨ä½¿ç”¨)
        function createOrUpdateArrows(count) {
            const arrowContainer = document.getElementById('markerContainer');
            if (!arrowContainer) return;
            const existing = arrowContainer.querySelectorAll('.chart-arrow');
            
            for (let i = existing.length - 1; i >= count; i--) {
                arrowContainer.removeChild(existing[i]);
            }
            for (let i = existing.length; i < count; i++) {
                const arrowEl = document.createElement('div');
                arrowEl.id = `chartArrow-${i}`;
                arrowEl.className = 'chart-arrow';
                arrowContainer.appendChild(arrowEl);
            }
        }
        function createOrUpdateQuantileMarkers(count) {
            const container = document.getElementById('markerContainer');
            if (!container) return;
            const markers = ['q1', 'q2', 'q3']; 
            const existing = container.querySelectorAll('.quantile-marker');
            const targetCount = count * markers.length;
            for (let i = existing.length - 1; i >= targetCount; i--) container.removeChild(existing[i]);
            for (let i = existing.length; i < targetCount; i++) {
                const yIndex = Math.floor(i / markers.length);
                const markerType = markers[i % markers.length];
                const markerEl = document.createElement('div');
                markerEl.id = `quantileMarker-${yIndex}-${markerType}`;
                markerEl.className = `quantile-marker ${markerType === 'q2' ? 'quantile-marker-q2' : ''}`;
                container.appendChild(markerEl);
            }
        }
        function createOrUpdateAverageLabels(count) {
            const container = document.getElementById('markerContainer');
            if (!container) return;
            const existing = container.querySelectorAll('.average-label');
            for (let i = existing.length - 1; i >= count; i--) container.removeChild(existing[i]);
            for (let i = existing.length; i < count; i++) {
                const labelEl = document.createElement('div');
                labelEl.id = `averageLabel-${i}`;
                labelEl.className = 'average-label';
                container.appendChild(labelEl);
            }
        }

        // --- æ¨™è¨˜æ›´æ–°å‡½æ•¸ (Marker Update Functions) ---
        // (é€™äº›åªçµ¦ä¸»åœ–è¡¨ä½¿ç”¨)
        function updateArrowPosition(hide = false) {
            const container = document.getElementById('markerContainer');
            if (!container) return;
            const arrows = container.querySelectorAll('.chart-arrow');
            if (hide) {
                arrows.forEach(arrow => arrow.style.display = 'none');
                return;
            }
            const selectEl = document.getElementById('arrowSelect');
            const selectedLabelString = selectEl.value;
            arrows.forEach(arrow => arrow.style.display = 'none'); 
            if (!chart || !selectedLabelString) return;
            const datasets = chart.data.datasets;
            let datasetIndex = -1;
            for (let i = 0; i < datasets.length; i++) {
                if (String(datasets[i].label) === selectedLabelString) {
                    datasetIndex = i;
                    break;
                }
            }
            if (datasetIndex === -1) return; 
            const meta = chart.getDatasetMeta(datasetIndex);
            if (!meta || !meta.data || meta.data.length === 0) return;
            meta.data.forEach((element, index) => {
                const arrowEl = document.getElementById(`chartArrow-${index}`);
                if (!arrowEl || !element || typeof element.getProps !== 'function' || element.hidden) {
                    if (arrowEl) arrowEl.style.display = 'none';
                    return;
                }
                const props = element.getProps(['x', 'y', 'height', 'base'], true);
                const hasVisibleWidth = props && (props.x > props.base + 0.01);
                if (hasVisibleWidth) {
                    const xPos = props.x;
                    const yPos = props.y - (props.height / 2);
                    const arrowHeight = 8;
                    const margin = 2;
                    arrowEl.style.left = `${xPos}px`;
                    arrowEl.style.top = `${yPos - arrowHeight - margin}px`;
                    arrowEl.style.display = 'block';
                } else {
                    arrowEl.style.display = 'none';
                }
            });
        }
        function updateQuantileMarkers(hide = false, yKey, groupKey, yLabels, filteredData) {
            const container = document.getElementById('markerContainer');
            if (!container) return;
            const allMarkers = container.querySelectorAll('.quantile-marker');
            allMarkers.forEach(marker => marker.style.display = 'none'); 
            if (hide || !chart) return;
            yLabels.forEach((yLabel, yIndex) => {
                
                // ** BUG 1 ä¿®æ­£ (ç¬¬äºŒæ¬¡)ï¼šä½¿ç”¨ bar element çš„å±¬æ€§ä¾†å®šä½ **
                // æˆ‘å€‘éœ€è¦ bar element çš„å±¬æ€§ä¾†æ‰¾åˆ°å®ƒçš„åº•éƒ¨é‚Šç·£
                let barProps = null;
                for (let i = 0; i < chart.data.datasets.length; i++) {
                    const meta = chart.getDatasetMeta(i);
                    if (meta && meta.data[yIndex]) {
                        const el = meta.data[yIndex];
                        if (el && !el.hidden && typeof el.getProps === 'function') {
                            // æ‰¾åˆ°äº†ç¬¬ä¸€å€‹å¯è¦‹çš„ barï¼Œå–å¾—å®ƒçš„å±¬æ€§
                            barProps = el.getProps(['y', 'height'], true);
                            break; // æ‰¾åˆ°å°±è·³å‡ºè¿´åœˆ
                        }
                    }
                }

                // å¦‚æœæ²’æœ‰å¯è¦‹çš„ barï¼Œå°±ç„¡æ³•æ”¾ç½® marker
                if (!barProps) return;Â 

                // barProps.y æ˜¯ bar çš„ä¸­å¿ƒ Y è»¸ä½ç½®
                // barProps.height æ˜¯ bar çš„åšåº¦
                const barBottomEdge = barProps.y + (barProps.height / 2);
                // ** BUG 1 ä¿®æ­£çµæŸ **

                let groupData = filteredData
                    .filter(d => String(d[yKey]) === String(yLabel))
                    .map(d => d[groupKey])
                    .filter(val => val !== undefined && val !== null);
                if (groupData.length === 0) return;
                
                // ** ä¿®æ­£ï¼šä½¿ç”¨ .trim() é€²è¡Œæ’åºåˆ—è¡¨æ¯”å° **
                const customOrder = CUSTOM_SORT_ORDERS[groupKey];
                const sortedIndices = Array.from(Array(groupData.length).keys()).sort((a, b) => {
                    if (customOrder) {
                        const getSortIndex = (val) => {
                            const index = customOrder.indexOf(String(val).trim()); // ** Trim here **
                            return index === -1 ? Infinity : index;
                        };
                        return getSortIndex(groupData[a]) - getSortIndex(groupData[b]);
                    }
                    return smartSort(groupData[a], groupData[b]);
                });
                
                const q1Index = sortedIndices[Math.floor(groupData.length * 0.25)];
                const q2Index = sortedIndices[Math.floor(groupData.length * 0.50)];
                const q3Index = sortedIndices[Math.floor(groupData.length * 0.75)];
                const q1Value = groupData[q1Index];
                const q2Value = groupData[q2Index];
                const q3Value = groupData[q3Index];
                const datasets = chart.data.datasets;
                const q1DatasetIndex = datasets.findIndex(ds => String(ds.label) === String(q1Value));
                const q2DatasetIndex = datasets.findIndex(ds => String(ds.label) === String(q2Value));
                const q3DatasetIndex = datasets.findIndex(ds => String(ds.label) === String(q3Value));

                // ** ä¿®æ­£ 2ï¼šç²å–é•·æ¢å€å¡Šçš„ä¸­å¿ƒé» X è»¸ä½ç½® **
                const getXPixel = (targetDatasetIndex) => {
                    if (targetDatasetIndex === -1) return null;
                    const datasetMeta = chart.getDatasetMeta(targetDatasetIndex);
                    if (!datasetMeta || !datasetMeta.data[yIndex]) return null;
                    const dataElement = datasetMeta.data[yIndex];
                    if (dataElement.hidden || !dataElement.getProps) return null; 
                    
                    // å–å¾— bar segment çš„ä¸­å¿ƒé» X è»¸ä½ç½®
                    return dataElement.getCenterPoint().x;
                };
                // ** ä¿®æ­£çµæŸ **

                const xPixels = { q1: getXPixel(q1DatasetIndex), q2: getXPixel(q2DatasetIndex), q3: getXPixel(q3DatasetIndex) };
                ['q1', 'q2', 'q3'].forEach(q => {
                    const markerEl = document.getElementById(`quantileMarker-${yIndex}-${q}`);
                    // ç®­é ­è·é›¢é•·æ¢åº•éƒ¨é‚Šç·£ 4px
                    const markerMargin = 4; 
                    if (markerEl && xPixels[q] !== null) {
                        markerEl.style.left = `${xPixels[q]}px`;
                        // ** é—œéµä¿®æ­£ï¼šä½¿ç”¨ barBottomEdge **
                        markerEl.style.top = `${barBottomEdge + markerMargin}px`; 
                        markerEl.style.display = 'block';
                    }
                });
            });
        }
        function updateAverageLabels(hide = false, yKey, groupKey, yLabels, filteredData) {
            const container = document.getElementById('markerContainer');
            if (!container) return;
            const allLabels = container.querySelectorAll('.average-label');
            allLabels.forEach(label => label.style.display = 'none');
            if (hide || !chart) return;
            yLabels.forEach((yLabel, yIndex) => {
                let numericData = filteredData
                    .filter(d => String(d[yKey]) === String(yLabel))
                    .map(d => parseNumericValue(d[groupKey]))
                    .filter(val => val.isNumeric)
                    .map(val => val.num);
                if (numericData.length === 0) return; 
                const sum = numericData.reduce((a, b) => a + b, 0);
                const average = sum / numericData.length;
                const meta = chart.getDatasetMeta(0); 
                if (!meta || !meta.data[yIndex]) return;
                const element = meta.data[yIndex];
                if (!element || typeof element.getProps !== 'function') return;
                const lastDatasetMeta = chart.getDatasetMeta(chart.data.datasets.length - 1);
                if (!lastDatasetMeta || !lastDatasetMeta.data[yIndex]) return;
                const lastElement = lastDatasetMeta.data[yIndex];
                const props = lastElement.getProps(['x', 'y', 'height'], true);
                const yPixel = props.y; 
                let xPixel = props.x; 
                const valueType = controls.valueSelect.value;
                if(valueType === 'percent') {
                    xPixel = chart.scales.x.getPixelForValue(100);
                }
                const labelEl = document.getElementById(`averageLabel-${yIndex}`);
                if (labelEl) {
                    labelEl.textContent = `${average.toFixed(1)}`; 
                    labelEl.style.left = `${xPixel}px`;
                    labelEl.style.top = `${yPixel}px`;
                    labelEl.style.display = 'block';
                }
            });
        }

        // ** ä¿®æ­£ 3.0: æ›´æ–°ä¸»åœ–è¡¨è¨­å®šçš„å‡½æ•¸ (åŠ å…¥ forceUpdate åƒæ•¸) **
        function updateChartSettings(forceUpdate = false) {
            if (!chart) return;
            
            // ** ä¿®æ­£ 1.1: å¦‚æœç”¨æˆ¶èª¿æ•´äº†è¨­å®šï¼Œæˆ‘å€‘å¼·åˆ¶å°‡è¨­å®šå€¼å¯«å…¥ Options **
            chart.options.scales.y.barPercentage = BAR_PERCENTAGE;
            chart.options.scales.y.categoryPercentage = BAR_CATEGORY_PERCENTAGE;
            chart.options.plugins.datalabels.font.size = DATALABELS_FONT_SIZE;
            
            if (forceUpdate) {
                 // é‡æ–°è§¸ç™¼å®Œæ•´æ›´æ–°ï¼Œé€™æœƒé‡æ–°è¨ˆç®—é«˜åº¦ä¸¦é‡ç¹ª
                 updateChart();
                 updateSankeyChart(); // é‡æ–°ç¹ªè£½ Sankey åœ–
            } else {
                chart.update();
                const yKey = controls.yAxisSelect.value;
                const groupKey = controls.colorBySelect.value;
                // æ³¨æ„ï¼šfilteredData åœ¨é€™è£¡å¯èƒ½ä¸æ˜¯æœ€æ–°çš„ï¼Œä½†æˆ‘å€‘å‡è¨­å®ƒè¶³å¤ ç”¨æ–¼ marker çš„å¤§è‡´å®šä½
                const isGroupKeyNumeric = groupKey !== 'none' && rawData.length > 0 && parseNumericValue(rawData[0][groupKey]).isNumeric; // ç°¡åŒ–åˆ¤æ–·
                setTimeout(() => triggerMarkerUpdates(yKey, groupKey, chart.data.labels, rawData, isGroupKeyNumeric), 50);
            }
        }

        // --- ä¸»æ›´æ–°å‡½æ•¸ (æ¨ç´åˆ†æ) ---
        function updateChart() {
            if (!chart || !controls.yAxisSelect) return;
            isUpdatingFilters = true;

            const yKey = controls.yAxisSelect.value;
            const groupKey = controls.colorBySelect.value;
            const valueType = controls.valueSelect.value;
            updateAnnotations();

            // æŠ“å–ç¯©é¸ (èˆ‡å°åœ–è¡¨å…±ç”¨)
            const activeFilters = getActiveFilters();
            let filteredData = rawData.filter(d => {
                return allColumns.every(key => {
                    const filterValues = activeFilters[key];
                    if (filterValues === undefined) return true;
                    if (filterValues.length === 0) return false;
                    return filterValues.includes(String(d[key]));
                });
            });

            const getSortIndex = (val, customOrder) => {
                const index = customOrder.indexOf(String(val).trim()); // ** ä¿®æ­£ï¼šTrim ç©ºç™½ **
                return index === -1 ? Infinity : index;
            };

            let yLabels = [...new Set(filteredData.map(d => d[yKey]))];
            if (CUSTOM_SORT_ORDERS[yKey]) yLabels.sort((a, b) => getSortIndex(a, CUSTOM_SORT_ORDERS[yKey]) - getSortIndex(b, CUSTOM_SORT_ORDERS[yKey]));
            else yLabels.sort(smartSort);
            chart.data.labels = yLabels;

            let groupLabels;
            let colorMap = {};
            const isPercent = valueType === 'percent';
            
            let isGroupKeyNumeric = false;
            if (groupKey !== 'none' && filteredData.length > 0) {
                const firstValue = filteredData.find(d => d[groupKey] !== null && d[groupKey] !== undefined);
                if(firstValue) {
                    isGroupKeyNumeric = parseNumericValue(firstValue[groupKey]).isNumeric;
                }
            }

            if (groupKey !== 'none') {
                groupLabels = [...new Set(filteredData.map(d => d[groupKey]))];
                if (CUSTOM_SORT_ORDERS[groupKey]) groupLabels.sort((a, b) => getSortIndex(a, CUSTOM_SORT_ORDERS[groupKey]) - getSortIndex(b, CUSTOM_SORT_ORDERS[groupKey]));
                else groupLabels.sort(smartSort);

                // ** ä¿®æ­£ï¼šä½¿ç”¨å›ºå®šé¡è‰²åœ°åœ–å’Œå„ªå…ˆæª¢æŸ¥é‚è¼¯ **
                let activePalette;
                if (isGroupKeyNumeric && groupLabels.length > 3) activePalette = GRADIENT_PALETTE; 
                else activePalette = CATEGORICAL_PALETTE;
                
                let paletteIndex = 0;
                colorMap = {};
                groupLabels.forEach((val) => {
                    const valStr = String(val).trim();
                    const prefix = getQuestionPrefix(groupKey); // <-- å–å¾—é¡Œè™Ÿå‰ç¶´

                    // 1. å„ªå…ˆæª¢æŸ¥ (å•é¡Œå‰ç¶´ + é¸é …å€¼) çš„çµ„åˆ e.g., '6.5_æœ‰'
                    const keyedColor = FIXED_ANSWER_COLORS[prefix + '_' + valStr]; // <-- ä½¿ç”¨å‰ç¶´æŸ¥æ‰¾
                    if (keyedColor) {
                        colorMap[String(val)] = keyedColor;
                    // 2. æ¥è‘—æª¢æŸ¥å–®ç´”çš„é¸é …å€¼
                    } else if (FIXED_ANSWER_COLORS[valStr]) {
                        colorMap[String(val)] = FIXED_ANSWER_COLORS[valStr];
                    } else {
                        // 3. éƒ½ä¸åŒ¹é…æ™‚ï¼Œä½¿ç”¨æ¼¸å±¤æˆ–é¡åˆ¥èª¿è‰²ç›¤
                        colorMap[String(val)] = activePalette[paletteIndex % activePalette.length];
                        paletteIndex++;
                    }
                });
                // ** ä¿®æ­£çµæŸ **

                const totalsPerYLabel = yLabels.map(yVal => {
                    const total = filteredData.filter(d => String(d[yKey]) === String(yVal)).length;
                    return total > 0 ? total : 1;
                });

                chart.data.datasets = groupLabels.map(groupVal => {
                    const dataValues = yLabels.map((yVal, yIdx) => {
                        const count = filteredData.filter(d => String(d[yKey]) === String(yVal) && String(d[groupKey]) === String(groupVal)).length;
                        return isPercent ? (count / totalsPerYLabel[yIdx]) * 100 : count;
                    });
                    const originalLabel = [...new Set(rawData.map(d => d[groupKey]))].find(l => String(l) === String(groupVal)) ?? groupVal;
                    // ** ä¿®æ­£ï¼šä½¿ç”¨ colorMap å–å¾—é¡è‰² **
                    const color = colorMap[String(groupVal)] || CATEGORICAL_PALETTE[0]; 
                    return { 
                        label: originalLabel, 
                        data: dataValues, 
                        backgroundColor: color + 'CC', 
                        borderColor: color, 
                        borderWidth: 0, 
                        borderRadius: 0 
                    };
                });
                
                document.getElementById('yAxisChartTitle').textContent = yKey;
                document.getElementById('cAxisChartTitle').textContent = groupKey;
                
            } else { // ç„¡åˆ†çµ„
                const dataCounts = yLabels.map(yVal => filteredData.filter(d => String(d[yKey]) === String(yVal)).length);
                chart.data.datasets = [{
                    label: 'ç­†æ•¸', data: dataCounts,
                    backgroundColor: CATEGORICAL_PALETTE[0] + 'CC', borderColor: CATEGORICAL_PALETTE[0], 
                    borderWidth: 0, // ** ä¿®æ­£ï¼šç§»é™¤é–“è· **
                    borderRadius: 0 // ** æ–°å¢ï¼šç§»é™¤åœ“è§’ **
                }];
                document.getElementById('yAxisChartTitle').textContent = yKey;
                document.getElementById('cAxisChartTitle').textContent = '';
            }

            // --- æ›´æ–°åœ–è¡¨é¸é … (Xè»¸, Tooltip, Datalabels) ---
            chart.options.plugins.tooltip.callbacks = {
                // ** ä¿®æ­£ 2.1: çªå‡ºé¡¯ç¤ºç•¶å‰ hover çš„ dataset **
                label: function(context) {
                    let label = context.dataset.label || '';
                    const rawCount = filteredData.filter(d => 
                        String(d[yKey]) === String(chart.data.labels[context.dataIndex]) && 
                        String(d[groupKey]) === String(context.dataset.label)
                    ).length;

                    if (label) {
                        label += ': ';
                    } else {
                        label = 'ç­†æ•¸: ';
                    }

                    if (isPercent) {
                        label += context.parsed.x !== null ? context.parsed.x.toFixed(1) + '%' : 'N/A';
                        label += ` (${rawCount}ç­†)`;
                    } else {
                        label += context.parsed.x !== null ? context.parsed.x : 'N/A';
                    }
                    return label;
                },
                // ** æ–°å¢ footer: é¡¯ç¤ºç•¶å‰ hover çš„ç¸½æ•¸å’Œç™¾åˆ†æ¯” **
                footer: function(context) {
                    const yValue = chart.data.labels[context[0].dataIndex];
                    const total = filteredData.filter(d => String(d[yKey]) === String(yValue)).length;
                    const totalText = total > 0 ? `ç¸½è¨ˆ: ${total} ç­†` : 'ç¸½è¨ˆ: N/A';
                    return totalText;
                }
            };
            
            // ** ä¿®æ­£ 2.2: çªå‡ºé¡¯ç¤º hover çš„ bar **
            chart.options.plugins.tooltip.backgroundColor = 'rgba(0, 0, 0, 0.8)';
            chart.options.plugins.tooltip.titleFont = { weight: 'bold', size: 14 }; // ç¢ºä¿æ¨™é¡Œç²—é«”
            chart.options.plugins.tooltip.footerFont = { weight: 'bold', size: 12 };
            chart.options.plugins.tooltip.mode = 'nearest'; // ç¢ºä¿èƒ½æŠ“åˆ°å–®ç¨çš„ bar
            chart.options.plugins.tooltip.position = 'nearest'; 


            if (isPercent) {
                chart.options.scales.x.max = 100;
                chart.options.scales.x.title.text = 'å„åˆ—ä½”æ¯” (%)';
                chart.options.plugins.datalabels.display = true;
                // ** ä¿®æ­£ 3.1: ä½¿ç”¨å…¨å±€è¨­å®šçš„å­—é«”å¤§å° **
                chart.options.plugins.datalabels.font.size = DATALABELS_FONT_SIZE;
                chart.options.plugins.datalabels.formatter = (value) => value > 5 ? Math.round(value) + '%' : '';
            } else { // ç­†æ•¸æ¨¡å¼
                chart.options.scales.x.max = undefined;
                chart.options.scales.x.title.text = 'ç­†æ•¸ (Count)';
                chart.options.plugins.datalabels.display = false;
            }
            
            // ** ä¿®æ­£ 1.1: å¥—ç”¨é•·æ¢ç²—åº¦è¨­å®š (Pivot) **
            chart.options.scales.y.barPercentage = BAR_PERCENTAGE;
            chart.options.scales.y.categoryPercentage = BAR_CATEGORY_PERCENTAGE;
            chart.options.plugins.datalabels.font.size = DATALABELS_FONT_SIZE; // ç¢ºä¿ datalabels size ä¹ŸåŒæ­¥

            // --- å‹•æ…‹èª¿æ•´åœ–è¡¨é«˜åº¦ ---
            const chartContainer = document.querySelector('.chart-container');
            const heightPerLabel = 30;
            // ** ä¿®æ­£ 1.2: è€ƒæ…® BAR_CATEGORY_PERCENTAGE ä¾†èª¿æ•´é«˜åº¦ **
            const adjustedHeightPerLabel = heightPerLabel * BAR_CATEGORY_PERCENTAGE;
            const baseHeight = 150;
            const newHeight = baseHeight + yLabels.length * adjustedHeightPerLabel;
            const finalHeight = Math.min(Math.max(newHeight, 350), 8000); // æœ€å°é«˜åº¦é™ä½
            chartContainer.style.height = `${finalHeight}px`;
            if (chart) chart.resize();

            // --- æ›´æ–°åœ–ä¾‹ ---
            const legendContainer = document.getElementById('customLegend');
            const arrowSelectContainer = document.getElementById('arrowSelectContainer');
            if (groupKey !== 'none') {
                let legendHTML = '';
                chart.data.datasets.forEach((dataset, index) => {
                    const label = dataset.label;
                    const color = dataset.borderColor || dataset.backgroundColor;
                    const isHidden = dataset.hidden || false;
                    legendHTML += `<div class="flex items-center legend-item ${isHidden ? 'legend-item-hidden' : ''}" data-label="${label}" data-dataset-index="${index}">
                                     <span class="w-3 h-3 mr-1" style="background-color: ${color}; border-radius: 2px;"></span>
                                     <span class="text-sm text-gray-700">${label}</span>
                                   </div>`;
                });
                legendContainer.innerHTML = legendHTML;
                legendContainer.querySelectorAll('.legend-item').forEach(item => {
                    item.addEventListener('click', () => {
                        const datasetIndex = parseInt(item.getAttribute('data-dataset-index'));
                        if (!chart || isNaN(datasetIndex) || datasetIndex < 0 || datasetIndex >= chart.data.datasets.length) return;
                        chart.data.datasets[datasetIndex].hidden = !chart.data.datasets[datasetIndex].hidden;
                        item.classList.toggle('legend-item-hidden', chart.data.datasets[datasetIndex].hidden);
                        chart.update();
                        setTimeout(() => triggerMarkerUpdates(yKey, groupKey, yLabels, filteredData, isGroupKeyNumeric), 10);
                    });
                });
                controls.arrowSelect.innerHTML = '<option value="">è«‹é¸æ“‡</option>';
                groupLabels.forEach(label => controls.arrowSelect.innerHTML += `<option value="${label}">${label}</option>`);
                arrowSelectContainer.classList.remove('hidden'); 
            } else { 
                legendContainer.innerHTML = '';
                arrowSelectContainer.classList.add('hidden');
                controls.arrowSelect.value = "";
            }

            // --- æ›´æ–°ç¯©é¸å™¨ç‹€æ…‹ ---
            updateFilterActiveStates();

            // --- æ›´æ–°åœ–è¡¨èˆ‡æ¨™è¨˜ ---
            chart.update();
            createOrUpdateArrows(yLabels.length);
            createOrUpdateQuantileMarkers(yLabels.length);
            createOrUpdateAverageLabels(yLabels.length);
            setTimeout(() => {
                triggerMarkerUpdates(yKey, groupKey, yLabels, filteredData, isGroupKeyNumeric);
            }, 50); 
            isUpdatingFilters = false;
        }
        
        // --- æå–ç¯©é¸å™¨ç‹€æ…‹ (é€šç”¨å‡½æ•¸) ---
        function getActiveFilters() {
            const activeFilters = {};
            allColumns.forEach(catKey => {
                const panel = document.getElementById(`filter-${catKey}-panel`);
                if (panel) {
                    const checkedCbs = panel.querySelectorAll('input:checked');
                    activeFilters[catKey] = Array.from(checkedCbs).map(cb => cb.value);
                }
            });
            return activeFilters;
        }
        
        // --- æ›´æ–°ç¯©é¸å™¨è¦–è¦ºç‹€æ…‹ (é€šç”¨å‡½æ•¸) ---
        function updateFilterActiveStates() {
            allColumns.forEach(catKey => {
                const panel = document.getElementById(`filter-${catKey}-panel`);
                if (!panel) return;
                const summary = panel.closest('.filter-dropdown').querySelector('summary');
                if (!summary) return;
                const allCheckboxes = panel.querySelectorAll('input[type="checkbox"].filter-checkbox');
                const checkedCheckboxes = panel.querySelectorAll('input[type="checkbox"].filter-checkbox:checked');
                if (allCheckboxes.length > 0) {
                    const isFiltered = checkedCheckboxes.length < allCheckboxes.length;
                    summary.classList.toggle('filter-active', isFiltered);
                } else {
                    summary.classList.remove('filter-active');
                }
            });
        }
        
        // --- ä¸»æ¨™è¨˜è§¸ç™¼ (æ¨ç´åˆ†æ) ---
        function triggerMarkerUpdates(yKey, groupKey, yLabels, filteredData, isGroupKeyNumeric) {
            // ** ä¿®æ­£ï¼šå¾ controls é‡æ–°ç²å– valueType **
            const valueType = controls.valueSelect.value;
            const hideQuantiles = valueType === 'percent' || groupKey === 'none' || !isGroupKeyNumeric;
            const hideAverage = groupKey === 'none' || !isGroupKeyNumeric;
            
            updateArrowPosition(false);
            updateQuantileMarkers(hideQuantiles, yKey, groupKey, yLabels, filteredData);
            updateAverageLabels(hideAverage, yKey, groupKey, yLabels, filteredData);
        }

        // å»ºç«‹åœ–è¡¨ (åªåŸ·è¡Œä¸€æ¬¡)
        function createChart() {
            const ctx = document.getElementById('mainChart').getContext('2d');
            chart = new Chart(ctx, {
                type: 'bar',
                data: { labels: [], datasets: [] },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: { padding: { top: 20 } },
                    scales: {
                        x: { stacked: true, title: { display: true, text: 'ç­†æ•¸ (Count)', font: { size: 14 } } },
                        y: { 
                            stacked: true, 
                            ticks: { autoSkip: false },
                            barPercentage: BAR_PERCENTAGE,  // ** ä½¿ç”¨å…¨å±€è®Šæ•¸ **
                            categoryPercentage: BAR_CATEGORY_PERCENTAGE // ** ä½¿ç”¨å…¨å±€è®Šæ•¸ **
                        }
                    },
                    plugins: {
                        datalabels: { 
                            display: false, 
                            color: '#333', 
                            font: { weight: 'bold', size: DATALABELS_FONT_SIZE } // ** ä½¿ç”¨å…¨å±€è®Šæ•¸ **
                        },
                        tooltip: { 
                            enabled: true, 
                            mode: 'index', 
                            intersect: false,
                            // ** ä¿®æ­£ Tooltip é¡¯ç¤º **
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleFont: { weight: 'bold', size: 14 }, 
                            footerFont: { weight: 'bold', size: 12 },
                            mode: 'nearest', 
                            position: 'nearest' 
                        },
                        legend: { display: false }
                    }
                }
            });
            
            // ** ä¿®æ­£ Q1ï¼šä¿®æ”¹ Resize äº‹ä»¶ **
            window.addEventListener('resize', debounce(() => {
                // å®Œæ•´é‡ç¹ªï¼Œæ‰èƒ½åœ¨ Zoom ä¹‹å¾Œæ­£ç¢ºå®šç‚º
                updateChart();
                updateSankeyChart(); // ç¸®æ”¾æ™‚é‡ç¹ª Sankey
                updateSmallMultiples();
            }, 250));
        }
        
        // ===============================================
        // == æ¡‘åŸºåœ– (Sankey Diagram) å‡½æ•¸ (æ–°å¢/æ›¿æ›) ==
        // ===============================================
        
        // ** Helper for Sankey Color **
        const getColorForValue = (value, key) => {
                const valStr = String(value).trim();
                const prefix = getQuestionPrefix(key);
                
                // 1. å„ªå…ˆæª¢æŸ¥ (å•é¡Œå‰ç¶´ + é¸é …å€¼) çš„çµ„åˆ e.g., '6.5_æœ‰'
                const keyedColor = FIXED_ANSWER_COLORS[prefix + '_' + valStr];
                if (keyedColor) return keyedColor;
                
                // 2. æ¥è‘—æª¢æŸ¥å–®ç´”çš„é¸é …å€¼
                if (FIXED_ANSWER_COLORS[valStr]) return FIXED_ANSWER_COLORS[valStr];

                // 3. éƒ½ä¸åŒ¹é…æ™‚ï¼Œä½¿ç”¨é€šç”¨èª¿è‰²ç›¤
                const uniqueValues = [...new Set(rawData.map(d => String(d[key]).trim()))];
                const categoryIndex = uniqueValues.indexOf(valStr);
                return CATEGORICAL_PALETTE[categoryIndex % CATEGORICAL_PALETTE.length];
        };
        
        function generateSankeyLegend(nodes, key, isSource) {
            const legendContainer = document.getElementById(isSource ? 'sankeySourceLegend' : 'sankeyTargetLegend');
            const legendTitle = document.getElementById(isSource ? 'sourceLegendTitle' : 'targetLegendTitle');
            
            // v8 ä¿®æ­£ï¼šç¢ºä¿ DOM å…ƒç´ å­˜åœ¨
            if (!legendContainer || !legendTitle) {
                console.error("Sankey legend container or title not found.");
                return;
            }

            // v8 ä¿®æ­£ï¼šçµ•å°ç¢ºä¿ itemsContainer å­˜åœ¨
            let itemsContainer = legendContainer.querySelector('.sankey-legend-items-wrapper');
            if (!itemsContainer) {
                itemsContainer = document.createElement('div');
                // ä¿®æ­£ 2.3: èª¿æ•´ itemsContainer çš„ flex wrap å’Œå°é½Šæ–¹å¼
                itemsContainer.className = `sankey-legend-items-wrapper flex flex-wrap gap-x-4 gap-y-1 ${isSource ? 'justify-start' : 'md:justify-end'}`;
                // ä¿®æ­£ 2.5: ç¢ºä¿ç§»é™¤ä»»ä½•èˆŠçš„ no-data æç¤º
                const oldNoData = legendContainer.querySelector('.sankey-no-data');
                if (oldNoData) oldNoData.remove();
                legendTitle.after(itemsContainer);
            }
            
            itemsContainer.innerHTML = ''; 

            // ä¿®æ­£ 2.1: æ¨™é¡Œä½¿ç”¨å•é¡Œåç¨±
            legendTitle.textContent = `${QUESTION_MAP[key] || key} åœ–ä¾‹ (${isSource ? 'ä¾†æº' : 'ç›®æ¨™'})`;

            const getSortIndex = (val, customOrder) => {
                const index = customOrder.indexOf(String(val).trim());
                return index === -1 ? Infinity : index;
            };
            const customOrder = CUSTOM_SORT_ORDERS[key];
            const sortedNodes = [...nodes].sort((a, b) => {
                const valA = a.name.split(': ')[1];
                const valB = b.name.split(': ')[1];
                
                // ç¢ºä¿æ’åºåªåœ¨è©²å´ç¯€é»ä¸Šé€²è¡Œ
                if (a.category !== (isSource ? 'Source' : 'Target') && b.category !== (isSource ? 'Source' : 'Target')) return 0;
                
                if (customOrder) {
                    return getSortIndex(valA, customOrder) - getSortIndex(valB, customOrder);
                }
                return smartSort(valA, valB);
            });

            // éæ¿¾ä¸¦å–å¾—è©²å´ç¯€é»
            const sideNodes = sortedNodes.filter(d => d.category === (isSource ? 'Source' : 'Target'));
            
            if (sideNodes.length === 0) {
                 const p = document.createElement('p');
                 p.className = 'text-gray-400 sankey-no-data';
                 p.textContent = 'ç„¡åœ–ä¾‹è³‡æ–™ã€‚';
                 itemsContainer.appendChild(p);
                 return;
            }
            
            sideNodes.forEach(node => {
                const value = node.name.split(': ')[1];
                // ä¿®æ­£ 2.4: å‚³å…¥å•é¡Œéµ keyï¼Œç¢ºä¿ getColorForValue ä½¿ç”¨æ­£ç¢ºçš„å‰ç¶´æŸ¥æ‰¾
                const color = getColorForValue(value, key); 
                
                const itemDiv = document.createElement('div');
                // ä¿®æ­£ 2.5: ç¢ºä¿å°é½Šæ–¹å¼
                itemDiv.className = `flex items-center sankey-legend-item ${isSource ? 'justify-start' : 'md:justify-end'}`;
                
                const textSpan = document.createElement('span');
                textSpan.textContent = `${value}`;
                textSpan.className = 'text-sm';

                const colorBlock = `<span class="w-3 h-3 mx-1 flex-shrink-0" style="background-color: ${color}; border-radius: 2px;"></span>`;

                if (isSource) {
                    itemDiv.innerHTML = colorBlock + textSpan.outerHTML;
                } else {
                    itemDiv.innerHTML = textSpan.outerHTML + colorBlock;
                }
                
                itemsContainer.appendChild(itemDiv);
            });
        }
        
        function updateSankeyChart() {
            const sourceKey = controls.sankeySourceSelect.value;
            const targetKey = controls.sankeyTargetSelect.value;
            const minThreshold = parseInt(document.getElementById('sankeyMinThreshold').value) || 1;
            const sankeyContainer = d3.select("#sankeyChart");
            
            sankeyContainer.html(""); // æ¸…é™¤èˆŠåœ–è¡¨

            const sourceLegendContainer = document.getElementById('sankeySourceLegend');
            const targetLegendContainer = document.getElementById('sankeyTargetLegend');
            
            // æ¸…ç†èˆŠçš„ no-data æ¨™ç±¤
            if (sourceLegendContainer) sourceLegendContainer.querySelector('.sankey-no-data')?.remove();
            if (targetLegendContainer) targetLegendContainer.querySelector('.sankey-no-data')?.remove();

            if (!sourceKey || !targetKey || sourceKey === targetKey) {
                sankeyContainer.html('<p class="text-gray-500 text-center py-8">è«‹é¸æ“‡ä¸åŒçš„ã€Œä¾†æºã€å’Œã€Œç›®æ¨™ã€æ¬„ä½ã€‚</p>');
                // æ¸…ç©ºåœ–ä¾‹
                if (sourceLegendContainer) sourceLegendContainer.querySelector('.sankey-legend-items-wrapper')?.remove();
                if (targetLegendContainer) targetLegendContainer.querySelector('.sankey-legend-items-wrapper')?.remove();
                document.getElementById('sourceLegendTitle').textContent = 'ä¾†æºåœ–ä¾‹ (Source)';
                document.getElementById('targetLegendTitle').textContent = 'ç›®æ¨™åœ–ä¾‹ (Target)';
                return;
            }

            const activeFilters = getActiveFilters();
            let filteredData = rawData.filter(d => {
                return allColumns.every(key => {
                    const filterValues = activeFilters[key];
                    if (filterValues === undefined) return true;
                    if (filterValues.length === 0) return false;
                    return filterValues.includes(String(d[key]));
                });
            });

            if (filteredData.length === 0) {
                 sankeyContainer.html('<p class="text-red-500 text-center py-8">åœ¨ç•¶å‰ç¯©é¸æ¢ä»¶ä¸‹ï¼Œç„¡è³‡æ–™å¯ä¾›åˆ†æã€‚</p>');
                 if (sourceLegendContainer) sourceLegendContainer.querySelector('.sankey-legend-items-wrapper')?.remove();
                 if (targetLegendContainer) targetLegendContainer.querySelector('.sankey-legend-items-wrapper')?.remove();
                 document.getElementById('sourceLegendTitle').textContent = 'ä¾†æºåœ–ä¾‹ (Source)';
                 document.getElementById('targetLegendTitle').textContent = 'ç›®æ¨™åœ–ä¾‹ (Target)';
                 return;
            }

            const linkCounts = new Map();
            const allNodes = new Set();
            
            filteredData.forEach(d => {
                const sourceVal = String(d[sourceKey]).trim();
                const targetVal = String(d[targetKey]).trim();
                
                if (sourceVal && targetVal) {
                    const linkId = `${sourceVal}->${targetVal}`;
                    linkCounts.set(linkId, (linkCounts.get(linkId) || 0) + 1);
                    allNodes.add(`Source: ${sourceVal}`);
                    allNodes.add(`Target: ${targetVal}`);
                }
            });

            const nodeMap = new Map();
            const nodes = Array.from(allNodes).map((name, index) => {
                const node = { id: index, name: name, category: name.split(': ')[0], value: 0 };
                nodeMap.set(name, node);
                return node;
            });

            const links = [];
            linkCounts.forEach((count, linkId) => {
                if (count >= minThreshold) {
                    const [sourceVal, targetVal] = linkId.split('->');
                    const sourceName = `Source: ${sourceVal}`;
                    const targetName = `Target: ${targetVal}`;
                    
                    if (nodeMap.has(sourceName) && nodeMap.has(targetName)) {
                        links.push({
                            source: nodeMap.get(sourceName).id,
                            target: nodeMap.get(targetName).id,
                            value: count,
                            sourceLabel: sourceVal,
                            targetLabel: targetVal
                        });
                    }
                }
            });

            const graph = { nodes, links };
            
            const margin = { top: 10, right: 10, bottom: 10, left: 10 };
            const containerEl = document.getElementById('sankeyChart');
            const availableWidth = containerEl.clientWidth;
            const innerWidth = availableWidth - margin.left - margin.right;
            const height = Math.min(nodes.length * 25 + 100, 600) - margin.top - margin.bottom; 
            
            const svgWidth = availableWidth; 
            const svgHeight = height + margin.top + margin.bottom;

            const svg = sankeyContainer.append("svg")
                .attr("width", svgWidth) 
                .attr("height", svgHeight)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            // *** é—œéµä¿®æ­£ 1: æ‡‰ç”¨è‡ªå®šç¾©æ’åº ***
            const getSortIndex = (val, customOrder) => {
                const index = customOrder.indexOf(String(val).trim());
                return index === -1 ? Infinity : index;
            };

            const sortNodesByCustomOrder = (a, b) => {
                const aName = a.name.split(': ')[1];
                const bName = b.name.split(': ')[1];
                const key = a.category === 'Source' ? sourceKey : targetKey;
                const customOrder = CUSTOM_SORT_ORDERS[key];

                if (customOrder) {
                    return getSortIndex(aName, customOrder) - getSortIndex(bName, customOrder);
                }
                // å¦‚æœæ²’æœ‰è‡ªå®šç¾©æ’åºï¼Œå‰‡ä½¿ç”¨é»˜èªçš„æ™ºèƒ½æ’åº (smartSort)
                return smartSort(aName, bName);
            };

            const sankey = d3.sankey()
                .nodeWidth(15)
                .nodePadding(10)
                .extent([[0, 0], [innerWidth, height]])
                .nodeSort(sortNodesByCustomOrder); // <-- æ‡‰ç”¨è‡ªå®šç¾©æ’åº

            sankey(graph);
            
            svg.append("g")
                .attr("fill", "none")
                .selectAll(".sankey-link")
                .data(graph.links)
                .join("path")
                .attr("class", "sankey-link")
                .attr("d", d3.sankeyLinkHorizontal())
                .attr("stroke-width", d => Math.max(1, d.width))
                .attr("stroke", d => getColorForValue(d.sourceLabel, sourceKey))
                .append("title")
                .text(d => `${d.sourceLabel} â†’ ${d.targetLabel}\nç­†æ•¸: ${d.value}`);

            const node = svg.append("g")
                .selectAll(".sankey-node")
                .data(graph.nodes)
                .join("g")
                .attr("class", "sankey-node")
                .attr("transform", d => `translate(${d.x0},${d.y0})`);

            node.append("rect")
                .attr("height", d => d.y1 - d.y0)
                .attr("width", sankey.nodeWidth())
                .attr("rx", 4)
                .attr("ry", 4)
                .attr("fill", d => {
                    const value = d.name.split(': ')[1];
                    const isSourceNode = d.category === 'Source';
                    return getColorForValue(value, isSourceNode ? sourceKey : targetKey);
                })
                .each(function(d) {
                    // ä¿®æ­£ 4ï¼šè¨ˆç®—ç¯€é»çš„ç¸½å€¼ (ç”¨æ–¼åœ–ä¾‹)
                    d.value = d.sourceLinks.reduce((sum, link) => sum + link.value, 0) || d.targetLinks.reduce((sum, link) => sum + link.value, 0);
                })
                .append("title")
                .text(d => {
                    const val = d.sourceLinks.reduce((sum, link) => sum + link.value, 0) || d.targetLinks.reduce((sum, link) => sum + link.value, 0);
                    return `${d.name.split(': ')[1]}\nç¸½ç­†æ•¸: ${val}`
                });

            // 7. ç§»é™¤ D3 æ¨™ç±¤ä¸¦ç”Ÿæˆè‡ªè¨‚åœ–ä¾‹ (Legend)
            if (links.length > 0) {
                 generateSankeyLegend(graph.nodes, sourceKey, true); 
                 generateSankeyLegend(graph.nodes, targetKey, false);
            } else {
                if (sourceLegendContainer) sourceLegendContainer.querySelector('.sankey-legend-items-wrapper')?.remove();
                if (targetLegendContainer) targetLegendContainer.querySelector('.sankey-legend-items-wrapper')?.remove();
                
                const sourceP = document.createElement('p');
                sourceP.className = 'text-gray-400 sankey-no-data';
                sourceP.textContent = 'ç„¡é€£çµè³‡æ–™ã€‚';
                
                const targetP = document.createElement('p');
                targetP.className = 'text-gray-400 sankey-no-data md:text-right';
                targetP.textContent = 'ç„¡é€£çµè³‡æ–™ã€‚';
                
                // ç¢ºä¿æ¨™é¡Œå­˜åœ¨æ‰ append
                const sourceTitle = document.getElementById('sourceLegendTitle');
                const targetTitle = document.getElementById('targetLegendTitle');

                if (sourceTitle) sourceTitle.after(sourceP);
                if (targetTitle) targetTitle.after(targetP);

                document.getElementById('sourceLegendTitle').textContent = `${QUESTION_MAP[sourceKey] || sourceKey} åœ–ä¾‹ (ä¾†æº)`;
                document.getElementById('targetLegendTitle').textContent = `${QUESTION_MAP[targetKey] || targetKey} åœ–ä¾‹ (ç›®æ¨™)`;
            }
        }


        // ===============================================
        // == å–®ä¸€æ¬„ä½åˆ†æ (å„€è¡¨æ¿) å‡½æ•¸ ==
        // ===============================================

        // ** ä¿®æ­£ 3.0: æ›´æ–°æ‰€æœ‰å°åœ–è¡¨è¨­å®šçš„å‡½æ•¸ (åŠ å…¥ forceUpdate åƒæ•¸) **
        function updateSmallMultiplesSettings(forceUpdate = false) {
            // ** ä¿®æ­£ 1: ç¢ºä¿æ‰€æœ‰é¸é …åœ¨ Chart.js å¯¦ä¾‹ä¸Šè¢«æ›´æ–° **
            Object.values(smallCharts).forEach(chartInstance => {
                chartInstance.options.scales.y.barPercentage = BAR_PERCENTAGE;
                chartInstance.options.scales.y.categoryPercentage = BAR_CATEGORY_PERCENTAGE;
                chartInstance.options.plugins.datalabels.font.size = DATALABELS_FONT_SIZE;
                chartInstance.update('none'); // å¼ºåˆ¶æ›´æ–°è§†å›¾
            });
            
            // ** ä¿®æ­£ 4.1: å¦‚æœæ˜¯ BAR ç²—åº¦èª¿æ•´ï¼Œéœ€è¦é‡æ–°å‰µå»º/ç¹ªè£½åœ–è¡¨å®¹å™¨ **
            if (forceUpdate) {
                // é‡æ–°èª¿ç”¨ updateSmallMultiples é‡æ–°ç¹ªè£½æ•´å€‹å€å¡Šï¼Œ
                // é€™æœƒé‡æ–°è¨ˆç®—æ¯å€‹å°åœ–è¡¨çš„ wrapperHeightã€‚
                updateSmallMultiples();
                return;
            }
        }
        
        function updateSmallMultiples() {
            const container = document.getElementById('smallMultiplesContainer');
            const selectedColumns = Array.from(document.querySelectorAll('.small-multiple-checkbox:checked')).map(cb => cb.value);
            // ** ä¿®æ­£ 2ï¼šè®€å–ç¨ç«‹çš„ valueSelect **
            const valueType = controls.smallValueSelect.value;
            const isPercent = valueType === 'percent';

            // æŠ“å–å…±ç”¨ç¯©é¸
            const activeFilters = getActiveFilters();
            let filteredData = rawData.filter(d => {
                return allColumns.every(key => {
                    const filterValues = activeFilters[key];
                    if (filterValues === undefined) return true;
                    if (filterValues.length === 0) return false;
                    return filterValues.includes(String(d[key]));
                });
            });

            // æ‘§æ¯€èˆŠåœ–è¡¨
            Object.values(smallCharts).forEach(chart => chart.destroy());
            smallCharts = {};
            container.innerHTML = '';

            if (selectedColumns.length === 0) {
                container.innerHTML = '<p class="text-gray-500">è«‹å¾ä¸Šæ–¹å‹¾é¸æ¬„ä½ä»¥é¡¯ç¤ºåˆ†æåœ–è¡¨ã€‚</p>';
                return;
            }
            
            const getSortIndex = (val, customOrder) => {
                const index = customOrder.indexOf(String(val).trim()); // ** ä¿®æ­£ï¼šTrim ç©ºç™½ **
                return index === -1 ? Infinity : index;
            };
            
            // ** ä¿®æ­£ 5.0: èª¿æ•´æ¯å€‹å°åœ–è¡¨çš„é«˜åº¦ï¼Œä½¿å…¶æ›´ç·Šæ¹Š **
            const singleBarHeight = 100 * BAR_CATEGORY_PERCENTAGE; // æ ¹æ“šç²—åº¦èª¿æ•´ Bar å€åŸŸé«˜åº¦
            const chartAreaHeight = Math.max(singleBarHeight, 20); // åœ–è¡¨å€åŸŸçš„æœ€å°é«˜åº¦
            // æ•´é«” wrapper çš„é«˜åº¦ = åœ–è¡¨å€ + Xè»¸åˆ»åº¦ (35px) + ä¸Šä¸‹ padding/margin (5px)
            const headerHeight = 30; // ç‚ºæ¨™é¡Œå’Œåœ–ä¾‹é ç•™ 30px çš„ç©ºé–“
            const wrapperHeight = chartAreaHeight + 35 + 5 + headerHeight; 

            // ç‚ºæ¯ä¸€å€‹å‹¾é¸çš„æ¬„ä½å»ºç«‹ä¸€å€‹åœ–è¡¨
            selectedColumns.forEach((colKey, index) => {
                const chartId = `smallChart-${index}`;
                const legendId = `smallLegend-${index}`;
                const avgId = `smallAvg-${index}`;

                // 2. æº–å‚™è³‡æ–™
                const yLabels = [colKey]; 
                let groupLabels = [...new Set(filteredData.map(d => d[colKey]))];
                
                if (CUSTOM_SORT_ORDERS[colKey]) groupLabels.sort((a, b) => getSortIndex(a, CUSTOM_SORT_ORDERS[colKey]) - getSortIndex(b, CUSTOM_SORT_ORDERS[colKey]));
                else groupLabels.sort(smartSort);

                let isGroupKeyNumeric = false;
                if (filteredData.length > 0) {
                    const firstValue = filteredData.find(d => d[colKey] !== null && d[colKey] !== undefined);
                    if(firstValue) isGroupKeyNumeric = parseNumericValue(firstValue[colKey]).isNumeric;
                }

                // ** é¡è‰²æ˜ å°„é‚è¼¯ (èˆ‡ä¸»åœ–è¡¨ä¸€è‡´) **
                let activePalette;
                if (isGroupKeyNumeric && groupLabels.length > 3) activePalette = GRADIENT_PALETTE; 
                else activePalette = CATEGORICAL_PALETTE;
                
                let colorMap = {};
                let paletteIndex = 0;
                groupLabels.forEach((val) => {
                    const valStr = String(val).trim();
                    const prefix = getQuestionPrefix(colKey);
                    
                    const keyedColor = FIXED_ANSWER_COLORS[prefix + '_' + valStr]; 
                    if (keyedColor) {
                        colorMap[String(val)] = keyedColor;
                    } else if (FIXED_ANSWER_COLORS[valStr]) {
                        colorMap[String(val)] = FIXED_ANSWER_COLORS[valStr];
                    } else {
                        colorMap[String(val)] = activePalette[paletteIndex % activePalette.length]; 
                        paletteIndex++;
                    }
                });

                const total = filteredData.filter(d => d[colKey] !== undefined && d[colKey] !== null).length;
                const totalForPercent = total > 0 ? total : 1;
                
                const datasets = groupLabels.map(groupVal => {
                    const count = filteredData.filter(d => String(d[colKey]) === String(groupVal)).length;
                    const dataValue = isPercent ? (count / totalForPercent) * 100 : count;
                    const color = colorMap[String(groupVal)] || CATEGORICAL_PALETTE[0]; 
                    return {
                        label: groupVal,
                        data: [dataValue], // åªæœ‰ä¸€ç­†è³‡æ–™
                        backgroundColor: color + 'CC', 
                        borderColor: color, 
                        borderWidth: 0, 
                        borderRadius: 0, 
                        rawCount: count // å„²å­˜åŸå§‹ç­†æ•¸çµ¦ tooltip
                    };
                });


                // 1. å»ºç«‹ HTML çµæ§‹ (å„ªåŒ–æ’ç‰ˆ)
                const chartWrapper = document.createElement('div');
                chartWrapper.className = 'bg-white pt-2 pb-1 px-4'; // æ¸›å°‘å‚ç›´ padding
                if (index > 0) {
                    chartWrapper.className += ' border-t border-gray-200'; 
                }
                
                // æ¨™é¡Œ/å¹³å‡æ•¸/åœ–ä¾‹ æ•´åˆåœ¨ä¸€å€‹ flex å®¹å™¨ä¸­
                chartWrapper.innerHTML = `
                    <div class="small-chart-header flex justify-between items-start pt-1">
                        <div class="flex items-baseline space-x-2">
                            <h3 class="text-base font-bold text-gray-800 leading-none">${colKey}</h3>
                            <span id="${avgId}" class="text-sm font-medium text-blue-700 leading-none"></span>
                        </div>
                        <div id="${legendId}" class="flex flex-wrap gap-x-2 gap-y-0.5 justify-end"></div>
                    </div>
                    <!-- ä¿®æ­£ï¼šå°‡ chartAreaHeight å¯«å…¥ï¼Œç¢ºä¿é«˜åº¦ç·Šæ¹Š -->
                    <div class="small-chart-container" style="height: ${wrapperHeight}px;">
                        <canvas id="${chartId}"></canvas>
                    </div>
                `;
                container.appendChild(chartWrapper);

                // 3. å»ºç«‹æ–°åœ–è¡¨ (é•·æ¢åœ–)
                const ctx = document.getElementById(chartId).getContext('2d');
                smallCharts[chartId] = new Chart(ctx, {
                    type: 'bar', 
                    data: { 
                        labels: yLabels, 
                        datasets: datasets 
                    },
                    options: {
                        indexAxis: 'y', 
                        responsive: true,
                        maintainAspectRatio: false,
                        layout: { 
                            padding: { left: -10 } // éš±è— Y è»¸æ¨™ç±¤
                        }, 
                        scales: {
                            x: {
                                display: true,
                                stacked: true,
                                max: isPercent ? 100 : undefined,
                                // ä¿®æ­£ 2.1: éš±è— X è»¸æ¨™é¡Œï¼Œä½†é¡¯ç¤ºåˆ»åº¦æ•¸å­— (ticks)
                                ticks: {
                                    display: true, 
                                    font: { size: 10 }
                                },
                                title: { 
                                    display: false // éš±è—è»¸æ¨™é¡Œ
                                }
                            },
                            y: {
                                stacked: true,
                                display: false, // éš±è— Y è»¸
                                barPercentage: BAR_PERCENTAGE, 
                                categoryPercentage: BAR_CATEGORY_PERCENTAGE 
                            }
                        },
                        plugins: {
                            datalabels: {
                                display: true, 
                                color: '#fff',
                                textShadow: '0 1px 2px rgba(0,0,0,0.4)',
                                font: { weight: 'bold', size: DATALABELS_FONT_SIZE },
                                formatter: (value, context) => {
                                    if (value === 0) return ''; 
                                    
                                    if (isPercent) {
                                        if (value < 8) return ''; 
                                        return Math.round(value) + '%';
                                    } else {
                                        const allData = context.chart.data.datasets.map(ds => ds.data[0]);
                                        const total = allData.reduce((sum, val) => sum + val, 0);
                                        if (total > 0 && (value / total) < 0.08) return ''; 
                                        return value; 
                                    }
                                }
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (label) label += ': ';
                                        const rawCount = context.dataset.rawCount || 0;
                                        if (isPercent) {
                                            if (context.parsed.x !== null) label += context.parsed.x.toFixed(1) + '%';
                                            label += ` (${rawCount}ç­†)`;
                                        } else {
                                            if (context.parsed.x !== null) label += context.parsed.x;
                                        }
                                        return label;
                                    }
                                }
                            },
                            legend: { display: false } // ä½¿ç”¨è‡ªè¨‚åœ–ä¾‹
                        }
                    }
                });

                // 4. å¡«å…¥åœ–ä¾‹
                const legendContainer = document.getElementById(legendId);
                let legendHTML = '';
                datasets.forEach((dataset) => { 
                    const label = dataset.label;
                    const color = dataset.borderColor;
                    legendHTML += `<div class="flex items-center legend-item">
                                     <span class="w-3 h-3 mr-1 flex-shrink-0" style="background-color: ${color}; border-radius: 2px;"></span>
                                     <span class="text-xs text-gray-700">${label}</span>
                                   </div>`; // åœ–ä¾‹æ–‡å­—ç¸®å°ç‚º text-xs
                });
                legendContainer.innerHTML = legendHTML;
                
                // 5. é‚„åŸå¹³å‡æ•¸è¨ˆç®—
                if (isGroupKeyNumeric) {
                    let numericData = filteredData
                        .map(d => parseNumericValue(d[colKey]))
                        .filter(val => val.isNumeric)
                        .map(val => val.num);
                    if (numericData.length > 0) {
                        const sum = numericData.reduce((a, b) => a + b, 0);
                        const average = sum / numericData.length;
                        document.getElementById(avgId).textContent = `å¹³å‡æ•¸: ${average.toFixed(1)}`;
                    }
                }
            });
        }
        
        // ** æ–°å¢ Q2ï¼šæˆªåœ–å‡½æ•¸ **
        async function downloadScreenshot() {
            const statusEl = document.getElementById('sm-screenshot-status');
            const buttonEl = document.getElementById('sm-download-screenshot');
            // ** ä¿®æ­£ï¼šåªæ“·å–åœ–è¡¨å®¹å™¨ **
            const targetEl = document.getElementById('smallMultiplesContainer'); 
            
            if (!targetEl) return;
            
            // ** æ–°å¢ï¼šæª¢æŸ¥æ˜¯å¦æœ‰åœ–è¡¨ **
            if (targetEl.children.length === 0 || (targetEl.children.length === 1 && targetEl.children[0].tagName === 'P')) {
                statusEl.textContent = 'æ²’æœ‰åœ–è¡¨å¯ä¾›æ“·å–ã€‚';
                statusEl.classList.remove('hidden');
                setTimeout(() => statusEl.classList.add('hidden'), 2000);
                return;
            }

            statusEl.textContent = 'æ­£åœ¨ç”¢ç”Ÿæˆªåœ–... è«‹ç¨å€™...';
            statusEl.classList.remove('hidden');
            buttonEl.disabled = true;

            try {
                const canvas = await html2canvas(targetEl, {
                    useCORS: true, // å…è¨±è·¨åŸŸåœ–ç‰‡ (é›–ç„¶æˆ‘å€‘æ²’æœ‰)
                    scale: 2 // æé«˜è§£æåº¦
                });
                
                const dataUrl = canvas.toDataURL('image/png');
                const link = document.createElement('a');
                link.href = dataUrl;
                link.download = 'dashboard-screenshot.png';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                statusEl.textContent = 'æˆªåœ–å·²ä¸‹è¼‰ï¼';
                setTimeout(() => statusEl.classList.add('hidden'), 2000);

            } catch (error) {
                console.error('æˆªåœ–å¤±æ•—:', error);
                statusEl.textContent = 'æˆªåœ–å¤±æ•—ï¼Œè«‹æª¢æŸ¥ consoleã€‚';
            } finally {
                buttonEl.disabled = false;
            }
        }
        
    </script>
</body>
</html>
